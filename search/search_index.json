{"config":{"lang":["en","pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Bem-vindo ao projeto Redes Abertas!</p> <p>Este projeto tem como objetivo fornecer uma base s\u00f3lida para a configura\u00e7\u00e3o e simula\u00e7\u00e3o de redes utilizando ferramentas modernas e eficientes: NetBox, rNetreplica e Containerlab.</p> <p>O projeto Redes Abertas foi desenvolvido para profissionais e entusiastas da \u00e1rea de redes que desejam:</p> <ul> <li>Explorar: Testar diferentes configura\u00e7\u00f5es de rede em um ambiente controlado.</li> <li>Automatizar: Utilizar templates para padronizar e automatizar as configura\u00e7\u00f5es de dispositivos de rede.</li> <li>Replicar: Reproduzir ambientes de rede reais em laborat\u00f3rios virtuais para testes e valida\u00e7\u00f5es.</li> <li>Gerenciar: Centralizar a documenta\u00e7\u00e3o e o gerenciamento de infraestruturas de rede de maneira eficiente.</li> </ul> <p>Com essas ferramentas, o projeto visa simplificar a cria\u00e7\u00e3o, gerenciamento e documenta\u00e7\u00e3o de topologias de rede complexas, proporcionando flexibilidade e escalabilidade.</p>"},{"location":"#capacidades-do-containerlab","title":"Capacidades do Containerlab","text":"<p>Containerlab \u00e9 uma ferramenta poderosa para a cria\u00e7\u00e3o e gerenciamento de laborat\u00f3rios de rede virtualizados, utilizando cont\u00eaineres Docker. Com ela, voc\u00ea pode testar e simular topologias de rede complexas em um ambiente controlado. A ferramenta suporta diversos dispositivos de rede, permitindo a configura\u00e7\u00e3o de redes multivendor, o que \u00e9 ideal para testar intera\u00e7\u00f5es entre diferentes fornecedores em um mesmo laborat\u00f3rio. Abaixo uma lista dos principais vendors suportados pelo Containerlab: </p>"},{"location":"#fluxograma-dos-laboratorios","title":"Fluxograma dos Laborat\u00f3rios","text":"<p>O fluxograma ilustra o fluxo de trabalho do Netreplica no contexto de um ambiente de simula\u00e7\u00e3o de rede, em integra\u00e7\u00e3o com o Containerlab:</p> <p></p>"},{"location":"#estrutura-do-fluxo-de-trabalho","title":"Estrutura do Fluxo de Trabalho","text":""},{"location":"#1-topologia","title":"1. Topologia","text":"<p>A topologia de rede define a estrutura e interconex\u00e3o dos dispositivos de rede.</p>"},{"location":"#2-netbox","title":"2. NetBox","text":"<p>A topologia \u00e9 documentada e gerenciada no NetBox, uma plataforma centralizada para gerenciamento de infraestrutura de rede. O NetBox armazena informa\u00e7\u00f5es detalhadas sobre dispositivos, endere\u00e7os IP e conex\u00f5es f\u00edsicas.</p>"},{"location":"#3-netreplica","title":"3. Netreplica","text":"<p>O Netreplica sincroniza as informa\u00e7\u00f5es de configura\u00e7\u00e3o do NetBox e prepara os dados para a simula\u00e7\u00e3o. Ele obt\u00e9m os dados via API e gera arquivos de configura\u00e7\u00e3o YAML necess\u00e1rios para a simula\u00e7\u00e3o.</p>"},{"location":"#4-configuracoes","title":"4. Configura\u00e7\u00f5es","text":"<p>O Netreplica gera arquivos de configura\u00e7\u00e3o YAML detalhados que descrevem como os dispositivos de rede devem ser configurados.</p>"},{"location":"#5-containerlab","title":"5. Containerlab","text":"<p>O Containerlab utiliza os arquivos de configura\u00e7\u00e3o gerados para criar e gerenciar topologias de rede complexas em cont\u00eaineres Docker.</p>"},{"location":"#6-laboratorio-stack-docker","title":"6. Laborat\u00f3rio (Stack Docker)","text":"<p>A simula\u00e7\u00e3o \u00e9 executada em um ambiente de laborat\u00f3rio utilizando um stack Docker. A topologia definida \u00e9 reproduzida, permitindo testes e valida\u00e7\u00f5es.</p>"},{"location":"#7-graphite","title":"7. Graphite","text":"<p>Para monitorar e visualizar m\u00e9tricas e desempenho da simula\u00e7\u00e3o, o Graphite \u00e9 integrado ao laborat\u00f3rio. Ele coleta e exibe dados relevantes para an\u00e1lise.</p>"},{"location":"#resumo-do-fluxo","title":"Resumo do Fluxo","text":"<ol> <li>Defini\u00e7\u00e3o da Topologia: A estrutura e interconex\u00e3o dos dispositivos de rede s\u00e3o definidas.</li> <li>Documenta\u00e7\u00e3o no NetBox: A topologia \u00e9 documentada e gerenciada no NetBox.</li> <li>Sincroniza\u00e7\u00e3o com Netreplica: O Netreplica sincroniza as informa\u00e7\u00f5es do NetBox via API e gera configura\u00e7\u00f5es YAML.</li> <li>Cria\u00e7\u00e3o de Topologia com Containerlab: O Containerlab usa as configura\u00e7\u00f5es YAML para criar a topologia de rede em cont\u00eaineres Docker.</li> <li>Execu\u00e7\u00e3o da Simula\u00e7\u00e3o: A topologia \u00e9 executada em um ambiente de laborat\u00f3rio Docker.</li> <li>Monitoramento com Graphite: O desempenho e as m\u00e9tricas da simula\u00e7\u00e3o s\u00e3o monitorados e visualizados com Graphite.</li> </ol>"},{"location":"#status-do-projeto","title":"Status do Projeto","text":"<p>Projeto em andamento.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Para come\u00e7ar, leia o Guia de Configura\u00e7\u00e3o para aprender como utilizar as ferramentas NetBox, Containerlab e Netreplica em conjunto.</p>"},{"location":"#laboratorios-disponiveis","title":"Laborat\u00f3rios Dispon\u00edveis","text":"<ul> <li>Roteamento OSPF - Laborat\u00f3rio de Configura\u00e7\u00e3o de OSPF baseados na plataforma MX da Juniper em uma topologia em anel.</li> <li>Descoberta - Laborat\u00f3rio de descoberta de dispositivos de rede utilizando OSPF e SNMP, integrando Zabbix e NetBox.</li> <li>Monitoramento ELK - Laborat\u00f3rio de monitoramento de fluxos IPFIX utilizando o Elastic Stack (Elasticsearch, Kibana, Fleet Server e Elastic Agent).</li> <li>Monitoramento Telegraf - Laborat\u00f3rio de monitoramento de fluxos de tr\u00e1fego via Telegraf/IPFIX para InfluxDB.</li> <li>Monitoramento Zabbix - Laborat\u00f3rio de monitoramento de roteadores via SNMP com coleta centralizada pelo Zabbix Server.</li> <li>Configura\u00e7\u00e3o NETCONF - Laborat\u00f3rio de configura\u00e7\u00e3o de dispositivos via NETCONF.</li> </ul>"},{"location":"#ferramentas","title":"Ferramentas","text":"<ul> <li>NetBox: Ferramenta para gerenciamento de infraestrutura de rede</li> <li>Containerlab: Ferramenta para simulac\u00e3o de topologias de rede complexas</li> <li>Netreplica: Ferramenta para replica\u00e7\u00e3o de ambientes de rede do NetBox para o Containerlab</li> <li>ELK: Stack para monitoramento de logs e Fluxos de dados em tempo real</li> <li>Edgeshark: Ferramenta para captura e visualiza\u00e7\u00e3o de tr\u00e1fego de rede</li> <li>LibreNMS: Ferramenta para monitoramento de dispositivos de rede</li> </ul>"},{"location":"#contribua","title":"Contribua","text":"<p>Contribua com o projeto clicando aqui.</p>"},{"location":"Contribua/","title":"Contribua","text":""},{"location":"Contribua/#ferramentas","title":"Ferramentas","text":"<p>Este projeto foi desenvolvido com as seguintes ferramentas:</p> <ul> <li>poetry para gerenciamento de depend\u00eancias</li> <li>taskpy para automa\u00e7\u00e3o de tarefas</li> <li>mkdocs para documenta\u00e7\u00e3o</li> <li>mkdocs-material para tema de documenta\u00e7\u00e3o</li> <li>commitizen para padroniza\u00e7\u00e3o de mensagens de commit</li> </ul>"},{"location":"Contribua/#como-contribuir","title":"Como contribuir","text":"<p>Primeiramente, obrigado por fazer parte deste projeto! Sua ajuda \u00e9 muito bem-vinda.</p> <p>Para contribuir com o projeto, siga as etapas abaixo:</p> <ol> <li>clone o reposit\u00f3rio para sua m\u00e1quina local:</li> </ol> <pre><code>git clone https://git.rnp.br/redes-abertas/docs.git\n</code></pre> <ol> <li>Instale as depend\u00eancias do projeto:</li> </ol> <p>primeiramente, instale o pipx para instalar o poetry documenta\u00e7\u00e3o aqui</p> <p>Agora, instale o poetry, que \u00e9 o gerenciador de depend\u00eancias do projeto:</p> <pre><code>pipx install poetry\n</code></pre> <p>agora dentro da pasta do projeto, instale as depend\u00eancias do projeto:</p> <pre><code>poetry install\n</code></pre> <p>pronto, agora voc\u00ea tem todas as depend\u00eancias do projeto instaladas.</p>"},{"location":"Contribua/#estrutura-de-pastas","title":"Estrutura de pastas","text":"<p>O projeto \u00e9 organizado da seguinte forma:</p> <pre><code>flowchart TD\n    A[./] --&gt; B[docs]\n    B --&gt; C[pt]\n    B --&gt; D[en]\n    B --&gt; E[img]\n    C --&gt; F[Ferramentas]\n    C --&gt; G[Guias]\n    C --&gt; H[inventarios]\n    C --&gt; I[Laborat\u00f3rios]\n    C --&gt; J[Templates]\n</code></pre> <p>onde cada pasta tem a seguinte fun\u00e7\u00e3o:</p> <ul> <li><code>docs</code>: cont\u00e9m a documenta\u00e7\u00e3o do projeto, escrita em Markdown.</li> <li><code>pt</code>: cont\u00e9m a documenta\u00e7\u00e3o em portugu\u00eas.</li> <li><code>en</code>: cont\u00e9m a documenta\u00e7\u00e3o em ingl\u00eas.</li> <li><code>img</code>: cont\u00e9m as imagens usadas na documenta\u00e7\u00e3o.</li> <li><code>Ferramentas</code>: cont\u00e9m as ferramentas que foram testadas e documentadas nos laborat\u00f3rios.</li> <li><code>Guias</code>: cont\u00e9m as guias de configura\u00e7\u00e3o dos laborat\u00f3rios e utiliza\u00e7\u00f5es mais espec\u00edficas do laborat\u00f3rios</li> <li><code>inventarios</code>: cont\u00e9m os invent\u00e1rios dos laboratorios no formato de importa\u00e7\u00e3o do netbox.</li> <li><code>Laborat\u00f3rios</code>: cont\u00e9m os laborat\u00f3rios que foram testados e documentados de topologias de redes.</li> <li><code>Templates</code>: cont\u00e9m os templates do netreplica para vendors ainda n\u00e3o suportados por padr\u00e3o.</li> </ul>"},{"location":"Contribua/#docs","title":"docs","text":"<p>A documenta\u00e7\u00e3o do projeto \u00e9 escrita em Markdown e est\u00e1 localizada na pasta docs. Para contribuir,  edite os arquivos Markdown existentes ou crie novos, seguindo a estrutura de pastas e arquivos j\u00e1 estabelecida.  Cada arquivo deve incluir um t\u00edtulo e uma descri\u00e7\u00e3o, tornando-o uma p\u00e1gina da documenta\u00e7\u00e3o.</p> <p>A estrutura de pastas deve seguir o padr\u00e3o do nome da se\u00e7\u00e3o correspondente,  com um arquivo index.md para a p\u00e1gina inicial da se\u00e7\u00e3o. As demais p\u00e1ginas necess\u00e1rias tamb\u00e9m devem ser em Markdown.  A organiza\u00e7\u00e3o do site \u00e9 feita automaticamente pelo MkDocs.</p> <p>Exmplo:</p> <pre><code>docs/\n    \u251c\u2500\u2500 Se\u00e7\u00e3o/\n    \u2502   \u251c\u2500\u2500 index.md\n</code></pre>"},{"location":"Contribua/#mao-na-massa","title":"M\u00e3o na massa","text":"<p>Agora que voc\u00ea j\u00e1 tem as depend\u00eancias instaladas e entendeu como o poetry funciona, voc\u00ea pode come\u00e7ar a contribuir com o c\u00f3digo, a seguir algumas dicas para contribuir com o projeto assim como utilizar as ferramentas de automa\u00e7\u00e3o e padroniza\u00e7\u00e3o do projeto.</p> <p>Dica</p> <p>antes de come\u00e7ar a editar o c\u00f3digo, \u00e9 importante entrar no ambiente virtual do poetry, para isso, execute o seguinte comando:</p> <p>Aten\u00e7\u00e3o</p> <p>Ap\u00f3s a atualiza\u00e7\u00e3o do poetry de 2025, o comando <code>poetry shell</code> foi transferido para um plugin, para funcionar, execute o seguinte comando: <pre><code>poetry self add poetry-plugin-shell\n</code></pre></p> <pre><code>poetry shell\n</code></pre>"},{"location":"Contribua/#ferramentas_1","title":"Ferramentas","text":"<p>o projeto conta com algumas ferramentas de automa\u00e7\u00e3o e padroniza\u00e7\u00e3o, como o <code>taskpy</code> e o <code>black</code>, que s\u00e3o usadas para automatizar tarefas e padronizar o c\u00f3digo, respectivamente.</p>"},{"location":"Contribua/#traducao-automatica","title":"Tradu\u00e7\u00e3o Autom\u00e1tica","text":"<p>O comando <code>task translate</code> \u00e9 respons\u00e1vel por traduzir os arquivos Markdown localizados na pasta <code>docs/pt</code> para o idioma ingl\u00eas e salvar as tradu\u00e7\u00f5es em <code>docs/en</code> utilizando o modelo Gemini 2.0 Flash para realizar a tradu\u00e7\u00e3o. Ele garante que o conte\u00fado seja traduzido de forma precisa sem alterar a estrutura da documenta\u00e7\u00e3o e mantendo todas as refer\u00eancias e links intactos.</p>"},{"location":"Contribua/#como-configurar-e-utilizar-a-traducao-de-arquivos","title":"Como configurar e utilizar a tradu\u00e7\u00e3o de arquivos","text":"<p>A seguir est\u00e3o as instru\u00e7\u00f5es para configurar corretamente o ambiente e realizar as tradu\u00e7\u00f5es.</p>"},{"location":"Contribua/#passo-1-obter-a-chave-da-api-do-gemini","title":"Passo 1: Obter a chave da API do Gemini","text":"<p>Para utilizar o modelo de tradu\u00e7\u00e3o do Gemini, \u00e9 necess\u00e1rio obter uma chave de API gratuita. Siga as etapas abaixo:</p> <ol> <li>Acesse o Google AI Studio.</li> <li>Logue em uma conta google valida.</li> <li>Clique em Criar chave API.</li> <li>Copie a chave gerada para usar no projeto.</li> </ol> <p>Info</p> <p>Mais sobre a implementa\u00e7\u00e3o o google gemini API acesse a Documenta\u00e7\u00e3o Oficial.</p>"},{"location":"Contribua/#passo-2-configurar-o-arquivo-env","title":"Passo 2: Configurar o arquivo <code>.env</code>","text":"<p>No diret\u00f3rio do projeto, voc\u00ea encontrar\u00e1 um arquivo chamado <code>.env.example</code>. Ele servir\u00e1 como um modelo para criar seu arquivo <code>.env</code> contendo as configura\u00e7\u00f5es sens\u00edveis, como a chave de API.</p> <ol> <li>Fa\u00e7a uma c\u00f3pia do arquivo <code>.env.example</code> e renomeie-a para <code>.env</code>:</li> </ol> <pre><code>cp .env.example .env\n</code></pre> <ol> <li>Abra o arquivo <code>.env</code> em qualquer editor de texto e insira a chave do Gemini:</li> </ol> <pre><code>GEMINI_API_KEY=sua-chave-aqui\n</code></pre> <p>Substitua <code>sua-chave-aqui</code> pela chave obtida no Passo 1.</p>"},{"location":"Contribua/#passo-3-executar-a-traducao","title":"Passo 3: Executar a tradu\u00e7\u00e3o","text":"<p>Ap\u00f3s configurar a chave de API no arquivo <code>.env</code>, basta executar o comando abaixo para iniciar a tradu\u00e7\u00e3o:</p> <pre><code>poetry run task translate\n</code></pre> <p>Este comando ir\u00e1: - Traduzir todos os arquivos Markdown (.md) encontrados em <code>docs/pt</code>. - Criar e salvar as tradu\u00e7\u00f5es na pasta <code>docs/en</code>, mantendo a estrutura de diret\u00f3rios id\u00eantica \u00e0 da pasta de origem.</p> <p>Observa\u00e7\u00e3o</p> <p>O comando ir\u00e1 ignorar os arquivos que j\u00e1 estiverem traduzidos e n\u00e3o foram alterados.</p> <p>Aten\u00e7\u00e3o</p> <ul> <li>O comando n\u00e3o traduz os nomes das pastas atualmente. Somente o conte\u00fado dos arquivos ser\u00e1 traduzido.</li> <li>Todos os links e refer\u00eancias internas na documenta\u00e7\u00e3o ser\u00e3o mantidos corretamente, sem altera\u00e7\u00f5es indesejadas.</li> </ul>"},{"location":"Contribua/#funcionalidade-adicional-deteccao-de-mudancas","title":"Funcionalidade adicional: Detec\u00e7\u00e3o de mudan\u00e7as","text":"<p>O script verifica se houve modifica\u00e7\u00f5es nos arquivos originais antes de realizar uma nova tradu\u00e7\u00e3o. Isso garante que:</p> <ul> <li>Apenas arquivos que n\u00e3o foram traduzidos ou que foram alterados ter\u00e3o a tradu\u00e7\u00e3o atualizada.</li> <li>Arquivos j\u00e1 traduzidos permanecer\u00e3o inalterados caso n\u00e3o exista necessidade de tradu\u00e7\u00e3o.</li> </ul> <p>Sobre a tradu\u00e7\u00e3o</p> <p>A tradu\u00e7\u00e3o utiliza o modelo Gemini 2.0 Flash, que realiza tradu\u00e7\u00e3o altamente precisa e confi\u00e1vel. No entanto, como modelos autom\u00e1ticos est\u00e3o sujeitos a erro dependendo do contexto, \u00e9 sempre recomendada uma revis\u00e3o final do conte\u00fado traduzido.</p>"},{"location":"Contribua/#dicas-para-contribuir-com-a-traducao","title":"Dicas para contribuir com a tradu\u00e7\u00e3o","text":"<ul> <li>Edite os arquivos originais (em <code>docs/pt</code>) sempre que for realizar altera\u00e7\u00f5es na documenta\u00e7\u00e3o.</li> <li>Ap\u00f3s realizar altera\u00e7\u00f5es, execute novamente o comando <code>task translate</code> para atualizar o conte\u00fado traduzido em ingl\u00eas.</li> </ul> <p>Com isso, a tradu\u00e7\u00e3o da sua documenta\u00e7\u00e3o estar\u00e1 sempre sincronizada com o idioma original.</p>"},{"location":"Contribua/#documentacao","title":"Documenta\u00e7\u00e3o","text":"<p>A documenta\u00e7\u00e3o do projeto \u00e9 escrita em Markdown e est\u00e1 localizada na pasta docs, seguindo a estrutura de pastas, subpastas e arquivos existentes. onde toda a padroniza\u00e7\u00e3o e a recomendada pelo mkdocs e mkdocs-material, logo para visualizar a documenta\u00e7\u00e3o localmente, execute o seguinte comando:</p> <pre><code>poetry run task docs\n</code></pre> <p>Dica</p> <p>Para contribuir com a documenta\u00e7\u00e3o, voc\u00ea pode editar os arquivos Markdown diretamente ou criar novos arquivos conforme necess\u00e1rio, seguindo a estrutura de pastas, subpastas e arquivos existentes.</p> <p>Dica</p> <p>Voc\u00ea pode utilizar qualquer feature disponivel no mkdocs de personaliza\u00e7\u00f5es, para saber mais acesse a documenta\u00e7\u00e3o abaixo:</p> <p>links uteis:</p> <ul> <li>mkdocs-admonitions: documenta\u00e7\u00e3o para as admonitions(anota\u00e7\u00f5es de documenta\u00e7\u00e3o)</li> <li>mkdocs-emojis : documenta\u00e7\u00e3o para os emojis</li> <li>mermaid : documenta\u00e7\u00e3o para o mermaid(diagrama de fluxo em markdown)</li> </ul>"},{"location":"Contribua/#commits","title":"Commits","text":"<p>O projeto utiliza o <code>commitizen</code> para padronizar as mensagens de commit. Para criar um commit, execute o seguinte comando:</p> <p>Observac\u0327a\u0303o</p> <p>voc\u00ea deve esta dentro do ambiente virtual do poetry, se n\u00e3o, execute o seguinte comando:  <pre><code>poetry shell\n</code></pre></p> <pre><code>poetry run task commit\n</code></pre> <p>Agora \u00e9 s\u00f3 preencher as informa\u00e7\u00f5es solicitadas e o commit ser\u00e1 feito de forma padronizada. Ap\u00f3s o commit, voc\u00ea pode fazer o push para o reposit\u00f3rio remoto.</p>"},{"location":"Contribua/#nao-achei-o-que-preciso-aqui","title":"N\u00e3o achei o que preciso aqui","text":"<p>Caso n\u00e3o tenha encontrado o que precisa, voc\u00ea pode abrir uma issue no projeto relatando o que n\u00e3o consegue fazer ou o que precisa ser melhor documentado</p>"},{"location":"Contribua/#melhoria-continua","title":"Melhoria cont\u00ednua","text":"<p>Esse documento pode ser melhorado por qualquer pessoa que tenha interesse em melhora-lo. Ent\u00e3o, sinta-se a vontade para fornecer mais dicas as pessoas que desejam contribuir tamb\u00e9m </p>"},{"location":"Getting%20Started/","title":"Getting started","text":"<p>Este guia abrangente o conduzir\u00e1 pela configura\u00e7\u00e3o de um ambiente de simula\u00e7\u00e3o de rede,\u00a0utilizando as ferramentas Netbox,\u00a0Containerlab e Netreplica.</p>"},{"location":"Getting%20Started/#pre-requisitos","title":"Pr\u00e9-requisitos:","text":"<ul> <li>Conhecimento b\u00e1sico em:<ul> <li>Linux e SSH (Recomenda\u00e7\u00e3o de curso: Introdu\u00e7\u00e3o ao Linux)</li> <li>Docker Basico (Recomenda\u00e7\u00e3o de curso: Docker para Iniciantes)</li> </ul> </li> </ul>"},{"location":"Getting%20Started/#passos","title":"Passos:","text":""},{"location":"Getting%20Started/#1-instalando-o-netbox","title":"1. Instalando o Netbox:","text":"<p>O Netbox \u00e9 uma plataforma centralizada para gerenciamento de infraestrutura de rede, fornecendo documenta\u00e7\u00e3o detalhada de dispositivos, endere\u00e7os IP e conex\u00f5es f\u00edsicas. Ele permite a cria\u00e7\u00e3o de templates de configura\u00e7\u00e3o usando Jinja2, facilitando a automa\u00e7\u00e3o e padroniza\u00e7\u00e3o na configura\u00e7\u00e3o de dispositivos como roteadores e switches. Essa capacidade \u00e9 essencial para manter ambientes de simula\u00e7\u00e3o de rede organizados e prontos para escalar conforme necess\u00e1rio.</p> <ul> <li>Documenta\u00e7\u00e3o Oficial: NetboxLabs</li> <li>Guia De Instala\u00e7\u00e3o: Instala\u00e7\u00e3o do NetBox e Importa\u00e7\u00f5es</li> <li>Resumo:<ul> <li>Certifique-se de ter o Docker instalado em sua maquina</li> <li>Baixe o repositorio oficial do netbox em sua maquina</li> <li>Configure o netbox acessando o .env</li> <li>Suba o compose</li> </ul> </li> </ul>"},{"location":"Getting%20Started/#2-instalando-o-containerlab","title":"2. Instalando o Containerlab:","text":"<p>O Containerlab \u00e9 respons\u00e1vel por simplificar a cria\u00e7\u00e3o e gerenciamento de topologias de rede complexas utilizando cont\u00eaineres Docker. Ele permite definir e interconectar dispositivos de rede virtualizados de maneira eficiente, facilitando a configura\u00e7\u00e3o de ambientes de simula\u00e7\u00e3o e testes de redes. Essa abordagem baseada em Docker simplifica a replica\u00e7\u00e3o de ambientes reais em laborat\u00f3rios virtuais, proporcionando flexibilidade e escalabilidade na configura\u00e7\u00e3o de infraestruturas de rede.</p> <ul> <li>Documenta\u00e7\u00e3o Oficial: Containerlab</li> <li>Resumo:<ul> <li>Instale o Docker e o Docker Compose.</li> <li>Baixe o bin\u00e1rio do Containerlab e adicione-o ao seu PATH.</li> </ul> </li> </ul>"},{"location":"Getting%20Started/#3-instalando-o-netreplica","title":"3. Instalando o Netreplica:","text":"<p>O Netreplica sincroniza dados do Netbox em ambientes de simula\u00e7\u00e3o usando cont\u00eaineres Docker. Ele permite testar configura\u00e7\u00f5es sem afetar o ambiente de produ\u00e7\u00e3o, garantindo consist\u00eancia nos dados e configura\u00e7\u00f5es entre diferentes cen\u00e1rios de rede.</p> <ul> <li>Documenta\u00e7\u00e3o Oficial: Netreplica</li> <li>Guia De Instala\u00e7\u00e3o: Instala\u00e7\u00e3o do NetReplica via Docker</li> <li>Resumo:<ul> <li>Utilize o Docker Compose para iniciar o Netreplica em um cont\u00eainer Docker.</li> <li>Configure o Netreplica para sincronizar com o Netbox.</li> </ul> </li> </ul>"},{"location":"Getting%20Started/#4-configurando-e-executando-o-netreplica-com-o-netbox","title":"4. Configurando e Executando o NetReplica com o Netbox:","text":"<p>Agora vamos detalhar o processo de configura\u00e7\u00e3o para integrar o Netreplica ao Netbox. Esta etapa \u00e9 crucial para garantir que os dados e configura\u00e7\u00f5es do Netbox sejam replicados corretamente em ambientes de simula\u00e7\u00e3o ou testes, utilizando o Netreplica.</p> <ul> <li>Documenta\u00e7\u00e3o Oficial: Netreplica how to use</li> <li>Guia De Configura\u00e7\u00e3o: Guia de Configurando o NetReplica</li> <li>Resumo:<ul> <li>Crie um token de API no Netbox para o Netreplica.</li> <li>Configure o Netreplica para usar o token de API e a URL do Netbox.</li> <li>Inicie o Netreplica e verifique se ele est\u00e1 sincronizando com o Netbox.</li> </ul> </li> </ul>"},{"location":"Getting%20Started/#5-criando-e-configurando-templates-no-netbox","title":"5. Criando e Configurando Templates no Netbox:","text":"<p>Os templates de configura\u00e7\u00e3o de dispositivos s\u00e3o essenciais para fornecer as configura\u00e7\u00f5es necess\u00e1rias ao Netreplica, que posteriormente ser\u00e3o aplicadas nas simula\u00e7\u00f5es de rede.</p> <ul> <li>Documenta\u00e7\u00e3o Oficial: Netbox Configuration Rendering</li> <li>Guia De Configura\u00e7\u00e3o: Cria\u00e7\u00e3o de Templates de configura\u00e7\u00f5es</li> <li>Resumo:<ul> <li>Crie modelos de configura\u00e7\u00e3o para dispositivos de rede,\u00a0como roteadores e switches.</li> <li>Utilize Jinja2 para criar templates din\u00e2micos que se adaptam \u00e0s suas topologias.</li> </ul> </li> </ul>"},{"location":"Ferramentas/","title":"Ferramentas","text":""},{"location":"Ferramentas/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Antes de come\u00e7ar a usar as ferramentas de monitoramento, \u00e9 fundamental configurar a base de comunica\u00e7\u00e3o entre os seus laborat\u00f3rios. Para isso, utilizamos uma rede Docker dedicada chamada br-lab. A rede br-lab facilita a integra\u00e7\u00e3o de ferramentas de an\u00e1lise com os laborat\u00f3rios criados no Containerlab, eliminando a necessidade de configurar repetidamente cada ferramenta para diferentes laborat\u00f3rios.</p>"},{"location":"Ferramentas/#passo-1-configuracao-da-rede-docker-br-lab","title":"Passo 1: Configura\u00e7\u00e3o da Rede Docker br-lab","text":"<p>Acesse o Guia de Configura\u00e7\u00e3o da Rede br-lab para configurar sua rede Docker. Essa rede ser\u00e1 respons\u00e1vel por conectar seus laborat\u00f3rios ao sistema de monitoramento de forma eficiente, permitindo que m\u00faltiplas ferramentas funcionem de maneira integrada.</p>"},{"location":"Ferramentas/#passo-2-escolhendo-a-ferramenta-de-monitoramento","title":"Passo 2: Escolhendo a Ferramenta de Monitoramento","text":"<p>Ap\u00f3s configurar a rede br-lab, voc\u00ea poder\u00e1 selecionar a ferramenta que melhor atenda \u00e0s suas necessidades. Cada uma das ferramentas listadas abaixo oferece funcionalidades espec\u00edficas para diferentes tipos de monitoramento, seja de dispositivos de rede, tr\u00e1fego ou logs.</p>"},{"location":"Ferramentas/#comparacao-de-ferramentas","title":"Compara\u00e7\u00e3o de Ferramentas","text":"<p>A tabela a seguir oferece uma vis\u00e3o geral das ferramentas que cobrimos em nossos tutoriais, destacando seus principais recursos, tipo de monitoramento e op\u00e7\u00f5es de pre\u00e7o:</p>"},{"location":"Ferramentas/#tabela-comparacao-de-ferramentas-de-monitoramento","title":"Tabela: Compara\u00e7\u00e3o de Ferramentas de Monitoramento","text":"Ferramentas Tecnologias de coleta e integra\u00e7\u00e3o Custo Dificuldade de Implementa\u00e7\u00e3o Integra\u00e7\u00f5es Ponto Forte Comunidade/Documenta\u00e7\u00e3o Zabbix SNMP, ICMP, JMX, IPMI, API_rest, Agent, Gratuito F\u00e1cil Grafana, prometheus,elastic, kafka, Graylog, ..etc Alertas avan\u00e7ados Completa ELK Stack Syslog, IPFIX , Netflow, SNMP, ICMP Freemium Moderada Fleet, logstash, filebeat, grafana, .etc An\u00e1lise centralizada de logs, Dashboard prontos Completa Telegraf + InfluxDB + Grafana SNMP, IPFIX, SFLOW, Syslog, gMNIC, Netflow, GRPC, etc Freemium Moderado Prometheus, Loki, Stack modular e escal\u00e1vel Ampla LibreNMS SNMP, Syslog, API_Rest Gratuito F\u00e1cil Grafana, Graylog, Proxmox Autodiscovery M\u00e9dia"},{"location":"Ferramentas/#passo-3-implementacao-e-testes","title":"Passo 3: Implementa\u00e7\u00e3o e Testes","text":"<p>Ap\u00f3s selecionar a ferramenta mais adequada, siga os tutoriais espec\u00edficos para configurar e integrar a solu\u00e7\u00e3o escolhida com seu ambiente de rede criado no Containerlab. Cada guia oferece instru\u00e7\u00f5es passo a passo para garantir uma integra\u00e7\u00e3o suave e funcional das ferramentas de monitoramento com seus laborat\u00f3rios.</p>"},{"location":"Ferramentas/#exemplos-de-cenarios-de-teste","title":"Exemplos de Cen\u00e1rios de Teste:","text":"<ul> <li>Monitoramento de Dispositivos de Rede com LibreNMS: Configure LibreNMS para monitorar switches e roteadores dentro do seu laborat\u00f3rio.</li> <li>An\u00e1lise de Logs e Eventos com ELK Stack: Colete e visualize dados de logs gerados por dispositivos da rede.</li> <li>Captura de Pacotes com EDSHARK: Execute diagn\u00f3sticos de rede e analise pacotes capturados diretamente dos roteadores.</li> </ul>"},{"location":"Ferramentas/#configuracao-de-rede-br-lab-e-enderecos-fixos","title":"Configura\u00e7\u00e3o de Rede br-lab e Endere\u00e7os Fixos","text":"<p>Todas as ferramentas s\u00e3o configuradas para serem atreladas \u00e0 rede br-lab e para facilitar o uso delas, independentemente do laborat\u00f3rio, elas possuem IPs fixos. Esses IPs podem ser consultados na lista abaixo, permitindo que voc\u00ea se conecte diretamente a cada ferramenta sem a necessidade de configura\u00e7\u00f5es adicionais para cada novo laborat\u00f3rio.</p>"},{"location":"Ferramentas/#tabela-ips-fixos-das-ferramentas","title":"Tabela: IPs Fixos das Ferramentas","text":"Servi\u00e7o IP Stack librenms-db 172.10.10.100 librenms librenms-redis 172.10.10.101 librenms librenms-msmtpd 172.10.10.102 librenms librenms-librenms 172.10.10.103 librenms librenms-dispatcher 172.10.10.104 librenms librenms-syslogng 172.10.10.105 librenms librenms-snmptrapd 172.10.10.106 librenms elk-setup 172.10.10.107 ELK elk-elasticsearch 172.10.10.108 ELK elk-kibana 172.10.10.109 ELK elk-fleet-server 172.10.10.110 ELK grafana-grafana 172.10.10.111 Grafana grafana-influxdb 172.10.10.112 Grafana grafana-chronograf 172.10.10.113 Grafana grafana-telegraf 172.10.10.114 Grafana zabbix-server 172.10.10.115 Zabbix zabbix-frontend 172.10.10.116 Zabbix zabbix-agent 172.10.10.117 Zabbix zabbix-database 172.10.10.118 Zabbix <p>Esses IPs fixos garantem uma comunica\u00e7\u00e3o est\u00e1vel e facilitada entre as ferramentas e os laborat\u00f3rios configurados no Containerlab. Com isso, voc\u00ea pode integrar m\u00faltiplas ferramentas de monitoramento de forma eficiente, sem precisar redefinir configura\u00e7\u00f5es de rede a cada novo laborat\u00f3rio.</p> <p>Essa adi\u00e7\u00e3o inclui a configura\u00e7\u00e3o de rede Docker, a explica\u00e7\u00e3o sobre os IPs fixos e como eles facilitam a integra\u00e7\u00e3o das ferramentas no seu ambiente de laborat\u00f3rio.</p>"},{"location":"Ferramentas/#ferramentas-futuras","title":"Ferramentas Futuras","text":"<p>Estamos constantemente testando e adicionando novas ferramentas ao nosso repert\u00f3rio. Algumas op\u00e7\u00f5es que consideramos explorar em breve incluem:</p> <ul> <li>Prometheus: Servidor de monitoramento e visualiza\u00e7\u00e3o de dados.</li> <li>OpenElastic: Uma solu\u00e7\u00e3o escal\u00e1vel e flex\u00edvel para auditoria de logs e eventos, baseada no Elastic Stack.</li> <li>OpenNMS: Ferramenta robusta para monitoramento de redes e sistemas, com foco em redes de grande escala.</li> <li>Akivorado: Ferramenta de monitoramento de fluxo de dados para redes.</li> </ul> <p>Essas ferramentas podem ser integradas ao seu ambiente de laborat\u00f3rio com o Containerlab,  permitindo que voc\u00ea crie um ecossistema robusto para gerenciamento e an\u00e1lise de redes.</p>"},{"location":"Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/","title":"Primeiros Passos: Preparando o Ambiente","text":""},{"location":"Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#1-introducao","title":"1. Introdu\u00e7\u00e3o","text":"<p>Neste guia, abordaremos os primeiros passos para preparar o ambiente de monitoramento usando a rede Docker br-lab.  Esta rede foi criada para facilitar o acesso, monitoramento e uso de ferramentas de an\u00e1lise nos laborat\u00f3rios gerenciados pelo Containerlab.  A configura\u00e7\u00e3o da rede br-lab \u00e9 um passo necess\u00e1rio para a utiliza\u00e7\u00e3o da maioria das ferramentas que ser\u00e3o mostradas neste guia.  Ap\u00f3s a configura\u00e7\u00e3o das ferramentas de monitoramento na rede br-lab, elas poder\u00e3o ser utilizadas em qualquer laborat\u00f3rio,  eliminando a necessidade de reconfigura\u00e7\u00e3o a cada novo ambiente. Isso simplifica os testes de m\u00faltiplas configura\u00e7\u00f5es  e permite a utiliza\u00e7\u00e3o de diversas ferramentas de an\u00e1lise com maior efici\u00eancia.</p>"},{"location":"Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#vantagens","title":"Vantagens:","text":"<ul> <li>Configura\u00e7\u00e3o \u00fanica: As ferramentas de monitoramento s\u00f3 precisam ser configuradas uma vez, independentemente do laborat\u00f3rio em uso.</li> <li>Facilidade nos testes: Possibilita a cria\u00e7\u00e3o e teste de v\u00e1rias configura\u00e7\u00f5es laboratoriais sem a necessidade de ajustes cont\u00ednuos nas ferramentas.</li> <li>Integra\u00e7\u00e3o flex\u00edvel: Permite adicionar facilmente novos laborat\u00f3rios e dispositivos \u00e0 rede sem impactos na infraestrutura j\u00e1 configurada.</li> </ul>"},{"location":"Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#exemplos-de-laboratorios-que-utilizam-a-rede-br-lab","title":"Exemplos de Laborat\u00f3rios que Utilizam a Rede br-lab","text":""},{"location":"Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#diagrama-da-rede-de-monitoramento","title":"Diagrama da Rede de Monitoramento","text":"<p>Abaixo est\u00e1 um exemplo visual que mostra como a rede de monitoramento <code>br-lab</code> est\u00e1 configurada, conectando diferentes laborat\u00f3rios e dispositivos para um ambiente de testes unificado e eficiente. </p>"},{"location":"Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#2-criando-a-rede-docker","title":"2. Criando a Rede Docker","text":""},{"location":"Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#comando-para-criar-a-rede","title":"Comando para Criar a Rede:","text":"<pre><code>docker network create \\\n  --driver=bridge \\\n  --opt com.docker.network.bridge.name=br-lab \\\n  --subnet=172.10.10.0/24 \\\n  br-lab\n</code></pre>"},{"location":"Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#explicacao-dos-parametros","title":"Explica\u00e7\u00e3o dos Par\u00e2metros:","text":"<ul> <li><code>docker network create</code>: Inicia a cria\u00e7\u00e3o de uma nova rede Docker.</li> <li><code>-driver=bridge</code>: Especifica o driver da rede (bridge).</li> <li><code>-opt com.docker.network.bridge.name=br-lab</code>: Define o nome da interface de rede bridge no host.</li> <li><code>-subnet=172.10.10.0/24</code>: Define a sub-rede (at\u00e9 254 IPs dispon\u00edveis).</li> <li><code>br-lab</code>: Nome da rede.</li> </ul>"},{"location":"Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#3-adicionando-containers-a-rede","title":"3. Adicionando Containers \u00e0 Rede","text":""},{"location":"Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#usando-docker-run","title":"Usando Docker Run:","text":"<p>Comando para adicionar um container \u00e0 rede:</p> <pre><code>docker run -d \\\n  --name meu_container \\\n  --network br-lab \\\n  imagem_do_container\n</code></pre>"},{"location":"Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#explicacao-dos-parametros_1","title":"Explica\u00e7\u00e3o dos Par\u00e2metros:","text":"<ul> <li><code>docker run -d</code>: Executa o container em segundo plano.</li> <li><code>-name meu_container</code>: Nome do container.</li> <li><code>-network br-lab</code>: Conecta o container \u00e0 rede <code>br-lab</code>.</li> <li><code>imagem_do_container</code>: Especifica a imagem do container a ser utilizada.</li> </ul>"},{"location":"Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#usando-docker-compose","title":"Usando Docker Compose:","text":"<p>Se a rede j\u00e1 foi criada, use o Docker Compose para configurar containers com IPs est\u00e1ticos.</p> <pre><code>version: '3.8'\n\nnetworks:\n  br-lab:\n    external: true\n\nservices:\n  meu_container:\n    image: imagem_do_container\n    networks:\n      br-lab:\n        ipv4_address: 172.10.10.101 # opcicional para ip estatico\n</code></pre> <p>Aten\u00e7\u00e3o</p> <p>Ao ultilizar ips estaticos, certifique-se de ultilizar ips apos <code>172.10.10.100</code>, afim de evitar conflitos com os containers existentes.</p>"},{"location":"Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#explicacao-da-configuracao","title":"Explica\u00e7\u00e3o da Configura\u00e7\u00e3o:","text":"<ul> <li><code>networks</code>: Define as redes que os servi\u00e7os usar\u00e3o.</li> <li><code>br-lab</code>: Indica que a rede j\u00e1 foi criada externamente (external: true).</li> <li><code>services</code>: Define os containers a serem executados.</li> <li><code>ipv4_address</code>: Atribui um IP est\u00e1tico ao container (recomendado utilizar endere\u00e7os ap\u00f3s <code>172.10.10.100</code>).</li> </ul>"},{"location":"Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#4-funcionamento-da-rede","title":"4. Funcionamento da Rede","text":"<p>A rede <code>br-lab</code> usa o driver <code>bridge</code>, o que permite comunica\u00e7\u00e3o interna entre os containers, mantendo-os isolados do sistema host. Isso oferece:</p> <ul> <li>Isolamento: Os containers n\u00e3o interferem em outros processos do host.</li> <li>Comunica\u00e7\u00e3o interna: Containers podem se comunicar usando IPs na sub-rede especificada.</li> </ul>"},{"location":"Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#5-conectando-roteadores-com-cabos-virtuais","title":"5. Conectando Roteadores com Cabos Virtuais","text":"<p>Para conectar roteadores na rede <code>br-lab</code> usando cabos virtuais via Containerlab, voc\u00ea pode configurar as conex\u00f5es entre interfaces.</p>"},{"location":"Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#exemplo-de-conexoes","title":"Exemplo de Conex\u00f5es:","text":"<pre><code>br-lab:\n  kind: bridge\n\nlinks:\n  - endpoints: [\"route1:eth1\", \"br-lab:eth1\"]\n  - endpoints: [\"route2:eth1\", \"br-lab:eth2\"]\n  - endpoints: [\"route3:eth1\", \"br-lab:eth3\"]\n  - endpoints: [\"route4:eth1\", \"br-lab:eth4\"]\n</code></pre>"},{"location":"Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#explicacao-das-conexoes","title":"Explica\u00e7\u00e3o das Conex\u00f5es:","text":"<ul> <li>Cada linha define um \u201ccabo virtual\u201d conectando duas interfaces de rede (por exemplo, <code>route1:eth1</code> est\u00e1 conectado a <code>br-lab:eth1</code>).</li> <li>Isso permite a comunica\u00e7\u00e3o entre dispositivos (roteadores e ferramentas de monitoramento) atrav\u00e9s dessas interfaces.</li> </ul>"},{"location":"Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#6-conclusao","title":"6. Conclus\u00e3o","text":"<p>Com este guia, voc\u00ea aprendeu a criar e utilizar a rede Docker <code>br-lab</code>, a adicionar containers \u00e0 rede e a conectar roteadores virtualmente. Essa configura\u00e7\u00e3o \u00e9 ideal para monitoramento eficiente em ambientes de laborat\u00f3rio.</p>"},{"location":"Ferramentas/Edgeshark/","title":"Guia de Instala\u00e7\u00e3o e Uso do Edgeshark","text":""},{"location":"Ferramentas/Edgeshark/#1-introducao","title":"1. Introdu\u00e7\u00e3o","text":"<p>Edgeshark \u00e9 uma solu\u00e7\u00e3o inovadora projetada para facilitar a captura e an\u00e1lise de tr\u00e1fego de rede em ambientes containerizados. Ele consiste em dois servi\u00e7os containerizados principais, o Ghostwire e o Packetflix, que trabalham em conjunto para monitorar o tr\u00e1fego de rede dentro de cont\u00eaineres Docker. Al\u00e9m disso, oferece um plugin opcional para o Wireshark, chamado csharg external capture plugin, que permite capturas remotas ao vivo do tr\u00e1fego de rede.</p>"},{"location":"Ferramentas/Edgeshark/#2-instalando-o-edgeshark","title":"2. instalando o Edgeshark","text":"<p>O Edgeshark oferece imagens Docker multi-arquitetura para as arquiteturas <code>linux/amd64</code> e <code>linux/arm64</code>.</p> <p>ATEN\u00c7\u00c3O</p> <p>Certifique-se de que voc\u00ea tem um kernel Linux de pelo menos a vers\u00e3o 4.11 instalado. No entanto, recomendamos fortemente usar a vers\u00e3o 5.6 ou superior.</p> Usando Docker Compose v2Usando BashUsando Industrial Edge <ol> <li>Instale o Docker Compose v2:</li> </ol> <p>Certifique-se de que o plugin Docker Compose v2 esteja instalado. Verifique executando <code>docker compose version</code>, que deve exibir a vers\u00e3o do plugin sem erros. Para usu\u00e1rios Debian, recomendamos instalar os pacotes <code>docker-ce</code> em vez de <code>docker.io</code>, pois s\u00e3o atualizados com mais frequ\u00eancia.</p> <ol> <li>Implanta\u00e7\u00e3o dos servi\u00e7os Edgeshark:</li> </ol> <p>Copie e cole o comando abaixo em um terminal para implantar os servi\u00e7os:</p> <pre><code>wget -q --no-cache -O - \\\nhttps://github.com/siemens/edgeshark/raw/main/deployments/wget/docker-compose-localhost.yaml \\\n| DOCKER_DEFAULT_PLATFORM= docker compose -f - up\n</code></pre> <ol> <li> <p>Acesse a interface:</p> <p>Ap\u00f3s a implanta\u00e7\u00e3o, visite http://localhost:5001 no seu navegador para explorar a rede virtual do seu host de cont\u00eainer.</p> </li> </ol> <p>NOTA</p> <p>Usar DOCKER_DEFAULT_PLATFORM= garante a implanta\u00e7\u00e3o correta das imagens multi-arquitetura e evita problemas, especialmente com o Rosetta da Apple, que pode ter dificuldades com implanta\u00e7\u00f5es de imagens em modo somente leitura.</p> <p>AVISO</p> <p>As implanta\u00e7\u00f5es r\u00e1pidas a seguir expor\u00e3o a porta TCP 5001 (ou 5500) para clientes externos ao seu host. Certifique-se de que sua rede est\u00e1 devidamente protegida.</p> <p>Se o seu sistema n\u00e3o suportar Docker Compose v2, voc\u00ea pode usar um script Bash como alternativa.</p> <ol> <li>Implanta\u00e7\u00e3o via Bash:</li> </ol> <p>Execute o comando abaixo para implantar os servi\u00e7os usando um script Bash:</p> <pre><code>wget -q --no-cache -O - \\\\\n  &lt;https://github.com/siemens/edgeshark/raw/main/deployments/nocomposer/edgeshark.sh&gt; \\\\\n  | DOCKER_DEFAULT_PLATFORM= bash -s up\n</code></pre> <ol> <li> <p>Acesse a interface:</p> <p>Visite http://localhost:5001 no seu navegador para explorar a rede virtual do seu host de cont\u00eainer.</p> </li> </ol> <p>AVISO</p> <p>As implanta\u00e7\u00f5es Esta implanta\u00e7\u00e3o r\u00e1pida expor\u00e1 a porta TCP 5001 para clientes externos ao seu host. Certifique-se de que sua rede est\u00e1 devidamente protegida.</p> <ol> <li> <p>Baixe o aplicativo Edgeshark:</p> <p>Baixe o \u00faltimo arquivo <code>.zip</code> na se\u00e7\u00e3o de lan\u00e7amentos do projeto.</p> </li> <li> <p>Extraia o arquivo: </p> <p>Descompacte o arquivo <code>edgeshark.app</code> contido no arquivo <code>.zip</code>.</p> </li> <li> <p>Importe para o IEM:</p> <p>Importe o arquivo <code>edgeshark.app</code> no seu sistema de gerenciamento Industrial Edge (IEM).</p> </li> <li> <p>Implanta\u00e7\u00e3o no IED:</p> <p>No cat\u00e1logo do seu IEM, implante o aplicativo Edgeshark nos seus dispositivos Industrial Edge (IED).</p> <p>AVISO</p> <p>A interface do Edgeshark e os servi\u00e7os s\u00e3o expostos na porta 5001 nos seus hosts IED sem qualquer autoriza\u00e7\u00e3o de usu\u00e1rio. Isso \u00e9 necess\u00e1rio para suportar a captura remota de pacotes a partir da interface de usu\u00e1rio.</p> </li> <li> <p>Acesse a interface:</p> <p>Navegue at\u00e9 a porta HTTP 5001 no seu IED: <code>http://&lt;endere\u00e7o-ip-do-ied&gt;:5001</code> (certifique-se de usar <code>http:</code> e n\u00e3o <code>https:</code>). Agora voc\u00ea deve ver a interface de usu\u00e1rio do Edgeshark.</p> </li> </ol>"},{"location":"Ferramentas/Edgeshark/#21-plugin-opcional-para-captura-de-pacotes","title":"2.1 Plugin Opcional para Captura de Pacotes","text":"<p>Caso voc\u00ea precise capturar tr\u00e1fego de rede ao vivo dentro dos cont\u00eaineres, \u00e9 necess\u00e1rio instalar o plugin externo cshargextcap para o Wireshark.</p> Windows 64bitLinux 64bitmacOS 64bit <ol> <li> <p>Verifique o Wireshark:    Certifique-se de que voc\u00ea tem uma vers\u00e3o recente do Wireshark (64 bits) instalada. A vers\u00e3o m\u00ednima recomendada \u00e9 a 3.0.2.</p> </li> <li> <p>Instale o plugin:     Baixe e execute o instalador mais recente do plugin, dispon\u00edvel aqui.</p> </li> <li> <p>Inicie a captura:     Na interface web do Edgeshark, clique em um dos bot\u00f5es de Wireshark para iniciar uma sess\u00e3o de captura.</p> </li> </ol> <ol> <li> <p>Instale o Wireshark:    Instale o Wireshark a partir dos reposit\u00f3rios da sua distribui\u00e7\u00e3o e permita que ele seja usado por usu\u00e1rios n\u00e3o root.</p> </li> <li> <p>Adicione seu usu\u00e1rio ao grupo wireshark:     Execute o comando abaixo:</p> <pre><code>sudo gpasswd -a $USER wireshark\n</code></pre> </li> <li> <p>Instale o plugin:    Baixe e instale o pacote do plugin apropriado para sua distribui\u00e7\u00e3o.</p> </li> <li> <p>Inicie a captura:     Na interface web do Edgeshark, clique em um dos bot\u00f5es de Wireshark para iniciar uma sess\u00e3o de captura.</p> </li> </ol> <ol> <li> <p>Baixe o plugin:     Baixe o plugin mais recente para macOS aqui</p> </li> <li> <p>Instale o plugin:      Siga as instru\u00e7\u00f5es de instala\u00e7\u00e3o fornecidas no arquivo baixado.</p> </li> <li> <p>Inicie a captura:     Navegue at\u00e9 a interface web do Edgeshark e clique em um bot\u00e3o de Wireshark para iniciar uma captura ao vivo.</p> </li> </ol>"},{"location":"Ferramentas/Edgeshark/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<p>Agora que o Edshark est\u00e1 instalado, o pr\u00f3ximo passo \u00e9 aprender a utiliz\u00e1-lo de maneira eficaz. Para isso, acesse a p\u00e1gina de uso detalhado clicando aqui e descubra como capturar o tr\u00e1fego de rede em seus cont\u00eaineres utilizando o Edgeshark. Aproveite os recursos dispon\u00edveis para otimizar a coleta de dados e melhorar a visibilidade da sua rede.</p>"},{"location":"Ferramentas/Edgeshark/#referencias","title":"Refer\u00eancias","text":"<p>Para mais informa\u00e7\u00f5es e recursos adicionais sobre o Edgeshark, visite a Documenta\u00e7\u00e3o Oficial.</p>"},{"location":"Ferramentas/Elasticsearch/","title":"Guia de Instala\u00e7\u00e3o do ELK (Elasticsearch)","text":""},{"location":"Ferramentas/Elasticsearch/#1-introducao","title":"1. Introdu\u00e7\u00e3o","text":"<p>Neste guia, abordaremos a configura\u00e7\u00e3o do stack ELK (Elasticsearch, Logstash e Kibana) para monitoramento e  an\u00e1lise de dados em ambientes laboratoriais. O ELK \u00e9 uma poderosa combina\u00e7\u00e3o de ferramentas que permite a coleta,  armazenamento, an\u00e1lise e visualiza\u00e7\u00e3o de dados em tempo real, sendo amplamente utilizado para gerenciamento de logs e  monitoramento de sistemas.</p>"},{"location":"Ferramentas/Elasticsearch/#2-o-que-e-elk","title":"2. O que \u00e9 ELK?","text":"<p> Fonte: Elastic Documentation</p> <p>A imagem acima ilustra o fluxo de dados e a integra\u00e7\u00e3o dos componentes do ELK Stack para monitoramento centralizado e an\u00e1lise em tempo real.</p> <ul> <li> <p>Elasticsearch: Respons\u00e1vel por armazenar e indexar os dados recebidos do Fleet Server. Com capacidade de busca e an\u00e1lise em tempo real, o Elasticsearch \u00e9 o n\u00facleo do ELK Stack, permitindo consultas eficientes em grandes volumes de dados e facilitando uma an\u00e1lise detalhada.</p> </li> <li> <p>Kibana: O Kibana Oferece uma interface gr\u00e1fica onde os dados no Elasticsearch podem ser visualizados e analisados. Kibana tamb\u00e9m gerencia os pacotes e integra\u00e7\u00f5es dispon\u00edveis para os agentes, que podem ser carregados a partir do Package Registry. Com ele, \u00e9 poss\u00edvel criar dashboards, relat\u00f3rios e gr\u00e1ficos, transformando dados brutos em insights visuais.</p> </li> <li> <p>Elastic Agent: Localizados nos dispositivos a serem monitorados, os Elastic Agents coletam dados de logs, m\u00e9tricas e eventos e os enviam ao Fleet Server Cluster. Esses agentes s\u00e3o configurados e gerenciados por pol\u00edticas que controlam quais dados s\u00e3o coletados e para onde s\u00e3o enviados.</p> </li> <li> <p>Fleet Server Cluster: Utilizando um balanceador de carga para alta disponibilidade, o Fleet Server Cluster centraliza o gerenciamento dos Elastic Agents. Ele distribui pol\u00edticas para os agentes, garantindo uma coleta consistente de dados, e depois os encaminha ao Elasticsearch para armazenamento e an\u00e1lise.</p> </li> </ul> <p>Esse fluxo garante que os dados da rede sejam coletados de forma unificada, armazenados de maneira otimizada e disponibilizados para visualiza\u00e7\u00e3o e an\u00e1lise, oferecendo uma solu\u00e7\u00e3o completa e robusta para monitoramento e an\u00e1lise de redes complexas e distribu\u00eddas.</p> <p>Observa\u00e7\u00e3o</p> <p>nesta instala\u00e7\u00e3o n\u00e3o utilizaremos o Logstash, e sim a vers\u00e3o mais morderna de coleta, no qual s\u00e3o os Fleet Server e Fleet Agent, para saber mais acesse a documenta\u00e7\u00e3o oficial sobre Fleet: Documenta\u00e7\u00e3o do Elastic - Fleet</p>"},{"location":"Ferramentas/Elasticsearch/#4-pre-requisitos","title":"4. Pr\u00e9-requisitos","text":"<p>Antes de prosseguir com a configura\u00e7\u00e3o do ELK, \u00e9 necess\u00e1rio configurar a rede br-lab. Para detalhes sobre essa configura\u00e7\u00e3o, consulte o guia Primeiros Passos: Preparando o Ambiente.</p>"},{"location":"Ferramentas/Elasticsearch/#5-preparando-o-ambiente","title":"5. Preparando o Ambiente","text":"<p>Ap\u00f3s garantir que a rede br-lab est\u00e1 configurada, siga os passos abaixo para preparar o ambiente de trabalho.</p>"},{"location":"Ferramentas/Elasticsearch/#6-baixando-o-docker-compose","title":"6. Baixando o Docker Compose","text":"<p>Para baixar o Docker Compose, execute o seguinte comando:</p> Linux/ MacWindows <pre><code>    curl -L -o get.sh \"https://git.rnp.br/redes-abertas/docker-composes/-/raw/main/ELK-Stack/get.sh?inline=false\" &amp;&amp; sh get.sh &amp;&amp; cd ELK-Stack\n</code></pre> <pre><code>    curl -L -o get.bat \"https://git.rnp.br/redes-abertas/docker-composes/-/raw/main/ELK-Stack/get.bat?inline=false\" &amp;&amp; call get.bat &amp;&amp; cd ELK-Stack\n</code></pre> <p>Esse comando faz o download do script de instala\u00e7\u00e3o e, em seguida, navega para o diret\u00f3rio ELK-Stack.</p>"},{"location":"Ferramentas/Elasticsearch/#7-subindo-os-containers","title":"7. Subindo os Containers","text":"<p>Ap\u00f3s baixar o Docker Compose, execute o comando abaixo para iniciar os servi\u00e7os do ELK:</p> <pre><code>docker compose up -d\n</code></pre> <p>Esse comando ir\u00e1 iniciar tr\u00eas containers essenciais para o funcionamento do stack ELK:</p> <ol> <li>Elasticsearch<ul> <li>Descri\u00e7\u00e3o: Motor de busca e armazenamento de dados. Ele permite o armazenamento de documentos em formato JSON e fornece uma API RESTful para busca e an\u00e1lise. Ideal para pesquisa em grandes volumes de dados.</li> <li>IP: <code>172.10.10.201</code></li> <li>Porta padr\u00e3o: <code>9200</code></li> <li>Documenta\u00e7\u00e3o: Elasticsearch Documentation</li> </ul> </li> <li>Kibana<ul> <li>Descri\u00e7\u00e3o: Interface gr\u00e1fica para visualiza\u00e7\u00e3o de dados armazenados no Elasticsearch. O Kibana permite que os usu\u00e1rios criem dashboards interativos e visualiza\u00e7\u00f5es de dados em tempo real, facilitando a an\u00e1lise e interpreta\u00e7\u00e3o de dados.</li> <li>IP: <code>172.10.10.202</code></li> <li>Porta padr\u00e3o: <code>5601</code></li> <li>Documenta\u00e7\u00e3o: Kibana Documentation</li> </ul> </li> <li>Fleet Server<ul> <li>Descri\u00e7\u00e3o: Agente respons\u00e1vel pela coleta de m\u00e9tricas e logs de diferentes fontes e seu envio para o Elasticsearch. O Fleet Server facilita a gest\u00e3o centralizada de agentes de coleta, como o Elastic Agent, permitindo a coleta e envio eficiente de dados.</li> <li>IP: <code>172.10.10.203</code></li> <li>Documenta\u00e7\u00e3o: Fleet Server Documentation</li> </ul> </li> </ol> <p>Acesso</p> <p> Usuario e senha padr\u00e3o - Usu\u00e1rio padr\u00e3o: <code>elastic</code> - Senha padr\u00e3o: <code>admin@123</code></p> <p>Configura\u00e7\u00e3o</p> <p>Para alterar a senha ou a vers\u00e3o do Elasticsearch, edite o arquivo .env.</p>"},{"location":"Ferramentas/Elasticsearch/#8-acessando-a-interface-do-kibana","title":"8. Acessando a Interface do Kibana","text":"<p>Para acessar a interface do Kibana, use o seguinte link:</p> <pre><code>https://&lt;seu-ip&gt;:5601\n</code></pre> <p>Fa\u00e7a login com o usu\u00e1rio e senha padr\u00e3o.</p>"},{"location":"Ferramentas/Elasticsearch/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<ul> <li>Configurar a Coleta IPFIX: Ap\u00f3s a configura\u00e7\u00e3o do ELK, o pr\u00f3ximo passo ser\u00e1 configurar a coleta de dados utilizando o IPFIX, com nosso guia de configura\u00e7\u00e3o de IPFIX.</li> </ul>"},{"location":"Ferramentas/Elasticsearch/Configurando%20IPFIX%20no%20ELK/","title":"Configurando IPFIX no ELK","text":""},{"location":"Ferramentas/Elasticsearch/Configurando%20IPFIX%20no%20ELK/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>O IPFIX (Internet Protocol Flow Information Export) \u00e9 um padr\u00e3o para exporta\u00e7\u00e3o de informa\u00e7\u00f5es de fluxo de rede, que permite monitorar e analisar o tr\u00e1fego em tempo real. Este guia \u00e9 voltado para a configura\u00e7\u00e3o do IPFIX na stack ELK (Elasticsearch, Logstash, Kibana). Antes de come\u00e7ar, certifique-se de que voc\u00ea possui os seguintes pr\u00e9-requisitos:</p> <ul> <li>Instala\u00e7\u00e3o da Stack ELK: Consulte o guia de \"Getting Started\" para instalar o ELK.</li> <li>Acesso ao Fleet: Certifique-se de que o Fleet est\u00e1 configurado no seu ambiente ELK.</li> </ul>"},{"location":"Ferramentas/Elasticsearch/Configurando%20IPFIX%20no%20ELK/#1-acesse-a-sub-aba-fleet-do-management","title":"1. Acesse a Sub-aba Fleet do Management","text":""},{"location":"Ferramentas/Elasticsearch/Configurando%20IPFIX%20no%20ELK/#o-que-e-o-fleet-server-e-o-fleet-agent","title":"O que \u00e9 o Fleet Server e o Fleet Agent?","text":"<ul> <li>Fleet Server: Um componente que gerencia a configura\u00e7\u00e3o e a comunica\u00e7\u00e3o entre os agentes e o servidor ELK. Ele permite o gerenciamento centralizado de agentes.</li> <li>Fleet Agent: Uma ferramenta que coleta dados de sistemas e os envia para o servidor ELK, facilitando a an\u00e1lise e monitoramento de dados.</li> </ul> <p>Mais informa\u00e7\u00f5es</p> <p>para mais informa\u00e7\u00f5es, acesse a documenta\u00e7\u00e3o oficial sobre Fleet server: Documenta\u00e7\u00e3o do Elastic - Fleet</p>"},{"location":"Ferramentas/Elasticsearch/Configurando%20IPFIX%20no%20ELK/#2-modificando-a-politica-do-fleet","title":"2. Modificando a Pol\u00edtica do Fleet","text":""},{"location":"Ferramentas/Elasticsearch/Configurando%20IPFIX%20no%20ELK/#o-que-sao-politicas-do-fleet-server","title":"O que s\u00e3o Pol\u00edticas do Fleet Server?","text":"<p>As pol\u00edticas do Fleet Server definem como os agentes se comportam, quais integra\u00e7\u00f5es s\u00e3o aplicadas e quais dados devem ser coletados. Essas pol\u00edticas s\u00e3o essenciais para personalizar a coleta de dados conforme as necessidades do seu ambiente.</p> <p>Mais informa\u00e7\u00f5es</p> <p>para mais informa\u00e7\u00f5es, acesse a documenta\u00e7\u00e3o oficial sobre pol\u00edticas fleet: Documenta\u00e7\u00e3o do Elastic - Policies</p>"},{"location":"Ferramentas/Elasticsearch/Configurando%20IPFIX%20no%20ELK/#3-acesse-a-politica-fleet-server-policy","title":"3. Acesse a Pol\u00edtica Fleet Server Policy","text":"<ol> <li>Na coluna Agent Policy, clique na pol\u00edtica chamada Fleet Server Policy.</li> <li>Nessa aba, voc\u00ea ver\u00e1 uma lista das integra\u00e7\u00f5es dispon\u00edveis para o agente.</li> </ol>"},{"location":"Ferramentas/Elasticsearch/Configurando%20IPFIX%20no%20ELK/#o-que-sao-integracoes","title":"O que s\u00e3o Integra\u00e7\u00f5es?","text":"<p>As integra\u00e7\u00f5es s\u00e3o pacotes que definem como coletar dados de diferentes fontes. Elas facilitam a configura\u00e7\u00e3o do agente, permitindo que voc\u00ea adicione recursos e funcionalidades conforme necess\u00e1rio.</p> <p>Mais informa\u00e7\u00f5es</p> <p>para mais informa\u00e7\u00f5es, acesse a documenta\u00e7\u00e3o oficial sobre integra\u00e7\u00f5es: Documenta\u00e7\u00e3o do Elastic - Integra\u00e7\u00f5es</p>"},{"location":"Ferramentas/Elasticsearch/Configurando%20IPFIX%20no%20ELK/#4-adicionando-a-integracao-de-netflow","title":"4. Adicionando a Integra\u00e7\u00e3o de NetFlow","text":"<ol> <li>Clique em Add Integration e busque por NetFlow.</li> <li>Selecione a op\u00e7\u00e3o NetFlow Records.</li> </ol>"},{"location":"Ferramentas/Elasticsearch/Configurando%20IPFIX%20no%20ELK/#resumo-da-integracao","title":"Resumo da Integra\u00e7\u00e3o","text":"<p>Ap\u00f3s selecionar a integra\u00e7\u00e3o, ser\u00e1 exibido um pequeno resumo explicando o que esta integra\u00e7\u00e3o faz. Clique em Add NetFlow Records para prosseguir.</p>"},{"location":"Ferramentas/Elasticsearch/Configurando%20IPFIX%20no%20ELK/#5-configuracao-da-integracao","title":"5. Configura\u00e7\u00e3o da Integra\u00e7\u00e3o","text":"<p>Na aba de configura\u00e7\u00e3o, voc\u00ea ver\u00e1 as seguintes op\u00e7\u00f5es:</p> <ul> <li>IP de Escuta: O endere\u00e7o IP onde o agente ir\u00e1 escutar os pacotes IPFIX.</li> <li>Portal de Recep\u00e7\u00e3o: O portal no qual os dados ser\u00e3o recebidos.</li> </ul> <p>Observa\u00e7\u00e3o</p> <p>Voc\u00ea n\u00e3o precisa modificar essas configura\u00e7\u00f5es, pois elas est\u00e3o definidas para funcionar com a configura\u00e7\u00e3o padr\u00e3o. Para mais informa\u00e7\u00f5es, acesse a documenta\u00e7\u00e3o oficial: Documenta\u00e7\u00e3o do Elastic - Integra\u00e7\u00f5es NetFlow</p>"},{"location":"Ferramentas/Elasticsearch/Configurando%20IPFIX%20no%20ELK/#6-finalizando-a-configuracao","title":"6. Finalizando a Configura\u00e7\u00e3o","text":"<ol> <li>Clique em Save and Continue.</li> <li>Em seguida, clique em Save and Deploy Changes para aplicar as altera\u00e7\u00f5es.</li> </ol>"},{"location":"Ferramentas/LibreNMS/","title":"em Desenvolvimento","text":""},{"location":"Ferramentas/Telegraf/","title":"Guia de Instala\u00e7\u00e3o do Telegraf","text":""},{"location":"Ferramentas/Telegraf/#1-introducao","title":"1. Introdu\u00e7\u00e3o","text":"<p>Este guia apresenta a instala\u00e7\u00e3o do Telegraf, uma ferramenta de coleta de m\u00e9tricas que ser\u00e1 utilizada no laborat\u00f3rio br-lab. O Telegraf fornece suporte a diversos protocolos e plugins para coleta de m\u00e9tricas, permitindo sua integra\u00e7\u00e3o com diferentes sistemas e dispositivos. A instala\u00e7\u00e3o utiliza o Docker Compose para provisionar automaticamente os servi\u00e7os necess\u00e1rios, garantindo uma implementa\u00e7\u00e3o pr\u00e1tica e eficiente no ambiente do laborat\u00f3rio.</p>"},{"location":"Ferramentas/Telegraf/#2-o-que-e-o-telegraf","title":"2. O que \u00e9 o Telegraf?","text":"<p>O Telegraf \u00e9 um agente de coleta de m\u00e9tricas altamente configur\u00e1vel desenvolvido pela InfluxData. Ele \u00e9 compat\u00edvel com uma ampla variedade de protocolos e plugins, o que possibilita capturar e processar m\u00e9tricas de sistemas, dispositivos, aplica\u00e7\u00f5es e servi\u00e7os em tempo real.</p>"},{"location":"Ferramentas/Telegraf/#principais-componentes","title":"principais Componentes:","text":"<ol> <li>Telegraf: Agente de coleta de dados configur\u00e1vel.</li> <li>InfluxDB: Banco de dados de s\u00e9ries temporais onde os dados do Telegraf ser\u00e3o armazenados.</li> <li>Grafana: Ferramenta para visualiza\u00e7\u00e3o e an\u00e1lise dos dados coletados.</li> <li>Chronograf: Interface gr\u00e1fica adicional para consulta e an\u00e1lise de dados no InfluxDB.</li> </ol> <p>Essa arquitetura integra captura, armazenamento e visualiza\u00e7\u00e3o de m\u00e9tricas, garantindo flexibilidade e efici\u00eancia no monitoramento do ambiente.</p>"},{"location":"Ferramentas/Telegraf/#3-pre-requisitos","title":"3. Pr\u00e9-requisitos","text":"<p>Certifique-se de atender aos seguintes pr\u00e9-requisitos antes da instala\u00e7\u00e3o:</p> <ol> <li> <p>Rede br-lab configurada:</p> <ul> <li>A rede br-lab \u00e9 obrigat\u00f3ria para isolar os servi\u00e7os no ambiente. Para mais detalhes sobre essa configura\u00e7\u00e3o, consulte o guia Primeiros Passos: Preparando o Ambiente.</li> </ul> </li> <li> <p>Pacotes Necess\u00e1rios:</p> <ul> <li><code>docker</code>, <code>docker-compose</code>, <code>curl</code>.</li> </ul> </li> </ol>"},{"location":"Ferramentas/Telegraf/#4-preparando-o-ambiente","title":"4. Preparando o Ambiente","text":""},{"location":"Ferramentas/Telegraf/#41-baixando-o-script-de-instalacao","title":"4.1. Baixando o Script de Instala\u00e7\u00e3o","text":"<p>Execute o comando abaixo para baixar e configurar os servi\u00e7os necess\u00e1rios:</p> Linux/ MacWindows <pre><code>    curl -L -o get.sh \"https://git.rnp.br/redes-abertas/docker-composes/-/raw/main/Telegraf/get.sh?inline=false\" &amp;&amp; sh get.sh &amp;&amp; cd Telegraf\n</code></pre> <pre><code>    curl -L -o get.bat \"https://git.rnp.br/redes-abertas/docker-composes/-/raw/main/Telegraf/get.bat?inline=false\" &amp;&amp; call get.bat &amp;&amp; cd Telegraf\n</code></pre> <p>Esse comando:</p> <ul> <li>Baixar\u00e1 o arquivo do Docker Compose contendo a configura\u00e7\u00e3o dos servi\u00e7os.</li> <li>Criar\u00e1 o diret\u00f3rio Telegraf, onde os arquivos necess\u00e1rios ser\u00e3o armazenados.</li> </ul>"},{"location":"Ferramentas/Telegraf/#5-subindo-os-containers","title":"5. Subindo os Containers","text":"<p>Para iniciar os servi\u00e7os do Telegraf e seus componentes, execute:</p> <pre><code>docker compose up -d\n</code></pre> <p>Isso iniciar\u00e1 os seguintes containers:</p> <ol> <li> <p>Telegraf: Agente de coleta de dados com suporte a v\u00e1rios protocolos e formatos.</p> <ul> <li>IP: <code>172.10.10.114</code></li> <li>Volumes mapeados:<ul> <li>Configura\u00e7\u00e3o do Telegraf.</li> <li>Diret\u00f3rios do sistema do host (proc, sys, etc).</li> </ul> </li> <li>Documenta\u00e7\u00e3o: Telegraf Documentation</li> </ul> </li> <li> <p>InfluxDB: Banco de dados para armazenar as m\u00e9tricas coletadas pelo Telegraf.</p> <ul> <li>IP: <code>172.10.10.112</code></li> <li>Credenciais de acesso:<ul> <li>Username: <code>admin</code></li> <li>Senha: <code>admin</code></li> </ul> </li> <li>Base de dados padr\u00e3o: <code>telemetry</code></li> <li>Documenta\u00e7\u00e3o: InfluxDB Documentation</li> </ul> </li> <li> <p>Grafana: Interface gr\u00e1fica para visualiza\u00e7\u00e3o de m\u00e9tricas armazenadas no InfluxDB.</p> <ul> <li>IP: <code>172.10.10.111</code></li> <li>Porta Padr\u00e3o: <code>3000</code></li> <li>Credenciais:<ul> <li>Usu\u00e1rio: <code>admin</code></li> <li>Senha: <code>admin</code></li> </ul> </li> <li>Documenta\u00e7\u00e3o: Grafana Documentation</li> </ul> </li> <li> <p>Chronograf: Ferramenta adicional para consultas e an\u00e1lises visuais no InfluxDB.</p> <ul> <li>IP: <code>172.10.10.113</code></li> <li>Porta Padr\u00e3o: <code>8888</code></li> <li>Documenta\u00e7\u00e3o: Chronograf Documentation</li> </ul> </li> </ol> <p>Para verificar o status de execu\u00e7\u00e3o dos containers:</p> <pre><code>docker compose ps\n</code></pre>"},{"location":"Ferramentas/Telegraf/#6-acessando-os-componentes","title":"6. Acessando os Componentes","text":""},{"location":"Ferramentas/Telegraf/#61-acesso-ao-grafana","title":"6.1. Acesso ao Grafana","text":"<p>Ap\u00f3s inicializar os servi\u00e7os, o Grafana estar\u00e1 acess\u00edvel pelo endere\u00e7o:</p> <pre><code>http://&lt;IP_DO_SERVIDOR&gt;:3000\n</code></pre> <p>Fa\u00e7a login utilizando as credenciais padr\u00e3o abaixo:</p> <ul> <li>Usu\u00e1rio: <code>admin</code></li> <li>Senha: <code>admin</code></li> </ul>"},{"location":"Ferramentas/Telegraf/#62-acesso-ao-chronograf","title":"6.2. Acesso ao Chronograf","text":"<p>O Chronograf pode ser acessado em:</p> <pre><code>http://&lt;IP_DO_SERVIDOR&gt;:8888\n</code></pre> <p>Use as credenciais configuradas no InfluxDB para acessar e configurar consultas.</p>"},{"location":"Ferramentas/Telegraf/#8-proximos-passos","title":"8. Pr\u00f3ximos Passos","text":"<ul> <li>Criar Dashboards personalizados no Grafana: Explore as m\u00e9tricas para criar visualiza\u00e7\u00f5es espec\u00edficas para suas necessidades.</li> <li>Adicionar Fontes de Dados ao Telegraf: Amplie o uso configurando o Telegraf para coletar m\u00e9tricas de outras fontes de interesse no laborat\u00f3rio.</li> </ul> <p>Para mais informa\u00e7\u00f5es sobre o Telegraf, consulte a documenta\u00e7\u00e3o oficial do Telegraf.</p>"},{"location":"Ferramentas/Visual%20Studio%20Code/","title":"Visual Studio Code","text":"<p>O Containerlab possui uma extens\u00e3o oficial para o Visual Studio Code, que facilita significativamente a cria\u00e7\u00e3o, edi\u00e7\u00e3o, visualiza\u00e7\u00e3o e gerenciamento de topologias em formato YAML. Este guia mostra como instalar a extens\u00e3o, explorar seus recursos e utiliz\u00e1-la inclusive em ambientes remotos.</p>"},{"location":"Ferramentas/Visual%20Studio%20Code/#1-instalacao-da-extensao","title":"1. Instala\u00e7\u00e3o da Extens\u00e3o","text":""},{"location":"Ferramentas/Visual%20Studio%20Code/#pre-requisitos","title":"Pr\u00e9-requisitos","text":"<ul> <li>Visual Studio Code instalado.</li> <li>Containerlab instalado (documenta\u00e7\u00e3o oficial).</li> <li>Docker instalado e em execu\u00e7\u00e3o no sistema.</li> </ul>"},{"location":"Ferramentas/Visual%20Studio%20Code/#instalacao","title":"Instala\u00e7\u00e3o","text":"<ol> <li>Acesse o marketplace do Visual Studio Code.</li> <li>Pesquise por: <code>Containerlab</code>.</li> <li>Ou acesse diretamente: Containerlab Extension.</li> <li>Ap\u00f3s instalar, voc\u00ea ver\u00e1 um \u00edcone do Containerlab na barra lateral esquerda.</li> </ol>"},{"location":"Ferramentas/Visual%20Studio%20Code/#2-uso-basico","title":"2. Uso B\u00e1sico","text":""},{"location":"Ferramentas/Visual%20Studio%20Code/#criando-e-editando-topologias","title":"Criando e Editando Topologias","text":"<ul> <li>Crie arquivos com extens\u00e3o <code>.clab.yml</code> para definir sua topologia.</li> <li>Clique no \u00edcone do Containerlab na barra lateral e selecione \"Criar Topologia\".</li> <li>Um novo arquivo ser\u00e1 aberto com estrutura base para defini\u00e7\u00e3o de n\u00f3s e links.</li> </ul>"},{"location":"Ferramentas/Visual%20Studio%20Code/#acoes-rapidas-via-explorer","title":"A\u00e7\u00f5es R\u00e1pidas via Explorer","text":"<p>Na visualiza\u00e7\u00e3o lateral:</p> <ul> <li>As topologias s\u00e3o listadas automaticamente.</li> <li> <p>Clique com o bot\u00e3o direito sobre uma topologia para acessar:</p> </li> <li> <p><code>Deploy</code></p> </li> <li><code>Destroy</code></li> <li><code>Redeploy</code></li> <li><code>Graph</code></li> <li> <p>Estados do lab s\u00e3o exibidos com \u00edcones coloridos:</p> </li> <li> <p>\ud83d\udfe0 Criando cont\u00eaineres</p> </li> <li>\ud83d\udfe2 Lab em execu\u00e7\u00e3o</li> <li>\ud83d\udd34 Erro na cria\u00e7\u00e3o</li> </ul>"},{"location":"Ferramentas/Visual%20Studio%20Code/#21-aba-dos-nos","title":"2.1 Aba dos N\u00f3s","text":"<p>Ao expandir uma topologia:</p> <ul> <li>Cada n\u00f3 ser\u00e1 listado com seu nome e status.</li> <li> <p>Clique com o bot\u00e3o direito no n\u00f3 para:</p> </li> <li> <p>Conectar via SSH/Telnet.</p> </li> <li>Abrir terminal (docker exec).</li> <li>Copiar informa\u00e7\u00f5es: IP, MAC, vendor, nome.</li> <li>Iniciar/parar/reiniciar o n\u00f3.</li> <li>Salvar configura\u00e7\u00f5es do n\u00f3.</li> <li>Visualizar logs.</li> <li>Abrir porta web do n\u00f3 (se aplic\u00e1vel).</li> <li>Acessar o painel de Link Impairments.</li> </ul>"},{"location":"Ferramentas/Visual%20Studio%20Code/#interfaces","title":"Interfaces","text":"<ul> <li>Clique com o bot\u00e3o esquerdo no n\u00f3 para expandir suas interfaces.</li> <li> <p>Para cada interface:</p> </li> <li> <p>Estado da interface \u00e9 exibido.</p> </li> <li>Clique com o bot\u00e3o direito \u2192 \"Abrir com Wireshark\" (requer o plugin do Edgeshark instalado).</li> </ul>"},{"location":"Ferramentas/Visual%20Studio%20Code/#22-visualizando-topologias-com-topoviewer","title":"2.2 Visualizando Topologias com TopoViewer","text":"<ul> <li>Na visualiza\u00e7\u00e3o lateral, clique com o bot\u00e3o direito em uma topologia.</li> <li>Selecione \"Graph Topo View\".</li> <li> <p>Ser\u00e1 aberta uma visualiza\u00e7\u00e3o gr\u00e1fica (TopoViewer) mostrando:</p> </li> <li> <p>N\u00f3s com \u00edcones customiz\u00e1veis via <code>labels</code>.</p> </li> <li>Conex\u00f5es.</li> <li>Agrupamento e geolocaliza\u00e7\u00e3o (opcional via <code>geo-lat</code>, <code>geo-long</code>).</li> </ul>"},{"location":"Ferramentas/Visual%20Studio%20Code/#3-acesso-remoto-via-ssh","title":"3. Acesso Remoto via SSH","text":"<p>A extens\u00e3o do Containerlab pode ser usada em conjunto com o Remote - SSH do VS Code, possibilitando uso remoto completo.</p>"},{"location":"Ferramentas/Visual%20Studio%20Code/#passo-a-passo","title":"Passo a Passo","text":"<ol> <li>Instale a extens\u00e3o Remote - SSH.</li> <li>Clique no \u00edcone verde de SSH no canto inferior esquerdo.</li> <li>Selecione \"Conectar a um servidor remoto...\".</li> <li>Preencha as informa\u00e7\u00f5es de conex\u00e3o (host, usu\u00e1rio, etc).</li> <li> <p>Ap\u00f3s conectado:</p> </li> <li> <p>Instale a extens\u00e3o <code>Containerlab</code> no host remoto (via VS Code).</p> </li> <li>Use normalmente a extens\u00e3o com as topologias remotas.</li> </ol>"},{"location":"Ferramentas/Visual%20Studio%20Code/#documentacao-oficial","title":"Documenta\u00e7\u00e3o Oficial","text":"<ul> <li>Documenta\u00e7\u00e3o oficial do Containerlab</li> <li>Documenta\u00e7\u00e3o da extens\u00e3o no Marketplace</li> </ul>"},{"location":"Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/","title":"Guia: Deploy de Laborat\u00f3rios de Rede usando VSCode e Containerlab","text":""},{"location":"Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Este guia apresenta o processo de cria\u00e7\u00e3o e deploy de laborat\u00f3rios de rede utilizando o Visual Studio Code (VSCode) em conjunto com a extens\u00e3o Containerlab. O objetivo \u00e9 demonstrar como essa integra\u00e7\u00e3o pode simplificar experimentos de rede, aproximando a experi\u00eancia de um ambiente real de produ\u00e7\u00e3o. Para profissionais de infraestrutura, o uso dessas ferramentas representa:</p> <ul> <li>Maior previsibilidade em mudan\u00e7as de rede.</li> <li>Agilidade para criar e destruir ambientes de teste.</li> <li>Menor risco operacional, ao validar previamente cen\u00e1rios cr\u00edticos.</li> </ul>"},{"location":"Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#o-que-e-o-vscode","title":"O que \u00e9 o VSCode?","text":"<p>O Visual Studio Code (VSCode) \u00e9 um editor de c\u00f3digo leve e multiplataforma. Embora amplamente utilizado por desenvolvedores, ele tamb\u00e9m oferece recursos essenciais para administradores de sistemas e operadores de rede. Com suporte a extens\u00f5es, o VSCode pode ser transformado em uma plataforma de gerenciamento centralizada, onde voc\u00ea edita arquivos de configura\u00e7\u00e3o, conecta-se a servidores remotos, e agora, com o Containerlab, tamb\u00e9m gerencia laborat\u00f3rios de rede completos.</p>"},{"location":"Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#beneficios-para-a-infraestrutura","title":"Benef\u00edcios para a Infraestrutura","text":""},{"location":"Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#producao","title":"Produ\u00e7\u00e3o","text":"<ul> <li>Valida\u00e7\u00e3o de altera\u00e7\u00f5es em ambientes isolados antes do deploy real.</li> <li>Testes de resili\u00eancia contra falhas de rede.</li> <li>Redu\u00e7\u00e3o de tempo de troubleshooting.</li> </ul>"},{"location":"Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#pesquisa","title":"Pesquisa","text":"<ul> <li>Cria\u00e7\u00e3o de ambientes de teste controlados para simula\u00e7\u00e3o de protocolos.</li> <li>Reproduzir condi\u00e7\u00f5es adversas (delay, jitter, perda de pacotes).</li> <li>Apoio a experimentos acad\u00eamicos e artigos cient\u00edficos.</li> </ul>"},{"location":"Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#operadores-de-rede","title":"Operadores de Rede","text":"<ul> <li>Menos depend\u00eancia de linha de comando para tarefas comuns.</li> <li>Visualiza\u00e7\u00e3o gr\u00e1fica da topologia.</li> <li>Integra\u00e7\u00e3o com ferramentas de documenta\u00e7\u00e3o (TopoView, Draw.io).</li> </ul>"},{"location":"Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#requisitos","title":"Requisitos","text":"<p>Antes de iniciar, verifique:</p> <ul> <li>VSCode instalado em sua m\u00e1quina.</li> <li>Leitura pr\u00e9via da documenta\u00e7\u00e3o do laborat\u00f3rio usado como exemplo:   Lab Monitoramento Zabbix.</li> <li>Familiaridade b\u00e1sica com a interface do VSCode:   Introdu\u00e7\u00e3o ao VSCode.</li> </ul>"},{"location":"Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#uso-remoto-com-ssh","title":"Uso remoto com SSH","text":"<p>Se voc\u00ea pretende executar o VSCode em um host remoto (ex.: servidor ou VM de testes):</p> <ul> <li>Primeiro, instale a extens\u00e3o Remote SSH. Ela permite que o VSCode acesse arquivos e recursos do servidor remoto como se estivessem locais.</li> <li>Ap\u00f3s se conectar ao host remoto, prossiga com a instala\u00e7\u00e3o das demais extens\u00f5es e configura\u00e7\u00e3o do ambiente.</li> </ul> <p>Isso \u00e9 \u00fatil em ambientes de laborat\u00f3rio ou produ\u00e7\u00e3o onde os recursos de hardware para containers n\u00e3o est\u00e3o dispon\u00edveis na sua m\u00e1quina pessoal.</p> <p></p>"},{"location":"Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#1-instalacao-da-extensao-containerlab","title":"1. Instala\u00e7\u00e3o da extens\u00e3o Containerlab","text":"<p>A primeira etapa \u00e9 instalar a extens\u00e3o Containerlab no VSCode. Essa extens\u00e3o adiciona um painel lateral onde \u00e9 poss\u00edvel:</p> <ul> <li>Criar, destruir e editar laborat\u00f3rios.</li> <li>Visualizar topologias de forma gr\u00e1fica.</li> <li>Monitorar logs e status dos n\u00f3s.</li> </ul> <p></p>"},{"location":"Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#11-instalacao-do-edgeshark","title":"1.1 Instala\u00e7\u00e3o do EdgeShark","text":"<p>O EdgeShark \u00e9 uma integra\u00e7\u00e3o que permite abrir capturas de tr\u00e1fego diretamente no VSCode, sem depender do Wireshark externo. Isso simplifica a an\u00e1lise de pacotes nos experimentos de rede, tornando o VSCode uma ferramenta completa para experimenta\u00e7\u00e3o.</p> <p>Para instalar:</p> <ul> <li>Abra a barra de pesquisa superior do VSCode.</li> <li>Digite:</li> </ul> <p><pre><code>&gt;containerlab: install Edgeshark\n</code></pre> * Pressione Enter.</p> <p></p>"},{"location":"Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#2-deploy-de-um-laboratorio","title":"2. Deploy de um Laborat\u00f3rio","text":"<p>Nesta se\u00e7\u00e3o, vamos fazer o deploy do laborat\u00f3rio de monitoramento Zabbix.</p> <ol> <li>Abra a aba lateral do Containerlab no VSCode.</li> <li>Clique em Open Folder e escolha a pasta de trabalho.</li> <li>No terminal integrado, baixe o laborat\u00f3rio de exemplo com os comandos abaixo:</li> </ol> Linux/Mac <pre><code>curl -L -o get.sh \"https://git.rnp.br/redes-abertas/labs/-/raw/main/zabbix-lab/get.sh?ref_type=heads&amp;inline=false\" &amp;&amp; sh get.sh &amp;&amp; cd zabbix-lab\n</code></pre> Windows <pre><code>curl -L -o get.bat \"https://git.rnp.br/redes-abertas/labs/-/raw/main/zabbix-lab/get.bat?ref_type=heads&amp;inline=false\" &amp;&amp; call get.bat &amp;&amp; cd zabbix-lab\n</code></pre> <p>Esse comando baixa um script de instala\u00e7\u00e3o, executa-o e cria a pasta com o laborat\u00f3rio.</p> <p>Ap\u00f3s a conclus\u00e3o, o laborat\u00f3rio aparecer\u00e1 na aba Local Labs. Basta clicar com o bot\u00e3o direito no laborat\u00f3rio e escolher Deploy.</p> <p></p>"},{"location":"Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#3-funcionalidades-principais","title":"3. Funcionalidades Principais","text":""},{"location":"Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#visualizacao-e-edicao","title":"Visualiza\u00e7\u00e3o e edi\u00e7\u00e3o","text":"<p>No TopoView, a topologia \u00e9 exibida de forma gr\u00e1fica, permitindo:</p> <ul> <li>Adicionar ou remover n\u00f3s e links.</li> <li>Alterar interfaces, endere\u00e7amento IP e limita\u00e7\u00f5es de desempenho.</li> <li>Associar arquivos de configura\u00e7\u00e3o diretamente a cada n\u00f3.</li> <li>Editar o arquivo <code>.clab</code> manualmente, caso prefira.</li> </ul> <p>Isso substitui edi\u00e7\u00f5es manuais demoradas em YAML, dando maior agilidade ao processo.</p>"},{"location":"Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#monitoramento-de-nos-e-logs","title":"Monitoramento de n\u00f3s e logs","text":"<p>Cada n\u00f3 da topologia pode ser inspecionado diretamente no VSCode. \u00c9 poss\u00edvel abrir logs em tempo real, o que ajuda no diagn\u00f3stico de falhas e valida\u00e7\u00e3o de funcionamento de servi\u00e7os.</p> <p></p>"},{"location":"Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#captura-e-analise-de-trafego","title":"Captura e an\u00e1lise de tr\u00e1fego","text":"<p>Com o EdgeShark, \u00e9 poss\u00edvel capturar pacotes de interfaces espec\u00edficas dentro da topologia. Essa funcionalidade \u00e9 equivalente ao uso do Wireshark em um ambiente real, sendo ideal para an\u00e1lise de protocolos e troubleshooting.</p> <p></p>"},{"location":"Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#simulacao-de-falhas-link-impairment","title":"Simula\u00e7\u00e3o de falhas (Link Impairment)","text":"<p>O recurso Link Impairment permite adicionar condi\u00e7\u00f5es adversas \u00e0 rede simulada:</p> <p></p> <ul> <li>Delay (ms) \u2013 tempo de resposta.</li> <li>Jitter \u2013 varia\u00e7\u00e3o do delay.</li> <li>Loss (%) \u2013 perda de pacotes.</li> <li>Rate-limit (Mbps) \u2013 limita\u00e7\u00e3o de banda.</li> <li>Corrupt (%) \u2013 corrup\u00e7\u00e3o de pacotes.</li> </ul> <p>Esse tipo de simula\u00e7\u00e3o \u00e9 muito valioso para avaliar como sistemas de produ\u00e7\u00e3o se comportariam em cen\u00e1rios de instabilidade.</p>"},{"location":"Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#outras-opcoes-uteis","title":"Outras op\u00e7\u00f5es \u00fateis","text":"<p>Na aba de gerenciamento, encontramos funcionalidades adicionais:</p> <ol> <li>Destroy (cleanup) \u2013 remove o laborat\u00f3rio e todos os dados persistentes.</li> <li>Redeploy (cleanup) \u2013 reinicia o lab do zero.</li> <li>Save config \u2013 salva a configura\u00e7\u00e3o atual dos n\u00f3s.</li> <li>Inspect \u2013 mostra informa\u00e7\u00f5es de imagem e rede.</li> <li>SSH (all nodes) \u2013 abre sess\u00f5es SSH para todos os n\u00f3s.</li> <li>Graph (draw.io) \u2013 exporta a topologia para documenta\u00e7\u00e3o.</li> <li>Graph (TopoView) \u2013 abre a topologia no visualizador gr\u00e1fico.</li> <li>Edit topology \u2013 edi\u00e7\u00e3o manual da topologia <code>.clab</code>.</li> </ol> <p></p> <p>Essas fun\u00e7\u00f5es complementam o ciclo de vida de um laborat\u00f3rio de rede, desde a cria\u00e7\u00e3o at\u00e9 o descarte e documenta\u00e7\u00e3o.</p>"},{"location":"Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#4-proximos-passos","title":"4. Pr\u00f3ximos Passos","text":"<p>Ap\u00f3s dominar as funcionalidades b\u00e1sicas, recomenda-se:</p> <ul> <li>Fazer deploy de outros labs disponiveis aqui</li> </ul>"},{"location":"Ferramentas/Zabbix/","title":"Guia de Instala\u00e7\u00e3o do Zabbix","text":""},{"location":"Ferramentas/Zabbix/#1-introducao","title":"1. Introdu\u00e7\u00e3o","text":"<p>Este guia apresenta a instala\u00e7\u00e3o do Zabbix, uma ferramenta de monitoramento de c\u00f3digo aberto que ser\u00e1 utilizada para coleta e an\u00e1lise de m\u00e9tricas no laborat\u00f3rio br-lab. O Zabbix proporciona monitoramento em tempo real de dispositivos, servidores e aplica\u00e7\u00f5es, auxiliando na identifica\u00e7\u00e3o e solu\u00e7\u00e3o de problemas. A instala\u00e7\u00e3o utiliza o Docker Compose para provisionar os servi\u00e7os de forma \u00e1gil e pr\u00e9-configurada, garantindo uma implementa\u00e7\u00e3o pr\u00e1tica e eficiente no ambiente do laborat\u00f3rio.</p>"},{"location":"Ferramentas/Zabbix/#2-o-que-e-o-zabbix","title":"2. O que \u00e9 o Zabbix?","text":"<p>O Zabbix \u00e9 uma plataforma de monitoramento de c\u00f3digo aberto que coleta, processa e exibe m\u00e9tricas de desempenho de servidores, aplica\u00e7\u00f5es e dispositivos de rede. Ele oferece uma interface gr\u00e1fica intuitiva, notifica\u00e7\u00f5es de alertas e relat\u00f3rios para identificar problemas e ajudar administradores no gerenciamento proativo de suas infraestruturas.</p>"},{"location":"Ferramentas/Zabbix/#principais-componentes","title":"Principais componentes:","text":"<ul> <li>Servidor Zabbix: Processa dados de monitoramento, armazena no banco de dados e envia alertas.</li> <li>Interface Web (Frontend): Permite a visualiza\u00e7\u00e3o, configura\u00e7\u00e3o e an\u00e1lise das m\u00e9tricas.</li> <li>Agente Zabbix: Coleta m\u00e9tricas do host onde est\u00e1 instalado.</li> <li>Banco de Dados: Armazena dados hist\u00f3ricos, configura\u00e7\u00f5es e estat\u00edsticas de desempenho.</li> </ul>"},{"location":"Ferramentas/Zabbix/#3-pre-requisitos","title":"3. Pr\u00e9-requisitos","text":"<p>Certifique-se de atender aos seguintes pr\u00e9-requisitos antes da instala\u00e7\u00e3o:</p> <ol> <li> <p>Rede br-lab configurada:</p> <ul> <li>A rede br-lab \u00e9 obrigat\u00f3ria para isolar os servi\u00e7os no ambiente. Para mais detalhes sobre essa configura\u00e7\u00e3o, consulte o guia Primeiros Passos: Preparando o Ambiente.</li> </ul> </li> <li> <p>Pacotes Necess\u00e1rios:</p> <ul> <li><code>docker</code>, <code>docker-compose</code>, <code>curl</code>.</li> </ul> </li> </ol>"},{"location":"Ferramentas/Zabbix/#4-preparando-o-ambiente","title":"4. Preparando o Ambiente","text":"<p>Para inicializar rapidamente o ambiente do Zabbix na rede br-lab, utilizaremos o Docker Compose com um script automatizado.</p>"},{"location":"Ferramentas/Zabbix/#5-baixando-o-docker-compose","title":"5. Baixando o Docker Compose","text":"<p>Para baixar o Docker Compose, execute o seguinte comando:</p> Linux/ MacWindows <pre><code>    curl -L -o get.sh \"https://git.rnp.br/redes-abertas/docker-composes/-/raw/main/Zabbix/get.sh?inline=false\" &amp;&amp; sh get.sh &amp;&amp; cd Zabbix\n</code></pre> <pre><code>    curl -L -o get.bat \"https://git.rnp.br/redes-abertas/docker-composes/-/raw/main/Zabbix/get.bat?inline=false\" &amp;&amp; call get.bat &amp;&amp; cd Zabbix\n</code></pre> <p>Esse comando faz o download do script de instala\u00e7\u00e3o e, em seguida, navega para o diret\u00f3rio Zabbix.</p>"},{"location":"Ferramentas/Zabbix/#5-subindo-os-containers","title":"5. Subindo os containers","text":"<p>Para iniciar os servi\u00e7os do Zabbix, use o comando abaixo:</p> <pre><code>docker compose up -d\n</code></pre> <p>Este comando iniciar\u00e1 os seguintes containers:</p> <ol> <li> <p>PostgreSQL: Banco de dados que armazena as m\u00e9tricas do Zabbix.</p> <ul> <li>IP: <code>172.10.10.118</code></li> <li>Credenciais de acesso:<ul> <li>Usuario: <code>zabbix</code></li> <li>Senha: <code>zabbixdatabase</code></li> </ul> </li> <li>Porta Padr\u00e3o: <code>5432</code> (exposta apenas dentro da rede br-lab).</li> </ul> </li> <li> <p>Servidor Zabbix: Componente principal que processa dados e envia alertas.</p> <ul> <li>IP: <code>172.10.10.115</code></li> <li>Porta Padr\u00e3o: <code>10051</code> (para conex\u00e3o com agentes).</li> </ul> </li> <li> <p>Documenta\u00e7\u00e3o: Zabbix documentation </p> </li> <li> <p>Frontend Zabbix: Interface Web para configura\u00e7\u00e3o e visualiza\u00e7\u00e3o.</p> <ul> <li>IP: <code>172.10.10.116</code></li> <li>Porta Padr\u00e3o: <code>880</code> (acess\u00edvel externamente).</li> </ul> </li> <li> <p>Documenta\u00e7\u00e3o: Zabbix documentation</p> </li> <li> <p>Agente Zabbix: Respons\u00e1vel por coletar m\u00e9tricas do host principal.</p> <ul> <li>IP: <code>172.10.10.117</code></li> <li>Porta Padr\u00e3o: <code>10050</code>.</li> </ul> </li> <li>Documenta\u00e7\u00e3o: Zabbix documentation</li> </ol> <p>Para verificar se todos os containers est\u00e3o em execu\u00e7\u00e3o, utilize:</p> <pre><code>docker compose ps\n</code></pre>"},{"location":"Ferramentas/Zabbix/#6-acessando-o-zabbix-frontend","title":"6. Acessando o Zabbix Frontend","text":"<p>Depois que os servi\u00e7os forem inicializados, a interface Web do Zabbix estar\u00e1 dispon\u00edvel no endere\u00e7o:</p> <pre><code>  http://&lt;IP_DO_SERVIDOR&gt;:880\n</code></pre>"},{"location":"Ferramentas/Zabbix/#61-credenciais-de-acesso","title":"6.1. Credenciais de acesso","text":"<p>As credenciais padr\u00e3o para login no Frontend Zabbix s\u00e3o:</p> <ul> <li>Usu\u00e1rio: <code>Admin</code></li> <li>Senha: <code>zabbix</code></li> </ul>"},{"location":"Ferramentas/Zabbix/#62-alterando-a-senha-padrao","title":"6.2. Alterando a senha padr\u00e3o","text":"<p>Por quest\u00f5es de seguran\u00e7a, altere a senha do usu\u00e1rio administrador ap\u00f3s o primeiro login:</p> <ul> <li>Navegue para Administration &gt; Users.</li> <li>Selecione o usu\u00e1rio Admin e clique em Change Password.</li> </ul>"},{"location":"Ferramentas/Zabbix/#8-proximos-passos","title":"8. Pr\u00f3ximos Passos","text":"<p>Com o ambiente do Zabbix configurado, voc\u00ea pode:</p> <ul> <li>Adicionar templates personalizados para monitoramento de servi\u00e7os espec\u00edficos.</li> <li>Integrar o Zabbix com outras ferramentas de automa\u00e7\u00e3o e monitoramento.</li> </ul> <p>Consulte a Zabbix documentation para explorar mais funcionalidades e boas pr\u00e1ticas.</p>"},{"location":"Ferramentas/Zabbix/Configurando%20Auto%20Discovery/","title":"Auto Discovery no Zabbix","text":""},{"location":"Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#1-introducao","title":"1. Introdu\u00e7\u00e3o","text":"<p>O Auto Discovery (descoberta autom\u00e1tica) do Zabbix \u00e9 um recurso avan\u00e7ado que permite detectar dinamicamente hosts e servi\u00e7os em uma rede, eliminando a necessidade de cadastrar dispositivos manualmente. Essa funcionalidade \u00e9 especialmente \u00fatil em ambientes din\u00e2micos, como o laborat\u00f3rio br-lab, onde novos dispositivos podem ser adicionados frequentemente.</p> <p>Neste guia, voc\u00ea aprender\u00e1 a configurar uma regra de descoberta no Zabbix para identificar automaticamente ativos da rede utilizando o protocolo SNMPv2, al\u00e9m de criar uma a\u00e7\u00e3o de cadastro autom\u00e1tico para adicionar os dispositivos descobertos ao monitoramento.</p>"},{"location":"Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#2-pre-requisitos","title":"2. Pr\u00e9-requisitos","text":"<p>Antes de iniciar, verifique os seguintes pr\u00e9-requisitos:</p> <ol> <li> <p>Zabbix devidamente instalado na rede <code>br-lab</code>.    Caso ainda n\u00e3o tenha feito a instala\u00e7\u00e3o, siga o Guia de Instala\u00e7\u00e3o do Zabbix.</p> </li> <li> <p>A rede <code>br-lab</code> deve estar funcional e com dispositivos configurados para responder a requisi\u00e7\u00f5es SNMPv2.</p> </li> <li> <p>O usu\u00e1rio utilizado deve ter permiss\u00f5es administrativas no frontend do Zabbix.</p> </li> </ol>"},{"location":"Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#3-configurando-a-descoberta-automatica","title":"3. Configurando a Descoberta Autom\u00e1tica","text":"<p>A descoberta autom\u00e1tica no Zabbix funciona com base em duas entidades:</p> <ul> <li>Regra de Descoberta (Discovery Rule): Define a faixa de IPs a ser escaneada, o tipo de verifica\u00e7\u00e3o (ex: SNMP, ICMP), e como extrair o nome do host.</li> <li>A\u00e7\u00e3o de Cadastro (Discovery Action): Aplica regras ap\u00f3s a detec\u00e7\u00e3o (ex: adicionar ao monitoramento, aplicar template, mover para grupo).</li> </ul>"},{"location":"Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#31-criando-a-regra-de-descoberta","title":"3.1 Criando a Regra de Descoberta","text":"<p>Para criar uma nova regra:</p> <ol> <li> <p>Acesse o Zabbix Frontend e v\u00e1 para:    <code>Data Collection \u2192 Discovery</code>    Clique em Create discovery rule.</p> </li> <li> <p>Configure os seguintes par\u00e2metros:</p> </li> </ol> Campo Valor Name <code>br-lab</code> Discovery by proxy <code>Zabbix server</code> IP range <code>172.10.10.1-254</code> Update interval <code>1m</code> Device uniqueness criteria <code>IP address</code> Host name <code>SNMPv2 agent \".1.3.6.1.2.1.1.5.0\"</code> Visible name <code>SNMPv2 agent \".1.3.6.1.2.1.1.5.0\"</code> <ol> <li>Adicione um Check com os seguintes par\u00e2metros:</li> </ol> Campo Valor Check type <code>SNMPv2 agent</code> Community <code>public</code> Port <code>161</code> SNMP OID <code>.1.3.6.1.2.1.1.5.0</code> (Nome do host via SNMP) <ol> <li>Salve a regra ap\u00f3s a configura\u00e7\u00e3o.</li> </ol> <p>\u2705 Ao configurar corretamente, a regra varrer\u00e1 toda a sub-rede <code>172.10.10.0/24</code> a cada minuto, buscando dispositivos que respondem a SNMP na porta 161 com a comunity <code>public</code>.</p>"},{"location":"Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#imagens-de-referencia-exemplo","title":"Imagens de Refer\u00eancia (exemplo)","text":""},{"location":"Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#configuracao-geral-da-regra","title":"\ud83d\udcf8 Configura\u00e7\u00e3o Geral da Regra:","text":""},{"location":"Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#configuracao-dos-checks-snmp","title":"\ud83d\udcf8 Configura\u00e7\u00e3o dos Checks SNMP:","text":""},{"location":"Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#_1","title":"Auto Discovery no Zabbix","text":"<p>Claro! Aqui est\u00e1 o trecho aprimorado no estilo acad\u00eamico e t\u00e9cnico, com formata\u00e7\u00e3o clara, explica\u00e7\u00f5es completas e a inclus\u00e3o da se\u00e7\u00e3o de imagens de exemplo para facilitar o entendimento visual:</p> <p>Nota</p> <p>lembre-se de ativar a regra para que ela funcione corretamente. Voc\u00ea pode fazer isso na aba de configura\u00e7\u00e3o da regra de descoberta, marcando a op\u00e7\u00e3o \"Enable\".</p>"},{"location":"Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#32-criando-a-acao-de-cadastro-automatico","title":"3.2 Criando a A\u00e7\u00e3o de Cadastro Autom\u00e1tico","text":""},{"location":"Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#o-que-e-uma-discovery-action","title":"\ud83e\udde0 O que \u00e9 uma Discovery Action?","text":"<p>A a\u00e7\u00e3o de descoberta no Zabbix \u00e9 um conjunto de instru\u00e7\u00f5es que definem o que deve ser feito automaticamente ap\u00f3s a detec\u00e7\u00e3o de um host por uma Discovery Rule. Esse mecanismo permite a automa\u00e7\u00e3o do gerenciamento de infraestrutura, evitando o cadastro manual de dispositivos.</p> <p>Com uma a\u00e7\u00e3o de descoberta configurada, \u00e9 poss\u00edvel:</p> <ul> <li>Inserir o host detectado automaticamente no banco de monitoramento;</li> <li>Associar o host a um ou mais grupos de hosts;</li> <li>Aplicar templates de monitoramento (ex: ICMP, SNMP, sistemas operacionais);</li> <li>Marcar campos do invent\u00e1rio e ativar o host para monitoramento imediato.</li> </ul>"},{"location":"Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#etapas-para-criar-a-acao","title":"\ud83d\udd27 Etapas para Criar a A\u00e7\u00e3o","text":"<ol> <li> <p>No Zabbix Frontend, navegue at\u00e9:    <code>Alerts \u2192 Actions \u2192 Discovery actions</code>.</p> </li> <li> <p>Clique em Create action e configure conforme abaixo:</p> </li> </ol>"},{"location":"Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#aba-action","title":"\ud83e\udde9 Aba \"Action\"","text":"Campo Valor Name <code>Auto Discovery: Network Devices</code> Conditions <ul><li><code>Discovery rule equals br-lab</code></li><li><code>Discovery status equals Discovered</code></li></ul> <p>\ud83d\udca1 Essas condi\u00e7\u00f5es garantem que a a\u00e7\u00e3o ser\u00e1 executada apenas para hosts descobertos com sucesso pela regra <code>br-lab</code>.</p>"},{"location":"Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#aba-operations","title":"\u2699\ufe0f Aba \"Operations\"","text":"<p>Adicione as seguintes opera\u00e7\u00f5es:</p> Tipo de Opera\u00e7\u00e3o Par\u00e2metros Add host Adiciona automaticamente o host descoberto ao banco do Zabbix Add to host groups <code>Discovered hosts</code> Link to templates <code>Juniper MX by SNMP</code> <p>Info</p> <p>O template <code>Juniper MX by SNMP</code> est\u00e1 localizado dentro do grupo <code>Templates/Network Devices</code>. Ele \u00e9 ideal para monitorar equipamentos Juniper da linha MX via SNMP. Caso voc\u00ea utilize outros dispositivos de rede (Cisco, Mikrotik, Dell, etc.), escolha um template apropriado ou crie um personalizado conforme suas necessidades.</p>"},{"location":"Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#imagens-de-exemplo","title":"Imagens de Exemplo","text":""},{"location":"Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#tela-da-aba-action","title":"\ud83d\udcf8 Tela da aba \"Action\"","text":""},{"location":"Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#tela-da-aba-operations","title":"\ud83d\udcf8 Tela da aba \"Operations\"","text":"<p>Com essa a\u00e7\u00e3o configurada, todo dispositivo detectado na rede <code>br-lab</code> com suporte SNMP ser\u00e1 adicionado automaticamente ao Zabbix, com template e grupo de monitoramento definidos, permitindo escalabilidade e agilidade na gest\u00e3o de infraestrutura.</p>"},{"location":"Guias/Netbox/","title":"Netbox","text":""},{"location":"Guias/Netbox/#1instalacao-do-netbox-e-importacoes","title":"1.Instala\u00e7\u00e3o do Netbox e importa\u00e7\u00f5es","text":"<p>NetBox \u00e9 uma aplica\u00e7\u00e3o web open source para gerenciamento de infraestrutura de redes e data centers. Ele permite documentar dispositivos, racks, conex\u00f5es, endere\u00e7os IP, circuitos, entre outros recursos, facilitando o controle e a automa\u00e7\u00e3o do ambiente de TI.</p>"},{"location":"Guias/Netbox/#11-pre-requisitos","title":"1.1 Pr\u00e9-requisitos","text":"<ul> <li>Docker instalado \u2192 Guia oficial</li> <li>Docker Compose instalado \u2192 Guia oficial</li> <li></li> <li>Acesso a Git para clonar reposit\u00f3rios.</li> </ul> <p>Nota: Este procedimento \u00e9 indicado para ambientes de teste ou homologa\u00e7\u00e3o. Para produ\u00e7\u00e3o, revise as configura\u00e7\u00f5es de seguran\u00e7a antes da publica\u00e7\u00e3o.</p>"},{"location":"Guias/Netbox/#12-clonar-o-repositorio-oficial","title":"1.2 Clonar o reposit\u00f3rio oficial","text":"<pre><code>git clone https://github.com/netbox-community/netbox-docker.git\ncd netbox-docker\n</code></pre>"},{"location":"Guias/Netbox/#13-configuracao-de-variaveis-de-ambiente","title":"1.3 Configura\u00e7\u00e3o de Vari\u00e1veis de Ambiente","text":"<p>O reposit\u00f3rio possui arquivos <code>.env</code> de exemplo.</p> <ol> <li>Acesse a pasta <code>env/</code>:</li> </ol> <p><pre><code>cd env\n</code></pre> 2. edite os arquivos conforme necess\u00e1rio:</p> <ul> <li><code>netbox.env</code> \u2192 Configura\u00e7\u00f5es do NetBox (e-mail, secret key, idioma, timezone).</li> <li><code>postgres.env</code> \u2192 Credenciais do banco de dados.</li> <li><code>redis-cache.env</code> \u2192 Credencias do Redis.</li> <li><code>redis.env</code> \u2192 Credencias do Redis.</li> </ul> <p>Recomenda\u00e7\u00e3o: Mesmo para ambientes de teste, altere senhas padr\u00e3o e credenciais antes de colocar em produ\u00e7\u00e3o.</p>"},{"location":"Guias/Netbox/#14-alterar-a-versao-do-netbox-opcional","title":"1.4 Alterar a vers\u00e3o do NetBox (opcional)","text":"<p>Para mudar a vers\u00e3o:</p> <ul> <li>Edite o <code>docker-compose.yml</code> ou <code>docker-compose.override.yml</code> e ajuste a imagem:</li> </ul> <p><pre><code>image: netboxcommunity/netbox:&lt;vers\u00e3o&gt;\n</code></pre> * Consulte as vers\u00f5es compat\u00edveis em: Releases Netbox Docker</p> <p>Aten\u00e7\u00e3o: Altera\u00e7\u00f5es entre vers\u00f5es muito distantes podem exigir ajustes no banco de dados ou configura\u00e7\u00f5es.</p>"},{"location":"Guias/Netbox/#15-configuracao-de-porta-opcional","title":"1.5 Configura\u00e7\u00e3o de Porta (opcional)","text":"<p>Crie o arquivo <code>docker-compose.override.yml</code> para expor uma porta espec\u00edfica:</p> <pre><code>tee docker-compose.override.yml &lt;&lt;EOF\nversion: '3.4'\nservices:\n  netbox:\n    ports:\n      - 8000:8080\nEOF\n</code></pre> <p>Troque <code>8000</code> se a porta estiver em uso (ex.: <code>8080</code> ou <code>8081</code>).</p>"},{"location":"Guias/Netbox/#16-construir-e-subir-os-conteineres","title":"1.6 Construir e subir os cont\u00eaineres","text":"<pre><code>docker compose pull\ndocker compose up -d\n</code></pre> <p>Aten\u00e7\u00e3o</p> <p>Os cont\u00eaineres podem demorar alguns minutos para iniciar. e caso o container netbox fique em loop sempre iniciando, use este comando para reiniciar este container:</p> <p><pre><code>    docker compose restart netbox\n</code></pre> e para acessar os logs basta usar o comando:</p> <pre><code>    docker compose logs -f\n</code></pre>"},{"location":"Guias/Netbox/#17-criar-usuario-administrador","title":"1.7 Criar usu\u00e1rio administrador","text":"<p>Ap\u00f3s a inicializa\u00e7\u00e3o dos cont\u00eaineres:</p> <pre><code>docker compose exec netbox /opt/netbox/netbox/manage.py createsuperuser\n</code></pre> <p>Siga as instru\u00e7\u00f5es para definir usu\u00e1rio, e-mail e senha.</p>"},{"location":"Guias/Netbox/#18-acessar-a-interface-web","title":"1.8 Acessar a interface web","text":"<ul> <li>URL local: http://localhost:8000</li> <li>De outro host: <code>http://&lt;IP_DO_SERVIDOR&gt;:8000</code></li> </ul> <p>Substitua a porta se tiver alterado no passo 5.</p>"},{"location":"Guias/Netbox/#19-resumo-de-boas-praticas-para-producao","title":"1.9 Resumo de boas pr\u00e1ticas para produ\u00e7\u00e3o","text":"<ul> <li>Alterar todas as credenciais padr\u00e3o nos arquivos <code>.env</code>.</li> <li>Configurar certificados TLS (HTTPS) com Nginx ou Traefik.</li> <li>Ativar backup regular do banco de dados PostgreSQL.</li> <li>Monitorar logs e consumo de recursos dos cont\u00eaineres.</li> </ul>"},{"location":"Guias/Netbox/#2-acesso","title":"2. Acesso","text":"<p>Ap\u00f3s concluir a instala\u00e7\u00e3o do NetBox no Docker, voc\u00ea pode acess\u00e1-lo via navegador da web. Por padr\u00e3o, o NetBox estar\u00e1 dispon\u00edvel localmente em http://localhost:8000/. No entanto, se voc\u00ea deseja acessar o NetBox de forma segura atrav\u00e9s de um t\u00fanel SSH, siga as etapas abaixo:</p>"},{"location":"Guias/Netbox/#21-acesso-via-tunel-ssh","title":"2.1 Acesso via tunel ssh","text":"<ol> <li>Agora, para acessar o NetBox de forma segura atrav\u00e9s de um t\u00fanel SSH, voc\u00ea precisar\u00e1 de um servidor remoto com acesso SSH, onde o Docker n\u00e3o precisa estar instalado.</li> <li> <p>No servidor remoto, execute o seguinte comando para criar um t\u00fanel SSH para o NetBox:</p> <pre><code>ssh -N -L 8080:localhost:8080 usuario@endereco_do_servidor\n</code></pre> <ul> <li>Substitua <code>usuario</code> pelo nome de usu\u00e1rio do servidor remoto.</li> <li>Substitua <code>endereco_do_servidor</code> pelo endere\u00e7o IP ou nome de dom\u00ednio do servidor remoto.</li> <li>Ap\u00f3s inserir sua senha SSH, o t\u00fanel ser\u00e1 estabelecido. Agora, o servidor remoto redirecionar\u00e1 as solicita\u00e7\u00f5es da porta 8080 para o NetBox na porta 8000.</li> <li>Em seu computador local, abra o navegador da web e acesse:</li> </ul> <pre><code>&lt;http://localhost:8080/&gt;\n</code></pre> <p>Voc\u00ea ser\u00e1 redirecionado para o NetBox que est\u00e1 sendo executado no servidor remoto por meio do t\u00fanel SSH. Agora voc\u00ea pode acessar o NetBox com seguran\u00e7a.</p> </li> </ol> <p>Lembre-se de que o t\u00fanel SSH manter\u00e1 a conex\u00e3o ativa enquanto o terminal do servidor remoto estiver aberto. Se voc\u00ea deseja manter o t\u00fanel funcionando em segundo plano, adicione a op\u00e7\u00e3o <code>-f</code> ao comando SSH no passo 9:</p> <pre><code>ssh -f -N -L 8080:localhost:8000 usuario@endereco_do_servidor\n</code></pre> <p>Com isso, voc\u00ea poder\u00e1 acessar o NetBox de forma segura por meio de um t\u00fanel SSH, garantindo a prote\u00e7\u00e3o dos seus dados durante a transmiss\u00e3o.</p>"},{"location":"Guias/Netbox/#3-importacao","title":"3. Importa\u00e7\u00e3o","text":"<p>Para a importa\u00e7\u00e3o deve-se organizar os arquivos em formato CSV corretamente formatado, contendo os campos indicados a seguir. Al\u00e9m disso, \u00e9 importante que a importa\u00e7\u00e3o siga a ordem da numera\u00e7\u00e3o dos arquivos conforme consta na prepara\u00e7\u00e3o dos dados.</p>"},{"location":"Guias/Netbox/#31-preparacao-dos-dados","title":"3.1. Prepara\u00e7\u00e3o dos dados","text":"<p>A importa\u00e7\u00e3o dos arquivos csv deve seguir a numera\u00e7\u00e3o estabelecida e conter as informa\u00e7\u00f5es indicadas. Os nomes (em negrito) indicam os locais de importa\u00e7\u00e3o, e as informa\u00e7\u00f5es abaixo (em it\u00e1lico) indicam os campos necess\u00e1rios para a importa\u00e7\u00e3o.</p> <ol> <li>manufacturers name, slug</li> <li> <p>platforms name, slug, manufacturer, napalm_driver, description</p> <p>tags name, items, slug, color, description</p> </li> <li> <p>device_roles name, color, vm_role, description, slug, tag</p> <p>device_types model, manufacturer, part_number, u_height, is_full_depth, slug</p> <p>sites name, status, slug, latitude, longitude</p> <p>tenants name, slug</p> </li> <li> <p>devices name, status, device_role, manufacturer, device_type, site, platform, tag</p> </li> <li> <p>interfaces name, device, label, enabled, type, description</p> <p>VRFs name, rd, tenant, enforce_unique, description, import_targets, export_targets, comments, tags</p> </li> <li> <p>circuit_types name, slug</p> <p>IP_addresses address, vrf, tenant, status, role, device, interface, dns_name, description</p> <p>providers name, slug</p> </li> <li> <p>circuits cid, provider, type, status, tenant, description</p> </li> </ol>"},{"location":"Guias/Netbox/#32-a-importacao","title":"3.2. A importa\u00e7\u00e3o","text":"<ol> <li>Fa\u00e7a login como superusu\u00e1rio: Acesse o NetBox com as credenciais de admin.</li> <li> <p>Encontre a op\u00e7\u00e3o de importa\u00e7\u00e3o: Verifique a se\u00e7\u00e3o relacionada aos dados que deseja importar, e procure por um \u00edcone de importa\u00e7\u00e3o como vemos na Figura 1 abaixo:</p> <p> Figura 1: ao clicar no \u00edcone importa\u00e7\u00e3o \u00e9 possivel fazer o upload do arquivo CSV.</p> </li> <li> <p>Selecione o arquivo CSV: Fa\u00e7a o upload do arquivo CSV com os dados preparados, cada CSV precisa conter os campos conforme descrito a Subse\u00e7\u00e3o 3.1.</p> </li> <li>Inicie a importa\u00e7\u00e3o: Clique em \"Enviar\" ou \"Importar\" para come\u00e7ar o processo.</li> <li>Verifique os resultados: Analise o relat\u00f3rio de importa\u00e7\u00e3o para confirmar o sucesso.</li> </ol>  \ud83d\udca1 **Observa\u00e7\u00e3o:** ap\u00f3s realizar a importa\u00e7\u00e3o do arquivos do item `7.`, \u00e9 necess\u00e1rio incluir as termina\u00e7\u00f5es manualmente. Para isso, sigas as instru\u00e7\u00f5es abaixo para completar a configura\u00e7\u00e3o. clique no circuito criado e no \u00edcone `edit` conforme destacado na imagem abaixo Ent\u00e3o edite as informa\u00e7\u00f5es de `side*` e `interface*`  <ul> <li> <p>Clique em Circuits para ver os circuitos criados na etapa 7. Selecione com 1 clique um dos Circuit ID criado, conforme o indicado na Figura 2.</p> <p>Observa\u00e7\u00e3o: as etapas devem ser feitas para todo Circuito ID existente.</p> </li> </ul> <p> Figura 2: clique no circuit (seta a esquerda), em seguida selecione o Circuirt ID (detacados e indicados com a seta) para realizar a configura\u00e7\u00e3o.</p> <ul> <li>Ap\u00f3s clicar em um dos circuitos, as configura\u00e7\u00f5es do circuito \u00e9 similar a apresentada na Figura 3. As temina\u00e7\u00f5es devem ser editadas clicando no \u00edcone <code>Edit</code> conforme destacado na imagem abaixo. Ao clicar no \u00edcone, o Netbox encaminha para a parte de Cables em Conex\u00f5es, conforme mostra a Figura 4.</li> </ul> <p> Figura 3: tela de um Circuit ID. As edi\u00e7\u00f5es de de cada Temination deve ser realizada clicando em <code>Edit</code> (destacado com a seta).</p> <ul> <li>A Figura 4 apresenta a cria\u00e7\u00e3o dos cabos de conex\u00e3o, a numera\u00e7\u00e3o dos cabos seguem apenas a ordem de cria\u00e7\u00e3o. Os itens <code>Side*</code> e <code>Interface*</code> devem ser preenchidos para finalizar a configura\u00e7\u00e3o da etapa 7.</li> </ul> <p> Figura 4: tela de configura\u00e7\u00e3o dos cabos para conex\u00e3o para a conex\u00e3o entre os dispositivos.</p>  \ud83d\udca1 Lembre-se de adaptar as subcategorias e locais de importa\u00e7\u00e3o de acordo com as funcionalidades espec\u00edficas do seu NetBox. Cada categoria pode ter campos e configura\u00e7\u00f5es \u00fanicas para a importa\u00e7\u00e3o."},{"location":"Guias/Netbox/Plugins/Branching/","title":"Branching Plugin","text":"<p>O plugin Branching para o NetBox \u00e9 uma solu\u00e7\u00e3o que possibilita a cria\u00e7\u00e3o de ramifica\u00e7\u00f5es (branches) dos dados armazenados no sistema, permitindo que diferentes equipes ou ambientes de trabalho fa\u00e7am altera\u00e7\u00f5es, testes e valida\u00e7\u00f5es sem impactar diretamente a base principal. Com ele, o NetBox ganha flexibilidade para gerenciar cen\u00e1rios de versionamento, experimenta\u00e7\u00e3o e colabora\u00e7\u00e3o, facilitando a compara\u00e7\u00e3o de configura\u00e7\u00f5es, o controle de mudan\u00e7as e a consolida\u00e7\u00e3o das atualiza\u00e7\u00f5es na infraestrutura documentada.</p>"},{"location":"Guias/Netbox/Plugins/Branching/#repositorio-do-plugin","title":"Reposit\u00f3rio do Plugin","text":"<p>Copie o link abaixo ou clique a seguir para acessar o Reposit\u00f3rio do Github</p> <pre><code>https://github.com/netboxlabs/netbox-branching\n</code></pre>"},{"location":"Guias/Netbox/Plugins/Branching/#1-requisitos-para-instalacao","title":"1. Requisitos para instala\u00e7\u00e3o","text":"<p>Esta documenta\u00e7\u00e3o utilizou os seguintes componentes com suas respectivas vers\u00f5es:</p> Componentes Vers\u00f5es Netbox v4.2.4 Napalm Plugin v0.5.7"},{"location":"Guias/Netbox/Plugins/Branching/#2-instalando-e-configurando-o-plugin-no-netbox","title":"2. Instalando e Configurando o Plugin no Netbox","text":"<p>Para instalarmos o plugin no Netbox, precisamos alterar e adicionar alguns arquivos  que s\u00e3o respons\u00e1veis pela configura\u00e7\u00e3o do Netbox.</p> <p>Os arquivos s\u00e3o:</p> <ul> <li><code>plugin_requirements.txt</code>.</li> <li><code>DockerFile-Plugins</code>.</li> <li><code>docker-compose.override.yml</code>.</li> <li><code>configuration/plugins.py</code>.</li> <li><code>configuration/local_settings.py</code></li> </ul>"},{"location":"Guias/Netbox/Plugins/Branching/#21-configurando-a-versao-do-netbox","title":"2.1 Configurando a vers\u00e3o do Netbox:","text":"<ol> <li> <p>Primeiro, vamos clonar o reposit\u00f3rio do Netbox: <pre><code>git clone -b release https://github.com/netbox-community/netbox-docker.git\n</code></pre></p> </li> <li> <p>Acesse o diret\u00f3rio clonado: <pre><code>cd netbox-docker\n</code></pre></p> </li> <li> <p>Agora, mude para a release 3.2.1 <pre><code>git checkout 3.2.1\n</code></pre></p> </li> </ol> <p>Informa\u00e7\u00e3o</p> <p>Alteramos a branch do reposit\u00f3rio para termos acesso \u00e0 vers\u00e3o 4.2.4 do Netbox.</p> <p>Dica</p> <p>Todos os comandos abaixos ser\u00e3o executados dentro diret\u00f3rio raiz do netbox <code>netbox-docker/</code>.</p>"},{"location":"Guias/Netbox/Plugins/Branching/#22-plugin_requirementstxt","title":"2.2 plugin_requirements.txt","text":"<p>Este arquivo cont\u00e9m ama lista dos plugins do Netbox (como pacotes Python do PyPO) que devem ser instalados durante a constru\u00e7\u00e3o da imagem Docker.</p> <p>Execute o seguinte comando para escrever o pacote dentro do arquivo <code>plugin_requirements.txt</code>.</p> <pre><code>echo \"netboxlabs-netbox-branching==0.5.7\" &gt;&gt; plugin_requirements.txt\n</code></pre>"},{"location":"Guias/Netbox/Plugins/Branching/#23-dockerfile-plugins","title":"2.3 DockerFile-Plugins","text":"<p>Esse \u00e9 o DockerFile usado para construir a imagem docker customizada.</p> <ol> <li> <p>Crie o arquivo e acesse com um editor:  <pre><code>nano DockerFile-Plugins\n</code></pre></p> </li> <li> <p>Copie o conte\u00fado abaixo e cole no arquivo: <pre><code>FROM netboxcommunity/netbox:v4.2.4\n\nCOPY ./plugin_requirements.txt /opt/netbox/\nRUN /usr/local/bin/uv pip install -r /opt/netbox/plugin_requirements.txt\n\n# Netbox branching =&gt; copy local_settings to container\nCOPY ./configuration/local_settings.py /opt/netbox/netbox/netbox/local_settings.py\n</code></pre></p> </li> </ol>"},{"location":"Guias/Netbox/Plugins/Branching/#24-docker-composeoverrideyml","title":"2.4 docker-compose.override.yml","text":"<p>Como o nome implica, esse arquivo contaim as configura\u00e7\u00f5es que v\u00e3o sobrescrever o <code>docker-compose.yml</code>.</p> <p>Caso voc\u00ea ainda n\u00e3o tenha configurado a rede <code>br-lab</code>. Acesse: Configurando a Rede Docker</p> <ol> <li> <p>Crie o arquivo e acesse com um editor: <pre><code>nano docker-compose.override.yml\n</code></pre></p> </li> <li> <p>Copie o conte\u00fado abaixo e cole no arquivo: <pre><code>services:\n  netbox:\n    image: netbox:latest-plugins\n    pull_policy: never\n    ports:\n      - 8000:8080\n    build:\n      context: .\n      dockerfile: Dockerfile-Plugins\n    networks:\n      - br-lab\n\n  netbox-worker:\n    image: netbox:latest-plugins\n    pull_policy: never\n    networks:\n      - br-lab\n\n  netbox-housekeeping:\n    image: netbox:latest-plugins\n    pull_policy: never\n    networks:\n      - br-lab\n\n  postgres:\n    networks:\n      - br-lab\n\n  redis:\n    networks:\n      - br-lab\n\n  redis-cache:\n    networks:\n      - br-lab\n\nnetworks:\n  br-lab:\n    external: true\n</code></pre></p> </li> </ol> <p>As altera\u00e7\u00f5es feitas foram: </p> <ul> <li>adicionar o Netbox na rede <code>br-lab</code>.</li> <li>altera\u00e7\u00e3o do dockerfile para o <code>Dockerfile-Plugins</code>, criado anteriormente.</li> <li>Tamb\u00e9m alterado a imagem dos servi\u00e7os para: <code>netbox:latest-plugins</code>.</li> </ul>"},{"location":"Guias/Netbox/Plugins/Branching/#25-pluginspy","title":"2.5 plugins.py","text":"<p>Este arquivo \u00e9 respons\u00e1vel por setar as configura\u00e7\u00f5es espec\u00edficas de cada plugin.</p> <ol> <li> <p>Acesse o arquivo com o editor: <pre><code>nano configuration/plugins.py\n</code></pre></p> </li> <li> <p>Copie e cole o conte\u00fado no arquivo: <pre><code>PLUGINS = [\n    \"netbox_branching\"\n]\n</code></pre></p> </li> </ol>"},{"location":"Guias/Netbox/Plugins/Branching/#25-local_settingspy","title":"2.5 local_settings.py","text":"<p>Agora, vamos criar o arquivo de configura\u00e7\u00e3o do plugin que permite que o database do Netbox, consiga criar r\u00e9plica das tabelas.</p> <ol> <li> <p>Primeiro crie o arquivo em <code>./configuration/</code>, com o seguinte comando: <pre><code>nano ./configuration/local_settings.py\n</code></pre></p> </li> <li> <p>Agora, copie o conte\u00fado abaixo, e cole no arquivo criado. <pre><code>import sys\nimport os\n\n# Adiciona o diret\u00f3rio atual ao sys.path\nsys.path.append(os.path.dirname(__file__))\n\nfrom netbox_branching.utilities import DynamicSchemaDict\nfrom configuration import DATABASE\n\n# Wrap DATABASES with DynamicSchemaDict for dynamic schema support\nDATABASES = DynamicSchemaDict({\n    'default': DATABASE,\n})\n\n# Employ our custom database router\nDATABASE_ROUTERS = [\n    'netbox_branching.database.BranchAwareRouter',\n]\n</code></pre></p> </li> </ol>"},{"location":"Guias/Netbox/Plugins/Branching/#3-build-e-deploy","title":"3. Build e Deploy!","text":"<p>Agora seu Netbox est\u00e1 configurado e pronto para o deploy, siga os comandos abaixo e construa a nova instancia do Netbox!</p> <ol> <li> <p>Construa a imagem: <pre><code>docker compose build --no-cache\n</code></pre></p> </li> <li> <p>Suba os containeres: <pre><code>docker compose up -d\n</code></pre></p> </li> <li> <p>Depois de subir os containers, verifique se o usu\u00e1rio PostgreSQL o qual o NetBox usa para autenticar, possui permiss\u00e3o para criar novos schemas no database. O resultado deverar ser: <code>GRANT</code>.</p> </li> </ol> <pre><code>docker exec -it netbox-docker-postgres-1 psql -U netbox -d netbox -c \"GRANT CREATE ON DATABASE netbox TO netbox;\"\n</code></pre>"},{"location":"Guias/Netbox/Plugins/Branching/#4-visualizacao","title":"4. Visualiza\u00e7\u00e3o","text":"<p>Com o plugin instalado voc\u00ea pode visualizar a interface que \u00e9 disponibilizada para voc\u00ea trabalhar com branchs no Netbox</p> <ul> <li> <p>Barra superior   </p> </li> <li> <p>Menu  </p> </li> </ul> <p>Para validar se o plugin est\u00e1 instalado corretamente, basta ir em Menu &gt; Admin &gt; Plugins  </p>"},{"location":"Guias/Netbox/Plugins/Diode/","title":"Diode Plugin","text":"<p>O plugin Diode para o NetBox \u00e9 uma solu\u00e7\u00e3o poderosa para quem deseja automatizar a descoberta e a ingest\u00e3o de dados de dispositivos de rede. Com ele, o NetBox passa a receber informa\u00e7\u00f5es de forma din\u00e2mica por meio de agentes ou scripts personalizados, que realizam a coleta, o tratamento e a inser\u00e7\u00e3o dos dados diretamente no sistema. Essa funcionalidade facilita a integra\u00e7\u00e3o com ambientes complexos e promove uma documenta\u00e7\u00e3o cont\u00ednua e automatizada da infraestrutura de rede.</p>"},{"location":"Guias/Netbox/Plugins/Diode/#repositorio-do-plugin","title":"Reposit\u00f3rio do Plugin","text":"<p>Copie o link abaixo ou clique a seguir para acessar o Reposit\u00f3rio do Github</p> <pre><code>https://github.com/netboxlabs/diode/tree/develop\n</code></pre>"},{"location":"Guias/Netbox/Plugins/Diode/#1-componentes","title":"1. Componentes","text":"<p>O Diode \u00e9 composto por tr\u00eas componentes principais, que trabalham em conjunto para realizar a ingest\u00e3o automatizada de dados no NetBox:</p> <ol> <li> <p>Plugin Diode para NetBox: Respons\u00e1vel pela integra\u00e7\u00e3o com o ORM do NetBox e pela gest\u00e3o de chaves de API, permitindo que o NetBox aceite dados externos de forma segura e estruturada. Instalando o Diode Plugin</p> </li> <li> <p>Servidor Diode (Diode Server): Atua como o n\u00facleo do servi\u00e7o, processando os dados recebidos e realizando a concilia\u00e7\u00e3o (reconciliation) com as informa\u00e7\u00f5es existentes no NetBox. Veja aqui como instalar Instalando o Diode Server</p> </li> <li> <p>Diode Client: Implementado como um SDK em Python, este componente coleta os dados dos dispositivos e os envia ao servidor via gRPC/protobuf. Pode ser facilmente incorporado a scripts personalizados ou integra\u00e7\u00f5es existentes. Veja aqui como instalar Instalando o Diode Client</p> </li> </ol> <p>Dica</p> <p>Os n\u00fameros dos componentes indicam a ordem de instala\u00e7\u00e3o, siga-os para ter uma melhor experi\u00eancia e entendimento do assunto.</p>"},{"location":"Guias/Netbox/Plugins/Diode/#2-arquitetura","title":"2. Arquitetura","text":"<p>Para facilitar a compreens\u00e3o do funcionamento do Diode, o diagrama abaixo ilustra a arquitetura dos seus principais componentes e como eles se comunicam entre si:</p> <p>foto do diagrama</p>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/","title":"Instalando o Diode Client","text":"<p>O Diode Client \u00e9 respons\u00e1vel por enviar os dados coletados para o Diode Server utilizando gRPC/Protobuf, permitindo a posterior ingest\u00e3o dessas informa\u00e7\u00f5es no NetBox.</p> <p>Existem diferentes formas de utilizar o Client. Nesta documenta\u00e7\u00e3o, ser\u00e1 apresentado o uso do Orb Agent, desenvolvido pela NetBox Labs. Esse agente n\u00e3o s\u00f3 realiza a descoberta automatizada de redes e dispositivos, como tamb\u00e9m oferece funcionalidades de observabilidade sobre os equipamentos monitorados.</p> <p>Alternativamente, conforme descrito na documenta\u00e7\u00e3o oficial do NetBox, o Diode Client tamb\u00e9m pode ser utilizado como um SDK Python, ideal para integrar scripts personalizados que coletam e enviam dados para o Diode Server.</p>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#repositorio-do-plugin","title":"Reposit\u00f3rio do Plugin","text":"<p>Copie o link abaixo ou clique a seguir para acessar o Reposit\u00f3rio do Github</p> <pre><code>https://github.com/netboxlabs/orb-agent\n</code></pre>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#1-requisitos-para-instalacao","title":"1. Requisitos para instala\u00e7\u00e3o","text":"<p>Esta documenta\u00e7\u00e3o utilizou os seguintes componentes com suas respectivas vers\u00f5es:</p> Componentes Vers\u00f5es Netbox v4.1.11 Orb Agent v1.2.0"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#2-arquivos-necessarios-para-instalacao","title":"2. Arquivos necess\u00e1rios para instala\u00e7\u00e3o","text":"<ol> <li>Primeiro, vamos criar uma nova pasta para baixar os arquivos do Diode Server. <pre><code>mkdir orb-agent\ncd orb-agent\n</code></pre></li> </ol> <p>Agora, vamos criar os arquivos necess\u00e1rios para a instala\u00e7\u00e3o do Orb-Agent</p>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#21-docker-composeyml","title":"2.1. <code>docker-compose.yml</code>","text":"<ol> <li>Primeiro, vamos criar o arquivo com o seguinte comando: <pre><code>nano docker-compose.yml\n</code></pre></li> <li>Agora copie o conte\u00fado abaixo e cole no arquivo. <pre><code>services:\n  orb-agent:\n    image: docker.io/netboxlabs/orb-agent:${ORB_TAG:-latest}\n    command: run -c /opt/orb/agent.yaml\n    volumes: \n      - ./:/opt/orb/\n    networks:\n      - orb-net\nnetworks:\n  orb-net:\n    external: true\n    name: ${DOCKER_NETWORK}\n</code></pre></li> </ol> <p>O agente precisa estar na mesma rede que cont\u00e9m dispositivos a serem importados, como estamos em um ambiente docker, vamos adiciona-l\u00f3 a rede padr\u00e3o dos laborat\u00f3rios <code>br-lab</code>.</p>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#22-env","title":"2.2. <code>.env</code>","text":"<p>O arquivo que cont\u00e9m as vari\u00e1veis respons\u00e1veis para configura\u00e7\u00e3o do Orb-Agent.</p> <ol> <li> <p>Primeiro, vamos criar o arquivo com o seguinte comando: <pre><code>nano .env\n</code></pre></p> </li> <li> <p>Para preencher a vari\u00e1vel <code>DOCKER_SUBNET</code> com a subnet da rede <code>br-lab</code>, use o comando: <pre><code>docker network inspect br-lab | grep \"Subnet\"\n</code></pre></p> </li> <li> <p>Agora copie o conte\u00fado abaixo e cole no arquivo. <pre><code>ORB_TAG=1.2.0\nDOCKER_NETWORK=br-lab # docker network\n\n# Rede Docker onde o agente ir\u00e1 coletar os IP's\nDOCKER_SUBNET=172.10.10.0/24\n\n# Chave de API para conex\u00e3o com o Diode Server -&gt; diode-ingestion\nDIODE_API_KEY=507006398ea55f210835a66ee98b2a301d9abf6d\n\n# Url do Diode Server\nDIODE_HOST=172.10.10.120:80 \n\n# De sua escolha\nAGENT_NAME=agent1 # nome do Agente\nSITE_NAME=RNP # Nome do Site a ser adicionado/criado no Netbox\nSCHEDULE='\"*/10 * * * *\"' # Tempo que ser\u00e1 realizada novamente a coleta\n</code></pre></p> </li> <li> <p>Ap\u00f3s definir as vari\u00e1veis, use os comandos abaixo para permitir e exportar as vari\u00e1veis no seu ambiente: <pre><code>set -o allexport\nsource .env\n</code></pre></p> </li> </ol>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#23-agentyaml","title":"2.3. <code>agent.yaml</code>","text":"<p>No Orb-Agent, as configura\u00e7\u00f5es s\u00e3o definidas por meio do arquivo <code>agent.yaml</code>. \u00c9 nesse arquivo que configuramos a conex\u00e3o com o Diode Server, especificamos o local de importa\u00e7\u00e3o de vari\u00e1veis ou credenciais de acesso e definimos os tipos de descoberta que o agente dever\u00e1 executar.</p>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#231-config-manager","title":"2.3.1. Config Manager","text":"<p>A se\u00e7\u00e3o <code>config_manager</code> define como o Orb-Agent deve obter suas informa\u00e7\u00f5es de configura\u00e7\u00e3o. O gerenciador de configura\u00e7\u00e3o \u00e9 respons\u00e1vel por processar esses dados, recuperar as pol\u00edticas definidas e repass\u00e1-las ao backend apropriado. Veja outros m\u00e9todos na documenta\u00e7\u00e3o</p> <pre><code>orb:\n  config_manager:\n    active: local\n  ...\n</code></pre>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#232-secrets-manager","title":"2.3.2. Secrets Manager","text":"<p>A se\u00e7\u00e3o secrets_manager define como o Orb-Agent deve obter e injetar segredos (como senhas e tokens) nas pol\u00edticas. Esse gerenciador pode se conectar a reposit\u00f3rios externos de segredos, como o HashiCorp Vault, para buscar informa\u00e7\u00f5es sens\u00edveis de forma segura, evitando que elas sejam escritas diretamente nos arquivos de configura\u00e7\u00e3o. Veja outros m\u00e9todos na documenta\u00e7\u00e3o</p> <pre><code>orb:\n  secrets_manager:\n    active: vault\n    sources:\n      vault:\n        address: \"https://vault.example.com:8200\"\n        namespace: \"my-namespace\"\n        timeout: 60\n        auth: \"token\"\n        auth_args:\n          token: \"${VAULT_TOKEN}\"\n        schedule: \"*/5 * * * *\"\n  ...\n</code></pre> <p>Em nosso caso n\u00e3o iremos utilizar esta se\u00e7\u00e3o</p>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#233-backends","title":"2.3.3. Backends","text":"<p>Esta se\u00e7\u00e3o define como o Orb-Agent backends deve ser ativado. Nele temos as seguintes op\u00e7\u00f5es:</p> <ul> <li>Device Discovery</li> <li>Network Discovery</li> <li>Worker</li> </ul> <pre><code>orb:\n  ...\n  backends:\n    network_discovery:\n    ...\n</code></pre>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#234-common","title":"2.3.4. Common","text":"<p>A subse\u00e7\u00e3o especial <code>common</code>, dentro da se\u00e7\u00e3o backends, define configura\u00e7\u00f5es que s\u00e3o compartilhadas entre todos os backends. Atualmente, essa se\u00e7\u00e3o permite repassar as configura\u00e7\u00f5es de conex\u00e3o com o servidor Diode para todos os backends de forma centralizada.</p> <pre><code>backends:\n  ...\n  common:\n    diode:\n      target: grpc://${DIODE_HOST}/diode\n      client_id: ${DIODE_CLIENT_ID}\n      client_secret: ${DIODE_CLIENT_SECRET}\n      agent_name: agent01\n</code></pre>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#235-policies","title":"2.3.5. Policies","text":"<p>A se\u00e7\u00e3o <code>policies</code> define quais pol\u00edticas de descoberta devem ser atribu\u00eddas a cada backend. Cada pol\u00edtica descreve configura\u00e7\u00f5es espec\u00edficas para o tipo de descoberta, como agendamento, propriedades padr\u00e3o e o escopo (alvos).</p> <p>Cada backend pode executar m\u00faltiplas pol\u00edticas ao mesmo tempo, desde que cada uma tenha um nome \u00fanico dentro daquele backend. Essas pol\u00edticas s\u00e3o agrupadas em subse\u00e7\u00f5es de acordo com o backend respons\u00e1vel.</p> <pre><code>orb:\n ...\n policies:\n   device_discovery:\n     device_policy_1:\n       # Veja docs/backends/device_discovery.md\n   network_discovery:\n     network_policy_1:\n      # Veja docs/backends/network_discovery.md\n   worker:\n     worker_policy_1:\n      # Veja docs/backends/worker.md\n</code></pre> <p>Links:</p> <ul> <li> <p>Device Discovery</p> </li> <li> <p>Network Discovery</p> </li> <li> <p>Worker</p> </li> </ul>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#3-agenttemplateyaml","title":"3. <code>agent.template.yaml</code>","text":"<p>Depois de entender um pouco da estrutura do Orb-Agent, vamos para um exemplo pr\u00e1tico com um template simples que pode ser utlizado para mapear a rede docker <code>br-lab</code> e alguns dispositivos nela. Nesse arquivo vamo utilizar os backends: <code>network_discovery</code> e <code>device_discovery</code>.</p> <p>Dica</p> <p>Lembre-se: o <code>Orb-Agent</code> utiliza o arquivo <code>agent.yaml</code> como base de configura\u00e7\u00e3o. Esse arquivo deve ser gerado no seu ambiente local e, no momento de subir o container, precisa ser copiado para dentro dele.</p> <ol> <li> <p>Vamos criar o arquivo <code>agent.template.yaml</code>. <pre><code>nano agent.template.yaml\n</code></pre></p> </li> <li> <p>Agora, copie e cole o conte\u00fado dentro do arquivo criado: <pre><code>orb:\n  config_manager:\n    active: local\n  backends:\n      device_discovery:\n    network_discovery:\n    common:\n      diode:\n        target: grpc://${DIODE_HOST}/diode\n        api_key: ${DIODE_API_KEY}\n        agent_name: ${AGENT_NAME}\n  policies:\n    network_discovery:\n      policy_1:\n        scope:\n          targets:\n            - ${DOCKER_SUBNET}\n    device_discovery:\n      discovery_1:\n        config:\n          schedule: ${SCHEDULE}\n          defaults:\n            site: ${SITE_NAME}\n        scope:\n          - driver: junos\n            hostname: 172.10.10.101\n            username: admin\n            password: admin@123\n            optional_args:\n              insecure: True\n          - driver: junos\n            hostname: 172.10.10.102\n            username: admin\n            password: admin@123\n            optional_args:\n              insecure: True\n          - driver: junos\n            hostname: 172.10.10.103\n            username: admin\n            password: admin@123\n            optional_args:\n              insecure: True\n</code></pre></p> </li> <li> <p>Agora vamos gerar o arquivo <code>agent.yaml</code> de acordo com as vari\u00e1veis deifnidas no <code>.env</code>. <pre><code>envsubst &lt; agent.template.yaml &gt; agent.yaml\n</code></pre></p> </li> <li> <p>Verifique se o arquivo preencher todos os espa\u00e7os de vari\u00e1veis com os seus respectivos valores. A sua sa\u00edda deve ser algo parecido como: <pre><code>orb:\n  config_manager:\n    active: local\n  backends:\n    device_discovery:\n    network_discovery:\n    common:\n      diode:\n        target: grpc://172.10.10.120:80/diode\n        api_key: 507006398ea55f210835a66ee98b2a301d9abf6d\n        agent_name: agent1\n  policies:\n    network_discovery:\n      policy_1:\n        scope:\n          targets:\n            - 172.10.10.0/24\n    device_discovery:\n      discovery_1:\n        config:\n          schedule: \"*/10 * * * *\"\n          defaults:\n            site: RNP\n        scope:\n          - driver: junos\n            hostname: 172.10.10.101\n            username: admin\n            password: admin@123\n            optional_args:\n              insecure: True\n          - driver: junos\n            hostname: 172.10.10.102\n            username: admin\n            password: admin@123\n            optional_args:\n              insecure: True\n          - driver: junos\n            hostname: 172.10.10.103\n            username: admin\n            password: admin@123\n            optional_args:\n              insecure: True\n</code></pre></p> </li> </ol>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#4-deploy","title":"4. Deploy!","text":"<p>Com o compose do Orb-Agent configurado e o arquivo <code>agent.yaml</code> gerado, agora \u00e9 hora de coloc\u00e1-lo em execu\u00e7\u00e3o.</p> <ul> <li> <p>Execute o comando abaixo para iniciar todos os servi\u00e7os definidos no docker-compose.yml: <pre><code>docker compose up # ou para rodar em segundo plano\ndocker compose up -d \n</code></pre></p> </li> <li> <p>Esta configura\u00e7\u00e3o deve retornar os IP's da rede <code>172.10.10.0/24</code> e os dados dos tr\u00eas dispositivos definidos dentro de 10 em 10 minutos.</p> </li> </ul>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#5-conclusao","title":"5. Conclus\u00e3o","text":"<p>Com o Orb-Agent devidamente configurado e em execu\u00e7\u00e3o, voc\u00ea tem uma poderosa ferramenta de automa\u00e7\u00e3o e descoberta ativa em sua rede. Ele permite a coleta cont\u00ednua e estruturada de dados sobre dispositivos e infraestrutura, enviando essas informa\u00e7\u00f5es diretamente para o NetBox via Diode Server, de forma segura e flex\u00edvel.</p> <p>Seja utilizando pol\u00edticas personalizadas ou integrando com gerenciadores de segredos e configura\u00e7\u00e3o, o Orb-Agent facilita a escalabilidade da gest\u00e3o de ativos de rede e contribui significativamente para manter seu ambiente atualizado, consistente e documentado.</p> <p>Nos pr\u00f3ximos passos, voc\u00ea poder\u00e1 expandir as descobertas, refinar pol\u00edticas espec\u00edficas para diferentes backends e aproveitar o potencial do NetBox como fonte de verdade da sua infraestrutura.</p>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Plugin/","title":"Instalando o Diode Plugin","text":"<p>O Diode Plugin \u00e9 um componente essencial para habilitar a ingest\u00e3o automatizada de dados no NetBox. Ele fornece integra\u00e7\u00e3o direta com o ORM do NetBox e gerencia as chaves de API, permitindo que o servidor Diode envie dados estruturados de forma segura e validada. Com esse plugin, o NetBox passa a receber atualiza\u00e7\u00f5es de invent\u00e1rio em tempo real, facilitando a descoberta, documenta\u00e7\u00e3o e sincroniza\u00e7\u00e3o cont\u00ednua da infraestrutura de rede.</p>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Plugin/#repositorio-do-plugin","title":"Reposit\u00f3rio do Plugin","text":"<p>Copie o link abaixo ou clique a seguir para acessar o Reposit\u00f3rio do Github</p> <pre><code>https://github.com/netboxlabs/diode-netbox-plugin\n</code></pre>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Plugin/#1-requisitos-para-instalacao","title":"1. Requisitos para instala\u00e7\u00e3o","text":"<p>Esta documenta\u00e7\u00e3o utilizou os seguintes componentes com suas respectivas vers\u00f5es:</p> Componentes Vers\u00f5es Netbox v4.1.11 Diode Plugin v0.6.0"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Plugin/#2-instalando-e-configurando-o-plugin-no-netbox","title":"2. Instalando e Configurando o Plugin no Netbox","text":"<p>Para instalarmos o plugin no Netbox, precisamos alterar e adicionar alguns arquivos  que s\u00e3o respons\u00e1veis pela configura\u00e7\u00e3o do Netbox.</p> <p>Os arquivos s\u00e3o:</p> <ul> <li><code>plugin_requirements.txt</code>.</li> <li><code>DockerFile-Plugins</code>.</li> <li><code>docker-compose.override.yml</code>.</li> <li><code>configuration/plugins.py</code>.</li> </ul>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Plugin/#21-configurando-a-versao-do-netbox","title":"2.1. Configurando a vers\u00e3o do Netbox:","text":"<ol> <li> <p>Primeiro, vamos clonar o reposit\u00f3rio do Netbox: <pre><code>git clone -b release https://github.com/netbox-community/netbox-docker.git\n</code></pre></p> </li> <li> <p>Acesse o diret\u00f3rio clonado: <pre><code>cd netbox-docker\n</code></pre></p> </li> <li> <p>Agora, mude para a release 3.0.0 <pre><code>git checkout 3.0.0\n</code></pre></p> </li> </ol> <p>Informa\u00e7\u00e3o</p> <p>Alteramos a branch do reposit\u00f3rio para termos acesso \u00e0 vers\u00e3o 4.1.11 do Netbox.</p> <p>Dica</p> <p>Todos os comandos abaixos ser\u00e3o executados dentro diret\u00f3rio raiz do netbox <code>netbox-docker/</code>.</p>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Plugin/#22-plugin_requirementstxt","title":"2.2. plugin_requirements.txt","text":"<p>Este arquivo cont\u00e9m ama lista dos plugins do Netbox (como pacotes Python do PyPO) que devem ser instalados durante a constru\u00e7\u00e3o da imagem Docker.</p> <p>Execute o seguinte comando para escrever o pacote dentro do arquivo <code>plugin_requirements.txt</code>.</p> <pre><code>echo \"netboxlabs-diode-netbox-plugin\" &gt; plugin_requirements.txt\n</code></pre>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Plugin/#23-dockerfile-plugins","title":"2.3. DockerFile-Plugins","text":"<p>Esse \u00e9 o DockerFile usado para construir a imagem docker customizada.</p> <ol> <li> <p>Crie o arquivo e acesse com um editor:  <pre><code>nano DockerFile-Plugins\n</code></pre></p> </li> <li> <p>Copie o conte\u00fado abaixo e cole no arquivo: <pre><code>FROM netboxcommunity/netbox:v4.1\n\nCOPY ./plugin_requirements.txt /opt/netbox/\nRUN pip install -r /opt/netbox/plugin_requirements.txt\n</code></pre></p> </li> </ol>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Plugin/#24-docker-composeoverrideyml","title":"2.4. docker-compose.override.yml","text":"<p>Como o nome implica, esse arquivo contaim as configura\u00e7\u00f5es que v\u00e3o sobrescrever o <code>docker-compose.yml</code>.</p> <p>Caso voc\u00ea ainda n\u00e3o tenha configurado a rede <code>br-lab</code>. Acesse: Configurando a Rede Docker</p> <ol> <li> <p>Crie o arquivo e acesse com um editor: <pre><code>nano docker-compose.override.yml\n</code></pre></p> </li> <li> <p>Copie o conte\u00fado abaixo e cole no arquivo: <pre><code>services:\n  netbox:\n    image: netbox:latest-plugins\n    pull_policy: never\n    ports:\n      - 8000:8080\n    build:\n      context: .\n      dockerfile: Dockerfile-Plugins\n    networks:\n      br-lab:\n        ipv4_address: 172.10.10.5\n\n  netbox-worker:\n    image: netbox:latest-plugins\n    pull_policy: never\n    networks:\n      - br-lab\n\n  netbox-housekeeping:\n    image: netbox:latest-plugins\n    pull_policy: never\n    networks:\n      - br-lab\n\n  postgres:\n    networks:\n      - br-lab\n\n  redis:\n    networks:\n      - br-lab\n\n  redis-cache:\n    networks:\n      - br-lab\n\nnetworks:\n  br-lab:\n    external: true\n</code></pre></p> </li> </ol> <p>As altera\u00e7\u00f5es feitas foram: </p> <ul> <li>adicionar o Netbox na rede <code>br-lab</code>.</li> <li>altera\u00e7\u00e3o do dockerfile para o <code>Dockerfile-Plugins</code>, criado anteriormente.</li> <li>Tamb\u00e9m alterado a imagem dos servi\u00e7os para: <code>netbox:latest-plugins</code>.</li> </ul>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Plugin/#25-pluginspy","title":"2.5. plugins.py","text":"<p>Este arquivo \u00e9 respons\u00e1vel por setar as configura\u00e7\u00f5es espec\u00edficas de cada plugin.</p> <ol> <li> <p>Acesse o arquivo com o editor: <pre><code>nano configuration/plugins.py\n</code></pre></p> </li> <li> <p>Copie e cole o conte\u00fado no arquivo: <pre><code>PLUGINS = [\n    \"netbox_diode_plugin\",\n]\n\nPLUGINS_CONFIG = {\n    \"netbox_diode_plugin\": {\n        # Auto-provision users for Diode plugin\n        \"auto_provision_users\": True, \n\n        # Diode gRPC target for communication with Diode server\n        \"diode_target_override\": \"grpc://172.10.10.120:80/diode\",\n\n        # User allowed for Diode to NetBox communication\n        \"diode_to_netbox_username\": \"diode-to-netbox\",\n\n        # User allowed for NetBox to Diode communication\n        \"netbox_to_diode_username\": \"netbox-to-diode\",\n\n        # User allowed for data ingestion\n        \"diode_username\": \"diode-ingestion\",\n    },\n}\n</code></pre></p> </li> </ol> <p>Dica</p> <p>Indicamos que deixe a configura\u00e7\u00e3o <code>auto_provision_users</code> como <code>True</code> para automatizar a cria\u00e7\u00e3o de usu\u00e1rio, grupos e chaves de API que s\u00e3o respons\u00e1veis pela integra\u00e7\u00e3o com o Diode Server.</p>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Plugin/#3-build-e-deploy","title":"3. Build e Deploy!","text":"<p>Agora seu Netbox est\u00e1 configurado e pronto para o deploy, siga os comandos abaixo e construa a nova instancia do Netbox!</p> <ol> <li> <p>Construa a imagem: <pre><code>docker compose build --no-cache\n</code></pre></p> </li> <li> <p>Suba os containeres: <pre><code>docker compose up -d\n</code></pre></p> </li> </ol>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Plugin/#4-proximos-passos","title":"4. Pr\u00f3ximos Passos","text":"<p>Com o plugin do Diode instalado, seu ambiente NetBox agora est\u00e1 preparado para receber dados do servidor Diode, permitindo a ingest\u00e3o automatizada de informa\u00e7\u00f5es da rede.</p> <p>O pr\u00f3ximo passo \u00e9 configurar o Diode Server, respons\u00e1vel por processar e encaminhar esses dados para o NetBox.</p> <p>Pr\u00f3ximo: Instalando o Diode Server</p>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Server/","title":"Instalando o Diode Server","text":"<p>O Diode Server \u00e9 o componente central da arquitetura do Diode. Ele \u00e9 respons\u00e1vel por receber, processar e reconciliar os dados enviados pelos clientes (scripts ou agentes) e integr\u00e1-los ao NetBox. Utilizando protocolos modernos como gRPC e formatos eficientes como Protobuf, o Diode Server valida as informa\u00e7\u00f5es recebidas e executa a atualiza\u00e7\u00e3o automatizada do invent\u00e1rio no NetBox por meio da API exposta pelo plugin.</p> <p>Esse servidor atua como um intermedi\u00e1rio inteligente, garantindo que os dados inseridos estejam corretos, completos e sincronizados com os registros existentes.</p>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Server/#repositorio-do-plugin","title":"Reposit\u00f3rio do Plugin","text":"<p>Copie o link abaixo ou clique a seguir para acessar o Reposit\u00f3rio do Github</p> <pre><code>https://github.com/netboxlabs/diode-netbox-plugin\n</code></pre>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Server/#1-requisitos-para-instalacao","title":"1. Requisitos para instala\u00e7\u00e3o","text":"<p>Esta documenta\u00e7\u00e3o utilizou os seguintes componentes com suas respectivas vers\u00f5es:</p> Componentes Vers\u00f5es Netbox v4.1.11 Diode Server v0.6.0"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Server/#2-baixando-os-arquivos-para-instalacao","title":"2. Baixando os arquivos para instala\u00e7\u00e3o","text":"<ol> <li> <p>Primeiro, vamos criar uma nova pasta para baixar os arquivos do Diode Server. <pre><code>mkdir diode-server\ncd diode-server\n</code></pre></p> </li> <li> <p>Agora, fa\u00e7a o download dos arquivos necess\u00e1rios para instala\u00e7\u00e3o <pre><code>curl -o docker-compose.yaml https://raw.githubusercontent.com/netboxlabs/diode/refs/tags/diode-reconciler/v0.6.0/diode-server/docker/docker-compose.yaml\ncurl -o .env https://raw.githubusercontent.com/netboxlabs/diode/refs/tags/diode-reconciler/v0.6.0/diode-server/docker/sample.env\n</code></pre></p> </li> </ol>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Server/#3-configurando-o-diode-server","title":"3. Configurando o Diode Server","text":"<p>Vamos alterar o arquivo de vari\u00e1veis <code>.env</code> e criar um novo arquivo <code>docker-compose.override.yml</code> para sobrescrever as configura\u00e7\u00f5es do docker-compose.</p>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Server/#env","title":"<code>.env</code>","text":"<p>Aqui vamos precisar alterar algumas vari\u00e1veis para conectar o servidor do Diode ao nosso ambiente:</p> <pre><code># Padr\u00e3o, n\u00e3o precisa alterar\nREDIS_PASSWORD=@FmnLoA*VnebyVnZoL.!-.6z\nREDIS_HOST=diode-redis\nREDIS_PORT=6378\nRECONCILER_GRPC_HOST=diode-reconciler\nRECONCILER_GRPC_PORT=8081\nLOGGING_LEVEL=DEBUG\nMIGRATION_ENABLED=true\nMIGRATION_ENABLED=true\nDIODE_TAG=0.6.0\n\n# Caso voc\u00ea n\u00e3o use o Graphite, pode deixar a porta padr\u00e3o 8080\nDIODE_NGINX_PORT=81\n\n# URL da API do Diode Plugin no Netbox\nNETBOX_DIODE_PLUGIN_API_BASE_URL=http://172.10.10.5:8080/api/plugins/diode \n\nNETBOX_DIODE_PLUGIN_SKIP_TLS_VERIFY=true # Se estiver usando Https, pode deixar como false\n\n# Chave API gerada na instala\u00e7\u00e3o do Diode plugin -&gt; diode-to-netbox\nDIODE_TO_NETBOX_API_KEY= \n\n# Chave API gerada na instala\u00e7\u00e3o do Diode plugin -&gt; netbox-to-diode\nNETBOX_TO_DIODE_API_KEY= \n\n# Chave API gerada na instala\u00e7\u00e3o do Diode plugin -&gt; diode-ingestion\nDIODE_API_KEY= \n\n# Chave API para autorizar as chamadas RPC entre o Ingester e o Reconciler.\n# Exemplo de comando shell para gera\u00e7\u00e3o: openssl rand -base64 40 | head -c 40\nINGESTER_TO_RECONCILER_API_KEY=sXjJZe6BBzVuovrVyyH4Q3vbceqvDwh2kC3DRpML \n</code></pre> <p>Dica</p> <p>As chaves de API <code>DIODE_TO_NETBOX_API_KEY</code>, <code>NETBOX_TO_DIODE_API_KEY</code> e <code>DIODE_API_KEY</code>, podem ser visualizadas no Netbox em: Menu Lateral &gt; Diode &gt; Configura\u00e7\u00f5es</p>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Server/#docker-composeoverrideyml","title":"<code>docker-compose.override.yml</code>","text":"<p>Este arquivo \u00e9 respons\u00e1vel para alterarmos as configura\u00e7\u00f5es do <code>docker-compose</code> sobreescrevendo as configura\u00e7\u00f5es do mesmo.</p> <ol> <li>Primeiro, vamos criar o arquivo com o seguinte comando: <pre><code>nano docker-compose.override.yml\n</code></pre></li> <li>Agora copie o conte\u00fado abaixo e cole no arquivo. <pre><code>services:\n  ingress-nginx:\n    networks:\n      br-lab:\n        ipv4_address: 172.10.10.120\n  diode-ingester:\n    networks:\n      - br-lab\n  diode-reconciler:\n    networks:\n      - br-lab\n  diode-redis:\n    networks:\n      - br-lab\nnetworks:\n  br-lab:\n    external: true\n</code></pre></li> </ol>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Server/#4-deploy","title":"4. Deploy!","text":"<p>Com o servidor do Diode devidamente configurado, agora \u00e9 hora de coloc\u00e1-lo em execu\u00e7\u00e3o.</p> <ul> <li> <p>Execute o comando abaixo para iniciar todos os servi\u00e7os definidos no docker-compose.yml: <pre><code>docker compose up -d\n</code></pre></p> </li> <li> <p>Verifique se todos os servi\u00e7os est\u00e3o com o status UP <pre><code>docker compose ps\n</code></pre> <pre><code>NAME                       IMAGE                                STATUS\ndiode-diode-ingester-1     netboxlabs/diode-ingester:0.6.0      Up \ndiode-diode-reconciler-1   netboxlabs/diode-reconciler:0.6.0    Up \ndiode-diode-redis-1        redis/redis-stack-server:latest      Up \ndiode-ingress-nginx-1      nginx:latest                         Up \n</code></pre></p> </li> </ul>"},{"location":"Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Server/#5-proximos-passos","title":"5. Pr\u00f3ximos Passos","text":"<p>Com o servidor do Diode em funcionamento, estamos quase concluindo a automatiza\u00e7\u00e3o da descoberta e importa\u00e7\u00e3o de dispositivos da rede no NetBox.</p> <p>O pr\u00f3ximo passo \u00e9 configurar o Diode Client, componente respons\u00e1vel por coletar as informa\u00e7\u00f5es diretamente dos dispositivos e envi\u00e1-las ao servidor do Diode para processamento.</p> <p>Pr\u00f3ximo: Instalando o Diode Client</p>"},{"location":"Guias/Netbox/Plugins/Napalm/","title":"Napalm Plugin","text":"<p>O plugin Napalm para o NetBox permite integrar funcionalidades de coleta em tempo real diretamente dos dispositivos de rede configurados no sistema. Com ele, \u00e9 poss\u00edvel obter informa\u00e7\u00f5es atualizadas como status operacional, vizinhan\u00e7as (LLDP/CDP) e configura\u00e7\u00f5es dos equipamentos, enriquecendo a visualiza\u00e7\u00e3o e gest\u00e3o dos ativos no NetBox. Essa integra\u00e7\u00e3o torna a ferramenta mais din\u00e2mica, aproximando a documenta\u00e7\u00e3o da realidade atual da rede.</p>"},{"location":"Guias/Netbox/Plugins/Napalm/#repositorio-do-plugin","title":"Reposit\u00f3rio do Plugin","text":"<p>Copie o link abaixo ou clique a seguir para acessar o Reposit\u00f3rio do Github</p> <pre><code>https://github.com/netbox-community/netbox-napalm-plugin\n</code></pre>"},{"location":"Guias/Netbox/Plugins/Napalm/#1-requisitos-para-instalacao","title":"1. Requisitos para instala\u00e7\u00e3o","text":"<p>Esta documenta\u00e7\u00e3o utilizou os seguintes componentes com suas respectivas vers\u00f5es:</p> Componentes Vers\u00f5es Netbox v4.1.11 Napalm Plugin v0.3.1 <p>Na documenta\u00e7\u00e3o foram testadas as seguintes funcionalidades:</p> Funcionalidades Funcionando Status Page \u2705 LLDP Neighbors Page \u2705 Config Page \u2705"},{"location":"Guias/Netbox/Plugins/Napalm/#2-instalando-e-configurando-o-plugin-no-netbox","title":"2. Instalando e Configurando o Plugin no Netbox","text":"<p>Para instalarmos o plugin no Netbox, precisamos alterar e adicionar alguns arquivos  que s\u00e3o respons\u00e1veis pela configura\u00e7\u00e3o do Netbox.</p> <p>Os arquivos s\u00e3o:</p> <ul> <li><code>plugin_requirements.txt</code>.</li> <li><code>DockerFile-Plugins</code>.</li> <li><code>docker-compose.override.yml</code>.</li> <li><code>configuration/plugins.py</code>.</li> </ul>"},{"location":"Guias/Netbox/Plugins/Napalm/#21-configurando-a-versao-do-netbox","title":"2.1 Configurando a vers\u00e3o do Netbox:","text":"<ol> <li> <p>Primeiro, vamos clonar o reposit\u00f3rio do Netbox: <pre><code>git clone -b release https://github.com/netbox-community/netbox-docker.git\n</code></pre></p> </li> <li> <p>Acesse o diret\u00f3rio clonado: <pre><code>cd netbox-docker\n</code></pre></p> </li> <li> <p>Agora, mude para a release 3.0.0 <pre><code>git checkout 3.0.0\n</code></pre></p> </li> </ol> <p>Informa\u00e7\u00e3o</p> <p>Alteramos a branch do reposit\u00f3rio para termos acesso \u00e0 vers\u00e3o 4.1.11 do Netbox.</p> <p>Dica</p> <p>Todos os comandos abaixos ser\u00e3o executados dentro diret\u00f3rio raiz do netbox <code>netbox-docker/</code>.</p>"},{"location":"Guias/Netbox/Plugins/Napalm/#22-plugin_requirementstxt","title":"2.2 plugin_requirements.txt","text":"<p>Este arquivo cont\u00e9m ama lista dos plugins do Netbox (como pacotes Python do PyPO) que devem ser instalados durante a constru\u00e7\u00e3o da imagem Docker.</p> <p>Execute o seguinte comando para escrever o pacote dentro do arquivo <code>plugin_requirements.txt</code>.</p> <pre><code>echo \"netbox-napalm-plugin\" &gt; plugin_requirements.txt\n</code></pre>"},{"location":"Guias/Netbox/Plugins/Napalm/#23-dockerfile-plugins","title":"2.3 DockerFile-Plugins","text":"<p>Esse \u00e9 o DockerFile usado para construir a imagem docker customizada.</p> <ol> <li> <p>Crie o arquivo e acesse com um editor:  <pre><code>nano DockerFile-Plugins\n</code></pre></p> </li> <li> <p>Copie o conte\u00fado abaixo e cole no arquivo: <pre><code>FROM netboxcommunity/netbox:v4.1\n\nCOPY ./plugin_requirements.txt /opt/netbox/\nRUN pip install -r /opt/netbox/plugin_requirements.txt\n</code></pre></p> </li> </ol>"},{"location":"Guias/Netbox/Plugins/Napalm/#24-docker-composeoverrideyml","title":"2.4 docker-compose.override.yml","text":"<p>Como o nome implica, esse arquivo contaim as configura\u00e7\u00f5es que v\u00e3o sobrescrever o <code>docker-compose.yml</code>.</p> <p>Caso voc\u00ea ainda n\u00e3o tenha configurado a rede <code>br-lab</code>. Acesse: Configurando a Rede Docker</p> <ol> <li> <p>Crie o arquivo e acesse com um editor: <pre><code>nano docker-compose.override.yml\n</code></pre></p> </li> <li> <p>Copie o conte\u00fado abaixo e cole no arquivo: <pre><code>services:\n  netbox:\n    image: netbox:latest-plugins\n    pull_policy: never\n    ports:\n      - 8000:8080\n    build:\n      context: .\n      dockerfile: Dockerfile-Plugins\n    networks:\n      - br-lab\n\n  netbox-worker:\n    image: netbox:latest-plugins\n    pull_policy: never\n    networks:\n      - br-lab\n\n  netbox-housekeeping:\n    image: netbox:latest-plugins\n    pull_policy: never\n    networks:\n      - br-lab\n\n  postgres:\n    networks:\n      - br-lab\n\n  redis:\n    networks:\n      - br-lab\n\n  redis-cache:\n    networks:\n      - br-lab\n\nnetworks:\n  br-lab:\n    external: true\n</code></pre></p> </li> </ol> <p>As altera\u00e7\u00f5es feitas foram: </p> <ul> <li>adicionar o Netbox na rede <code>br-lab</code>.</li> <li>altera\u00e7\u00e3o do dockerfile para o <code>Dockerfile-Plugins</code>, criado anteriormente.</li> <li>Tamb\u00e9m alterado a imagem dos servi\u00e7os para: <code>netbox:latest-plugins</code>.</li> </ul>"},{"location":"Guias/Netbox/Plugins/Napalm/#25-pluginspy","title":"2.5 plugins.py","text":"<p>Este arquivo \u00e9 respons\u00e1vel por setar as configura\u00e7\u00f5es espec\u00edficas de cada plugin.</p> <ol> <li> <p>Acesse o arquivo com o editor: <pre><code>nano configuration/plugins.py\n</code></pre></p> </li> <li> <p>Copie e cole o conte\u00fado no arquivo: <pre><code>PLUGINS = [\n    \"netbox_napalm_plugin\"\n]\n\nPLUGINS_CONFIG = {\n    \"netbox_napalm_plugin\": {\n        \"NAPALM_USERNAME\": \"admin\", # Usu\u00e1rio para acesso aos equipamentos\n        \"NAPALM_PASSWORD\": \"admin@123\", # Senha para acesso aos equipamentos\n    },\n}\n</code></pre></p> </li> </ol>"},{"location":"Guias/Netbox/Plugins/Napalm/#3-build-e-deploy","title":"3. Build e Deploy!","text":"<p>Agora seu Netbox est\u00e1 configurado e pronto para o deploy, siga os comandos abaixo e construa a nova instancia do Netbox!</p> <ol> <li> <p>Construa a imagem: <pre><code>docker compose build --no-cache\n</code></pre></p> </li> <li> <p>Suba os containeres: <pre><code>docker compose up -d\n</code></pre></p> </li> </ol> <p>Ap\u00f3s os containeres subirem, execute os comandos abaixos para copiar os arquivos est\u00e1ticos solicitados pelo plugin do Napalm.</p> <ol> <li> <p>Primeiro, mude as permiss\u00f5es dos arquivos usando o comando abaixo: <pre><code>docker compose exec -it --user root netbox chmod -R a+w /opt/netbox/netbox/static\n</code></pre></p> </li> <li> <p>Ent\u00e3o, execute o comando para copiar os arquivo est\u00e1ticos: <pre><code>docker compose exec netbox python3 manage.py collectstatic --noinput\n</code></pre></p> </li> </ol>"},{"location":"Guias/Netbox/Plugins/Napalm/#4-configurando-o-napalm","title":"4. Configurando o Napalm","text":"<p>Agora, com o Netbxo j\u00e1 configurado e funcionando, vamos configurar e entender melhor como o Napalm funciona.</p> <p>Pontos importantes, para o ativar o plugin do Napalm precisamos dos seguintes requisitos:</p> <ul> <li>Napalm Platform Configs</li> <li>Dispositivo<ul> <li>Fun\u00e7\u00e3o do Dispositivo (Device role)</li> <li>Tipo do Dispositivo (Device type)</li> <li>Status: Ativo</li> <li>Plataforma (Plataform)</li> <li>IPv4 Prim\u00e1rio</li> <li>Interfaces (Para exibir a aba LLDP Neighbors) </li> </ul> </li> </ul>"},{"location":"Guias/Netbox/Plugins/Napalm/#41-napalm-platform-configs","title":"4.1 Napalm Platform Configs","text":"<p>Acesse seu Netbox e siga as instru\u00e7\u00f5es abaixo.</p> <ol> <li>No menu lateral, v\u00e1 em Plugin \u2192 Napalm.</li> <li>Clique no bot\u00e3o Adicionar.</li> <li><code>Plataform</code>: Selecione uma plataform (ex: junos)</li> <li><code>NAPALM driver</code>: Aqui \u00e9 o nome do driver usado pelo Napalm para coletar os dados dos dispositivos. Para ver os drivers dispon\u00edveis, acesse Supported Devices. Neste caso vamos usar o junos.</li> <li><code>NAPALM arguments</code>(Opcional): Argumentos passados quando inicializa o NAPALM driver. Argumentos em: Optional Arguments. Em nosso caso, n\u00e3o iremos preencher.</li> <li>Clique em Criar.</li> </ol> <p>Pronto! agora temos o Plataform Config criado para acesso aos nossos dispositivos! </p>"},{"location":"Guias/Netbox/Plugins/Napalm/#42-configurando-um-dispositivo","title":"4.2 Configurando um Dispositivo","text":"<p>Para testarmos o plugin do Napalm, precisamos de dispositivos para consulta, para isso, vamos usar o laborat\u00f3rio de Descoberta Mais informa\u00e7\u00f5es. Logo, adicionar pelo menos um dispositivo ao Netbox.</p>"},{"location":"Guias/Netbox/Plugins/Napalm/#421-adicionando-os-roteadores","title":"4.2.1 Adicionando os Roteadores","text":"<ol> <li> <p>Clone o resposit\u00f3rio do laborat\u00f3rio: <pre><code>git clone https://git.rnp.br/redes-abertas/labs/-/tree/main/discovery-lab\n</code></pre></p> </li> <li> <p>Entre no reposit\u00f3rio: <pre><code>cd discovery-lab/\n</code></pre></p> </li> <li> <p>Inicie a topologia com o comando: <pre><code>sudo clab deploy -t clab/discovery-lab.clab.yaml\n</code></pre></p> </li> </ol> <p>Debug</p> <p>Os dispositivos podem levar cerca de 10 minutos para estarem totalmente operacionais. Caso ocorra algum erro, verifique a sa\u00edda do comando para poss\u00edveis mensagens de erro. Use <code>docker logs &lt;container_name&gt;</code> para depurar.</p>"},{"location":"Guias/Netbox/Plugins/Napalm/#422-adicionando-o-roteador-ao-netbox","title":"4.2.2 Adicionando o roteador ao Netbox.","text":"<p>Criar site</p> <ol> <li>V\u00e1 em Sites \u2192 clique em Add.</li> <li>Preencha os campos:</li> <li>Name: <code>RNP</code></li> <li>Clique em Create.</li> </ol> <p>Criar o Fabricante</p> <ol> <li>V\u00e1 em Devices \u2192 Manufacturers \u2192 Add.</li> <li>Preencha:</li> <li>Name: <code>Juniper</code></li> <li>Slug: <code>juniper</code> (ou gerado automaticamente)</li> <li>Clique em Create.</li> </ol> <p>Criar o Tipo de Dispositivo</p> <ol> <li>V\u00e1 em Devices \u2192 Device Types \u2192 Add.</li> <li>Preencha:</li> <li>Manufacturer: <code>Juniper</code></li> <li>Model: <code>VMX</code></li> <li>Clique em Create.</li> </ol> <p>Criar o Dispositivo</p> <ol> <li>V\u00e1 em Devices \u2192 clique em Add.</li> <li>Preencha:</li> <li>Name: <code>JPA</code></li> <li>Device Role: <code>Roteador</code> (crie se necess\u00e1rio)</li> <li>Device Type: <code>VMX</code></li> <li>Site: <code>RNP</code></li> <li>Status: <code>Active</code></li> <li>Clique em Create.</li> </ol> <p>Criar Interface</p> <ol> <li>Acesse o dispositivo <code>JPA</code>.</li> <li>V\u00e1 na aba Interfaces \u2192 clique em Add Interface.</li> <li>Preencha:</li> <li>Name: <code>ge-0/0/2</code></li> <li>Type: <code>Virtual</code></li> <li>Clique em Create.</li> </ol> <p>Criar Endere\u00e7o IP</p> <ol> <li>V\u00e1 em IPAM \u2192 IP Addresses \u2192 Add.</li> <li>Preencha:</li> <li>Address: <code>172.10.10.101/32</code></li> <li>Status: <code>Active</code></li> <li>Interface Assignment:<ul> <li>Device: <code>JPA</code></li> <li>Interface: <code>ge-0/0/2</code></li> </ul> </li> <li>Clique em Create.</li> </ol> <p>Adicionando IPv4 Prim\u00e1rio no Dispositivo</p> <ol> <li>V\u00e1 em Dispositivos</li> <li>Clique no JPA e depois em Editar</li> <li>Em Gest\u00e3o \u2192 IPv4 prim\u00e1rio: Selecione <code>172.10.10.101/32 (ge-0/0/2)</code></li> </ol>"},{"location":"Guias/Netbox/Plugins/Napalm/#5-visualizando-o-plugin","title":"5. Visualizando o Plugin","text":"<p>Ap\u00f3s o cadastro, na aba de dispositivos, acesse JPA.</p> <p>Agora voc\u00ea deve estar vendo as abas adicionais do plugin Napalm.</p> <ul> <li>Status</li> <li>LLDP Neighbors</li> <li>Config</li> </ul>"},{"location":"Guias/Netbox/Plugins/Napalm/#51-status","title":"5.1 Status","text":"<p>A aba Status, habilitada por meio da integra\u00e7\u00e3o do NetBox com o plugin NAPALM, exibe informa\u00e7\u00f5es operacionais em tempo real do dispositivo de rede. Essa funcionalidade permite ao administrador monitorar rapidamente o estado atual do equipamento sem sair da interface do NetBox.</p> <p> Principais Informa\u00e7\u00f5es Apresentadas:</p> <ul> <li> <p>Device Facts: Dados b\u00e1sicos e est\u00e1ticos do dispositivo, como:</p> <ul> <li> <p><code>Hostname</code>: Identifica\u00e7\u00e3o do dispositivo na rede (ex: JPA)</p> </li> <li> <p><code>Vendor / Model</code>: Fabricante e modelo do equipamento (ex: Juniper VMX)</p> </li> <li> <p><code>Serial Number</code>: N\u00famero de s\u00e9rie do hardware</p> </li> <li> <p><code>OS Version</code>: Vers\u00e3o do sistema operacional (ex: 22.2R1.9)</p> </li> <li> <p><code>Uptime</code>: Tempo desde o \u00faltimo boot, com data e hora registradas</p> </li> </ul> </li> <li> <p>Environment: M\u00e9tricas ambientais e de desempenho que auxiliam na manuten\u00e7\u00e3o preventiva e opera\u00e7\u00e3o:</p> <ul> <li> <p><code>CPU Usage</code>: Utiliza\u00e7\u00e3o atual da(s) CPU(s), apresentada por n\u00facleo</p> </li> <li> <p><code>Memory</code>: Quantidade de mem\u00f3ria dispon\u00edvel e utilizada</p> </li> <li> <p><code>Temperature, Fans, Power (PSUs)</code>: Status dos sensores e fontes de energia (caso o equipamento forne\u00e7a esses dados)</p> </li> </ul> </li> </ul> <p></p> <p> Finalidade: </p> <p>Essa aba \u00e9 especialmente \u00fatil para diagn\u00f3stico r\u00e1pido, auditorias, e monitoramento da sa\u00fade dos dispositivos, eliminando a necessidade de login manual via SSH ou console. As informa\u00e7\u00f5es s\u00e3o atualizadas dinamicamente por meio da API do NAPALM, desde que corretamente configurada no NetBox.</p>"},{"location":"Guias/Netbox/Plugins/Napalm/#52-lldp-neighbors","title":"5.2 LLDP Neighbors","text":"<p>Esta funcionalidade exibe os vizinhos de camada 2 detectados por meio do protocolo LLDP (Link Layer Discovery Protocol). Essa funcionalidade permite identificar automaticamente os dispositivos conectados diretamente ao equipamento monitorado.</p> <p> Comportamento Importante:</p> <ul> <li> <p>A visualiza\u00e7\u00e3o de vizinhos est\u00e1 limitada \u00e0s interfaces previamente cadastradas no NetBox.</p> </li> <li> <p>Caso uma interface exista no dispositivo real, mas n\u00e3o tenha sido criada no NetBox, os vizinhos descobertos por ela n\u00e3o ser\u00e3o exibidos.</p> </li> </ul> <p></p> <p> Finalidade:</p> <p>Essa aba \u00e9 \u00fatil para validar conex\u00f5es f\u00edsicas entre dispositivos, verificar a topologia de rede em tempo real e detectar erros de cabeamento ou configura\u00e7\u00e3o de portas, de forma automatizada e integrada \u00e0 interface do NetBox.</p>"},{"location":"Guias/Netbox/Plugins/Napalm/#53-config","title":"5.3 Config","text":"<p>A aba Config, permite a visualiza\u00e7\u00e3o direta das configura\u00e7\u00f5es do dispositivo de rede, extra\u00eddas remotamente por meio da API. Ela apresenta diferentes vers\u00f5es do arquivo de configura\u00e7\u00e3o, \u00fateis para compara\u00e7\u00e3o, auditoria e troubleshooting.</p> <p> Tipos de Configura\u00e7\u00f5es Exibidas:</p> <ul> <li> <p><code>Startup Config</code>: A configura\u00e7\u00e3o que ser\u00e1 carregada quando o dispositivo for reiniciado. Representa o estado persistente.</p> </li> <li> <p><code>Running Config</code>: A configura\u00e7\u00e3o atualmente em execu\u00e7\u00e3o no dispositivo. Pode incluir mudan\u00e7as n\u00e3o salvas.</p> </li> <li> <p><code>Candidate Config</code> (quando suportada pelo sistema operacional): Configura\u00e7\u00e3o em edi\u00e7\u00e3o que ainda n\u00e3o foi aplicada. Presente em equipamentos que trabalham com staging de configura\u00e7\u00f5es (ex: Juniper).</p> </li> </ul> <p></p> <p> Finalidade:</p> <p>Essa aba \u00e9 essencial para o gerenciamento e rastreamento de mudan\u00e7as na configura\u00e7\u00e3o dos dispositivos, al\u00e9m de fornecer uma forma pr\u00e1tica e segura de validar se as configura\u00e7\u00f5es persistentes est\u00e3o de acordo com as em execu\u00e7\u00e3o \u2014 tudo dentro da interface do NetBox.</p>"},{"location":"Guias/Netbox/Render_Templates/","title":"Render Templates","text":"<p>Os Render Templates no NetBox s\u00e3o uma poderosa ferramenta que permite gerar configura\u00e7\u00f5es de rede de maneira din\u00e2mica e personalizada para cada dispositivo.  Esses templates utilizam a linguagem de marca\u00e7\u00e3o Jinja2 para processar vari\u00e1veis e renderizar arquivos de configura\u00e7\u00e3o com base nas informa\u00e7\u00f5es armazenadas no banco de dados do NetBox.</p>"},{"location":"Guias/Netbox/Render_Templates/#1-adicionando-templates","title":"1. Adicionando Templates","text":""},{"location":"Guias/Netbox/Render_Templates/#11-templates-remotos","title":"1.1 Templates Remotos","text":"<p>Os templates remotos ficam dispon\u00edveis online em um reposit\u00f3rio Git. Para adicionar o nosso reposit\u00f3rio de templates, siga os passos abaixo:</p>"},{"location":"Guias/Netbox/Render_Templates/#adicionando-o-repositorio","title":"Adicionando o Reposit\u00f3rio","text":"<ol> <li>Acesse o NetBox e v\u00e1 em Personaliza\u00e7\u00e3o &gt; Fonte de Dados &gt; Adicionar.</li> <li>Defina um nome de sua escolha e selecione o tipo como Git.</li> <li>Na URL, adicione o seguinte link para usar o template:</li> </ol> <pre><code>https://git.rnp.br/redes-abertas/config-templates-data-source.git\n</code></pre> <p>Aten\u00e7\u00e3o</p> <p>Caso o reposit\u00f3rio seja privado, adicione o seu m\u00e9todo de autentica\u00e7\u00e3o nos par\u00e2metros de back-end.</p> <ol> <li>Clique em Criar.</li> <li>Clique no data source que foi criado e, em seguida, clique em Sync para realizar a an\u00e1lise do reposit\u00f3rio.</li> </ol> <p>Se a sincroniza\u00e7\u00e3o for bem-sucedida, aparecer\u00e1 uma mensagem de \"Conclu\u00eddo\" na parte de Status.</p> <ol> <li>Agora, voc\u00ea poder\u00e1 visualizar os templates na aba Provisionamento &gt; Modelos de Configura\u00e7\u00e3o.</li> </ol>"},{"location":"Guias/Netbox/Render_Templates/#12-templates-locais","title":"1.2 Templates Locais","text":"<p>Para adicionar templates locais, siga estes passos:</p> <ol> <li>Acesse o NetBox e v\u00e1 para Provisionamento &gt; Modelos de Configura\u00e7\u00e3o &gt; Adicionar.</li> <li>Adicione um nome, uma descri\u00e7\u00e3o e, em Dados, insira o c\u00f3digo Jinja2 do template que deseja adicionar. Preencha as demais atribui\u00e7\u00f5es conforme necess\u00e1rio.</li> </ol> <p>Aqui est\u00e1 um exemplo de template Jinja2 gen\u00e9rico:</p> <pre><code>Device Information:\n------------------------------------------\nDevice Name: {{ device.name }}\nDevice Type: {{ device.device_type.name if device.device_type else 'N/A' }}\nSite: {{ device.site.name if device.site else 'N/A' }}\nStatus: {{ device.status if device.status else 'N/A' }}\nSerial Number: {{ device.serial if device.serial else 'N/A' }}\n{% if device.primary_ip %}\nPrimary IP: {{ device.primary_ip.address if device.primary_ip.address else 'N/A' }}\n{% endif %}\nPlatform: {{ device.platform if device.platform else 'N/A' }}\nRack: {{ device.rack.name if device.rack else 'N/A' }}\nAsset Tag: {{ device.asset_tag if device.asset_tag else 'N/A' }}\n{% if device.comments %}\nComments: {{ device.comments }}\n{% endif %}\n\nInterfaces Information:\n----------------------------------------------\n{% for interface in device.interfaces.all() %}\nInterface Name: {{ interface.name if interface.name else 'N/A' }}\nType: {{ interface.type if interface.type else 'N/A' }}\nMAC Address: {{ interface.mac_address if interface.mac_address else 'N/A' }}\n{% if interface.ip_addresses %}\nIP Addresses: {% for ip in interface.ip_addresses.all() %}\n              {{ ip.address }}\n              {% endfor %}\n{% endif %}\nOperational Status: {{ interface.enabled if interface.enabled else 'N/A' }}\nAdmin Status: {{ interface.enabled if interface.enabled is defined else 'N/A' }}\n{% if interface.untagged_vlan %}\nVLANs: {% for vlan in interface.untagged_vlan.all() %}\n       {{ vlan.vid }}\n       {% endfor %}\n{% endif %}\n----------------------------------------------\n{% endfor %}\n</code></pre> <ol> <li>Ap\u00f3s inserir todas as informa\u00e7\u00f5es, clique em Criar.</li> </ol>"},{"location":"Guias/Netbox/Render_Templates/#2-associando-templates-aos-dispositivos","title":"2. Associando Templates aos Dispositivos","text":"<p>Para associar um template a um dispositivo espec\u00edfico:</p> <ol> <li>Selecione o dispositivo em Dispositivos &gt; Dispositivos.</li> <li>Clique em Editar ou no \u00edcone de l\u00e1pis no canto direito.</li> <li>Procure pela se\u00e7\u00e3o Gest\u00e3o &gt; Modelo de Configura\u00e7\u00e3o.</li> </ol> <p>Nessa aba, voc\u00ea ver\u00e1 todas as configura\u00e7\u00f5es dispon\u00edveis.</p> <p>Observa\u00e7\u00e3o</p> <p>Atente-se ao sistema do dispositivo, pois os templates de configura\u00e7\u00e3o s\u00e3o criados de forma diferente para sistemas distintos.</p> <ol> <li>Ap\u00f3s selecionar o template desejado, clique em Salvar.</li> <li>Para visualizar o template, acesse o dispositivo e clique em Render Config. Isso renderizar\u00e1 a configura\u00e7\u00e3o espec\u00edfica para o dispositivo de forma din\u00e2mica.</li> </ol>"},{"location":"Guias/Netbox/Render_Templates/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<p>Caso queira criar outros templates e aprender mais sobre o funcionamento da base de templates, clique aqui.</p>"},{"location":"Guias/Netbox/Render_Templates/Criando%20um%20Template/","title":"Cria\u00e7\u00e3o de Templates de configura\u00e7\u00f5es","text":""},{"location":"Guias/Netbox/Render_Templates/Criando%20um%20Template/#como-funciona-o-render-template-no-netbox","title":"Como Funciona o Render Template no NetBox?","text":"<p>O \"Render Template\" no NetBox \u00e9 uma poderosa funcionalidade que permite aos administradores de rede automatizar a gera\u00e7\u00e3o de configura\u00e7\u00f5es de dispositivos de rede com base em modelos de configura\u00e7\u00e3o predefinidos. Ele simplifica o processo de implementa\u00e7\u00e3o e manuten\u00e7\u00e3o de dispositivos, tornando-o mais eficiente e menos propenso a erros humanos. Aqui est\u00e1 como ele funciona:</p> <ol> <li>Cria\u00e7\u00e3o de Modelos de Configura\u00e7\u00e3o: Primeiro, os administradores criam modelos de configura\u00e7\u00e3o usando a linguagem de template Jinja2. Esses modelos servem como estruturas para as configura\u00e7\u00f5es desejadas dos dispositivos.</li> <li>Incorpora\u00e7\u00e3o de Vari\u00e1veis: Os modelos de configura\u00e7\u00e3o podem incorporar vari\u00e1veis J2, que s\u00e3o espa\u00e7os reservados para informa\u00e7\u00f5es din\u00e2micas. Essas vari\u00e1veis s\u00e3o substitu\u00eddas por dados espec\u00edficos de dispositivos quando o template \u00e9 renderizado.</li> <li>Associa\u00e7\u00e3o a Dispositivos: Cada modelo de configura\u00e7\u00e3o \u00e9 associado a um tipo de dispositivo espec\u00edfico. Isso permite que o NetBox saiba quais modelos de configura\u00e7\u00e3o usar para cada dispositivo com base em seu tipo.</li> <li>Renderiza\u00e7\u00e3o Automatizada: Quando um administrador cria ou atualiza um dispositivo no NetBox, o \"Render Template\" entra em a\u00e7\u00e3o. O NetBox identifica o tipo de dispositivo e o modelo de configura\u00e7\u00e3o correspondente.</li> <li>Preenchimento com Dados Reais: As vari\u00e1veis J2 no modelo de configura\u00e7\u00e3o s\u00e3o preenchidas com dados reais do dispositivo, como seu nome, localiza\u00e7\u00e3o, endere\u00e7o IP, entre outros.</li> <li>Gera\u00e7\u00e3o de Configura\u00e7\u00e3o: O NetBox gera automaticamente uma configura\u00e7\u00e3o completa para o dispositivo, aplicando os valores das vari\u00e1veis J2 ao modelo de configura\u00e7\u00e3o. Isso cria uma configura\u00e7\u00e3o personalizada e pronta para uso.</li> <li>Aplica\u00e7\u00e3o da Configura\u00e7\u00e3o: A configura\u00e7\u00e3o gerada pode ser implantada no dispositivo por meio de m\u00e9todos tradicionais, como transfer\u00eancia de arquivos SSH/SCP, ou integrada a ferramentas de gerenciamento de configura\u00e7\u00e3o para automa\u00e7\u00e3o adicional.</li> </ol> <p>Em resumo, o \"Render Template\" no NetBox simplifica o processo de configura\u00e7\u00e3o de dispositivos de rede, permitindo a cria\u00e7\u00e3o de modelos flex\u00edveis e automatizando a gera\u00e7\u00e3o de configura\u00e7\u00f5es com base nas informa\u00e7\u00f5es dos dispositivos. Isso economiza tempo, reduz erros e facilita a manuten\u00e7\u00e3o da infraestrutura de rede.</p> <ul> <li>{{ }} - Vari\u00e1veis J2: As express\u00f5es entre chaves duplas, como <code>{{ device.name }}</code>, s\u00e3o vari\u00e1veis J2. Elas s\u00e3o substitu\u00eddas pelos valores reais dos dispositivos durante a renderiza\u00e7\u00e3o do template. Por exemplo, <code>{{ device.name }}</code> ser\u00e1 substitu\u00eddo pelo nome do dispositivo espec\u00edfico.</li> <li>Blocos de Controle: Os blocos de controle, como <code>{% if condition %} ... {% endif %}</code>, permitem a l\u00f3gica condicional e os loops. Eles s\u00e3o usados para verificar se uma condi\u00e7\u00e3o \u00e9 verdadeira (<code>if</code>) ou para iterar sobre uma lista de itens (<code>for</code>). Isso \u00e9 \u00fatil para lidar com casos em que as informa\u00e7\u00f5es podem ou n\u00e3o estar dispon\u00edveis.</li> <li>Python por Baixo: Os templates J2 usam a linguagem de template Jinja2, que \u00e9 baseada em Python. Portanto, voc\u00ea pode usar a sintaxe do Python para criar l\u00f3gica personalizada dentro de seus templates. Isso inclui o uso de condicionais, loops e fun\u00e7\u00f5es personalizadas.</li> </ul> <p>Agora que explicamos o funcionamento, aqui est\u00e3o as vari\u00e1veis dispon\u00edveis dos devices cadastrados no netbox</p>"},{"location":"Guias/Netbox/Render_Templates/Criando%20um%20Template/#variaveis-e-uso","title":"Vari\u00e1veis e Uso","text":"Nome Comando Descri\u00e7\u00e3o Exemplo de Retorno Device Name {{ http://device.name/ }} Nome do dispositivo Nome do dispositivo Device Type {{ device.device_type.name if device.device_type else 'N/A' }} Tipo do dispositivo Tipo do dispositivo (ou 'N/A' se n\u00e3o houver tipo) Site {{ http://device.site.name/ if device.site else 'N/A' }} Nome do site Nome do site (ou 'N/A' se n\u00e3o houver site) Status {{ device.status if device.status else 'N/A' }} Status do dispositivo Status do dispositivo (ou 'N/A' se n\u00e3o houver status) Serial Number {{ device.serial if device.serial else 'N/A' }} N\u00famero de s\u00e9rie do dispositivo N\u00famero de s\u00e9rie do dispositivo (ou 'N/A' se n\u00e3o houver n\u00famero de s\u00e9rie) Primary IP {{ device.primary_ip.address if device.primary_ip.address else 'N/A' }} Endere\u00e7o IP prim\u00e1rio do dispositivo Endere\u00e7o IP prim\u00e1rio do dispositivo (ou 'N/A' se n\u00e3o houver IP prim\u00e1rio) Platform {{ device.platform if device.platform else 'N/A' }} Plataforma do dispositivo Plataforma do dispositivo (ou 'N/A' se n\u00e3o houver plataforma) Rack {{ http://device.rack.name/ if device.rack else 'N/A' }} Nome do rack Nome do rack (ou 'N/A' se n\u00e3o houver rack) Asset Tag {{ device.asset_tag if device.asset_tag else 'N/A' }} Tag de ativo do dispositivo Tag de ativo do dispositivo (ou 'N/A' se n\u00e3o houver tag de ativo) Comments {{ device.comments }} Coment\u00e1rios do dispositivo Coment\u00e1rios do dispositivo (ou em branco) Interface Name {{ http://interface.name/ if http://interface.name/ else 'N/A' }} Nome da interface Nome da interface (ou 'N/A' se n\u00e3o houver nome) Type {{ interface.type if interface.type else 'N/A' }} Tipo da interface Tipo da interface (ou 'N/A' se n\u00e3o houver tipo) MAC Address {{ interface.mac_address if interface.mac_address else 'N/A' }} Endere\u00e7o MAC da interface Endere\u00e7o MAC da interface (ou 'N/A' se n\u00e3o houver endere\u00e7o MAC) IP Addresses {{ ip.address }} Endere\u00e7os IP da interface (v\u00e1rios podem estar presentes) Lista de endere\u00e7os IP da interface Operational Status {{ interface.enabled if interface.enabled else 'N/A' }} Status operacional da interface Status operacional da interface (ou 'N/A' se n\u00e3o houver status operacional) Admin Status {{ interface.enabled if interface.enabled is defined else 'N/A' }} Status administrativo da interface Status administrativo da interface (ou 'N/A' se n\u00e3o houver status administrativo) VLANs {% for vlan in interface.untagged_vlan.all() %}{{ vlan.vid }} VLANs da interface Lista de VLANs da interface (se houver)"},{"location":"Guias/Netbox/Render_Templates/Criando%20um%20Template/#exmplo","title":"Exmplo","text":"<p>Este template de renderiza\u00e7\u00e3o \u00e9 projetado para gerar configura\u00e7\u00f5es de interfaces no formato adequado para um roteador Juniper. Ele percorre todas as interfaces do dispositivo no NetBox que t\u00eam endere\u00e7os IP associados e gera configura\u00e7\u00f5es para essas interfaces.</p> <p>Aqui est\u00e1 como o template funciona:</p> <pre><code>{%- for interface in device.interfaces.all() -%}\n    {%- if interface.ip_addresses.all() %}\n    {{ interface.name.split('.')[0].split(':')[0] }} {\n        unit 0 {\n            family inet {\n                {%- for ip in interface.ip_addresses.all() %}\n                address {{ ip }};\n                {%- endfor %}\n            }\n        }\n    }\n    {%- endif %}\n{%- endfor %}\n</code></pre> <p>A sa\u00edda gerada ap\u00f3s a renderiza\u00e7\u00e3o deste template ser\u00e1 algo semelhante ao seguinte:</p> <pre><code>ge-0/0/0 {\n    unit 0 {\n        family inet {\n            address 192.168.1.1/24;\n            address 10.0.0.1/30;\n        }\n    }\n}\nge-0/0/1 {\n    unit 0 {\n        family inet {\n            address 172.16.0.1/24;\n        }\n    }\n}\n</code></pre> <p>Neste exemplo:</p> <ul> <li>O loop <code>{%- for interface in device.interfaces.all() -%}</code> percorre todas as interfaces do dispositivo no NetBox.</li> <li>A condi\u00e7\u00e3o <code>{%- if interface.ip_addresses.all() %}</code> verifica se a interface tem endere\u00e7os IP associados a ela.</li> <li><code>{{ interface.name.split('.')[0].split(':')[0] }}</code> \u00e9 usado para extrair o nome da interface no formato desejado. Por exemplo, se o nome da interface for \"ge-0/0/0.0:1\", ele ser\u00e1 convertido em \"ge-0/0/0\".</li> <li>O template ent\u00e3o gera as configura\u00e7\u00f5es para cada interface, incluindo o endere\u00e7o IP (obtido do loop <code>{%- for ip in interface.ip_addresses.all() %}</code>).</li> </ul> <p>A sa\u00edda resultante \u00e9 uma s\u00e9rie de configura\u00e7\u00f5es de interfaces formatadas corretamente para um dispositivo Juniper. Cada interface tem sua pr\u00f3pria configura\u00e7\u00e3o, incluindo seu nome e endere\u00e7o IP, se aplic\u00e1vel.</p>"},{"location":"Guias/Netreplica/","title":"NetReplica - Guia de Configura\u00e7\u00e3o e Execu\u00e7\u00e3o em Container","text":"<p>Este guia descreve os passos necess\u00e1rios para configurar e executar o NetReplica em um cont\u00eainer Docker, utilizando o Docker Compose. O NetReplica \u00e9 uma ferramenta dedicada \u00e0 automa\u00e7\u00e3o de laborat\u00f3rios de rede atrav\u00e9s de software.</p>"},{"location":"Guias/Netreplica/#pre-requisitos","title":"Pr\u00e9-requisitos","text":"<ul> <li>Docker instalado em sua m\u00e1quina: Instru\u00e7\u00f5es de Instala\u00e7\u00e3o</li> <li>Docker Compose instalado em sua m\u00e1quina: Instru\u00e7\u00f5es de Instala\u00e7\u00e3o</li> </ul>"},{"location":"Guias/Netreplica/#passo-1-preparacao-do-ambiente","title":"Passo 1: Prepara\u00e7\u00e3o do Ambiente","text":"<ol> <li>Abra um terminal e clone o reposit\u00f3rio do NetReplica utilizando o seguinte comando:</li> </ol> <pre><code>git clone https://git.rnp.br/redes-abertas/netreplica-docker.git\n</code></pre> <ol> <li>Navegue para o diret\u00f3rio do NetReplica clonado:</li> </ol> <pre><code>cd netreplica-docker\n</code></pre>"},{"location":"Guias/Netreplica/#passo-2-inicializacao-do-conteiner","title":"Passo 2: Inicializa\u00e7\u00e3o do Cont\u00eainer","text":"<ol> <li>Para construir a imagem Docker e iniciar o cont\u00eainer NetReplica, execute:</li> </ol> <pre><code>docker compose up -d\n</code></pre> <p>Este comando criar\u00e1 e iniciar\u00e1 o cont\u00eainer em segundo plano.</p>"},{"location":"Guias/Netreplica/#passo-3-utilizacao-do-netreplica","title":"Passo 3: Utiliza\u00e7\u00e3o do NetReplica","text":"<p>Ap\u00f3s a inicializa\u00e7\u00e3o do cont\u00eainer, voc\u00ea pode interagir com o NetReplica utilizando os comandos abaixo.</p>"},{"location":"Guias/Netreplica/#execucao-do-netreplica","title":"Execu\u00e7\u00e3o do NetReplica","text":"<ol> <li> <p>Coloque qualquer arquivo de configura\u00e7\u00e3o necess\u00e1rio (arquivos <code>.conf</code>) na pasta <code>conf</code> que est\u00e1 dentro do diret\u00f3rio <code>nrx</code> onde o reposit\u00f3rio foi clonado.</p> </li> <li> <p>Para executar o NetReplica com o arquivo <code>.conf</code>, utilize o seguinte comando:</p> </li> </ol> <pre><code>docker exec -it nrx nrx -c conf/&lt;arquivo.conf&gt;\n</code></pre> <ul> <li>Substitua <code>&lt;arquivo.conf&gt;</code> pelo nome do arquivo de configura\u00e7\u00e3o que voc\u00ea deseja utilizar.</li> <li>O diret\u00f3rio de sa\u00edda para os resultados da execu\u00e7\u00e3o j\u00e1 est\u00e1 especificado dentro do arquivo <code>.conf</code>, portanto, n\u00e3o \u00e9 necess\u00e1rio especific\u00e1-lo no comando.</li> </ul>"},{"location":"Guias/Netreplica/#alias-para-agilidade","title":"Alias para Agilidade","text":"<p>Para otimizar ainda mais o uso do NetReplica, voc\u00ea pode criar um alias no seu shell para simplificar o comando de execu\u00e7\u00e3o:</p> <ol> <li>Abra um terminal e edite o arquivo de perfil do shell correspondente ao seu sistema (por exemplo, <code>~/.bashrc</code> para o Bash ou <code>~/.zshrc</code> para o Zsh).</li> <li>Adicione a seguinte linha ao final do arquivo:</li> </ol> <pre><code>alias nrx='docker exec -it nrx nrx'\n</code></pre> <ol> <li>Salve o arquivo e feche-o.</li> <li>Para ativar o novo alias sem reiniciar o terminal, execute o comando:</li> </ol> <pre><code>source ~/.bashrc   # ou source ~/.zshrc, dependendo do seu shell\n</code></pre> <p>Agora, voc\u00ea pode utilizar o comando simplificado <code>nrx</code> para executar o NetReplica de forma mais r\u00e1pida. Por exemplo:</p> <pre><code>nrx -c conf/&lt;arquivo.conf&gt;\n</code></pre> <p>Agora para testar se o NetReplica est\u00e1 funcionando, execute o seguinte comando:</p> <pre><code>nrx -c conf/teste.conf\n</code></pre> <p>este comando ira fazer uma consulta no netbox de demonstra\u00e7\u00e3o gerando um resultado igual o demonstrado abaixo:</p> <pre><code>--&gt; nrx -c conf/teste.conf\nReading platform map from: templates/platform_map.yaml\nConnecting to NetBox at: https://demo.netbox.dev\nFetching devices from sites: ['DM-Akron']\nCreated clab topology: conf/lab/lab.clab.yaml\nTo deploy this topology, run: sudo -E clab dep -t conf/lab/lab.clab.yaml\n</code></pre>"},{"location":"Guias/Netreplica/#monitorando-a-execucao","title":"Monitorando a Execu\u00e7\u00e3o","text":"<ul> <li>Durante a execu\u00e7\u00e3o, o NetReplica usar\u00e1 as configura\u00e7\u00f5es do arquivo <code>.conf</code> para acessar o NetBox, iniciar a replica\u00e7\u00e3o e an\u00e1lise da rede. Monitore a sa\u00edda do terminal para acompanhar o progresso e visualizar qualquer mensagem relevante.</li> <li>Ap\u00f3s a conclus\u00e3o da execu\u00e7\u00e3o, os resultados da replica\u00e7\u00e3o e an\u00e1lise estar\u00e3o dispon\u00edveis no diret\u00f3rio de sa\u00edda especificado dentro do arquivo <code>.conf</code>.</li> </ul>"},{"location":"Guias/Netreplica/#encerrando-o-conteiner","title":"Encerrando o Cont\u00eainer","text":"<p>Para encerrar o cont\u00eainer NetReplica e liberar os recursos, execute:</p> <pre><code>docker compose down\n</code></pre>"},{"location":"Guias/Netreplica/#proximos-passos-configuracao-do-arquivo-conf","title":"Pr\u00f3ximos Passos: Configura\u00e7\u00e3o do Arquivo <code>.conf</code>","text":"<p>Agora que voc\u00ea j\u00e1 sabe como configurar e executar o NetReplica,  o pr\u00f3ximo passo \u00e9 entender como configurar corretamente o arquivo <code>.conf</code> para atender \u00e0s necessidades do seu ambiente de rede. </p> <p>proximos passos Configura\u00e7\u00e3o do Arquivo <code>.conf</code></p>"},{"location":"Guias/Netreplica/NetReplica%20Criando%20Templates/","title":"NetReplica Criando Templates","text":""},{"location":"Guias/Netreplica/NetReplica%20Criando%20Templates/#estrutura-dos-templates-clab","title":"Estrutura dos Templates CLAB","text":"<p>Os templates CLAB seguem uma estrutura espec\u00edfica, que permite que o NetReplica interprete e aplique as configura\u00e7\u00f5es corretamente. Aqui est\u00e1 um exemplo de um template CLAB para um dispositivo ceos:</p> <pre><code>  {{ name }}:\n    kind: ceos\n    image: ceos:latest\n    {% if configuration_file is defined %}\n    startup-config: {{ configuration_file }}\n    {% endif %}\n    {% if interface_map is defined %}\n    binds:\n        - {{ interface_map }}:/mnt/flash/EosIntfMapping.json:ro\n    {% endif %}\n    {% include 'clab/labels.j2' %}\n</code></pre> <p>Neste exemplo:</p> <ul> <li><code>{{ name }}</code> \u00e9 uma vari\u00e1vel que ser\u00e1 substitu\u00edda pelo nome do dispositivo.</li> <li><code>kind</code> define o tipo de dispositivo, neste caso, \"ceos\".</li> <li><code>image</code> especifica a imagem do dispositivo.</li> <li><code>startup-config</code> permite definir um arquivo de configura\u00e7\u00e3o inicial.</li> <li><code>binds</code> permite mapear volumes, como o mapeamento de interfaces.</li> <li><code>include</code> \u00e9 usado para incluir labels adicionais do template CLAB.</li> </ul>"},{"location":"Guias/Netreplica/NetReplica%20Criando%20Templates/#criando-templates-clab","title":"Criando Templates CLAB","text":"<p>Para criar seus pr\u00f3prios templates CLAB, siga a estrutura e o formato de exemplo fornecido. Voc\u00ea pode criar arquivos <code>.j2</code> lembrando que o nome do arquivo dever\u00e1 ser o nome da plataforma, para cada tipo de dispositivo e personalizar as configura\u00e7\u00f5es conforme necess\u00e1rio. Salve seus templates no diret\u00f3rio <code>templates/clab/kinds/</code> do seu ambiente NetReplica.</p> <p>Ao criar e usar templates CLAB, voc\u00ea tem flexibilidade para definir como os dispositivos ser\u00e3o provisionados e configurados dentro do ambiente CLAB, permitindo uma replica\u00e7\u00e3o precisa da sua rede.</p> <p>Exemplo do template junos junos.j2</p> <pre><code>{{ name }}:\n            kind: crpd\n            image: crpd:23.1R1.8\n            {% if configuration_file is defined %}\n            startup-config: {{ configuration_file }}\n            {% endif %}\n            {% if interface_map is defined %}\n            binds:\n                - {{ interface_map }}:/mnt/flash/EosIntfMapping.json:ro\n            {% endif %}\n            {% include 'clab/labels.j2' %}\n</code></pre>"},{"location":"Guias/Netreplica/NetReplica%20Criando%20Templates/#passo2-executando-o-netreplica-com-o-arquivo-de-configuracao","title":"Passo2: Executando o NetReplica com o Arquivo de Configura\u00e7\u00e3o","text":"<p>Uma vez que voc\u00ea tenha criado e configurado o arquivo <code>.conf</code> com as op\u00e7\u00f5es desejadas, voc\u00ea est\u00e1 pronto para executar o NetReplica e iniciar a replica\u00e7\u00e3o e an\u00e1lise de redes com base nas informa\u00e7\u00f5es do NetBox. Siga os passos abaixo para executar o NetReplica:</p> <ol> <li>Localiza\u00e7\u00e3o do Arquivo de Configura\u00e7\u00e3o: Certifique-se de que o arquivo <code>.conf</code> esteja na localiza\u00e7\u00e3o correta. Se voc\u00ea estiver usando o NetReplica via Docker, lembre-se de que o arquivo <code>.conf</code> deve estar dentro do diret\u00f3rio \"conf\" que \u00e9 criado ap\u00f3s a execu\u00e7\u00e3o do compose.</li> <li>Iniciando o NetReplica: Abra um terminal ou prompt de comando e navegue at\u00e9 o diret\u00f3rio onde o NetReplica est\u00e1 instalado. Se voc\u00ea estiver usando o NetReplica via Docker, certifique-se de estar no diret\u00f3rio onde o arquivo <code>docker-compose.yml</code> est\u00e1 localizado.</li> <li> <p>Executando o NetReplica: Execute o comando para iniciar o NetReplica, passando o caminho para o arquivo <code>.conf</code> como um argumento. Por exemplo, se o arquivo <code>.conf</code> estiver no diret\u00f3rio atual e for chamado <code>netreplica.conf</code>, o comando pode ser:</p> <pre><code>nrx -c &lt;arquivo&gt;.conf\n</code></pre> </li> </ol> <p>Se voc\u00ea estiver usando o NetReplica via Docker, o comando para executar pode ser:</p> <pre><code>```bash\ndocker exec -it nrx ./nrx -c conf/&lt;arquivo&gt;.conf\n```\n</code></pre> <ol> <li>Acompanhando a Execu\u00e7\u00e3o: Durante a execu\u00e7\u00e3o, o NetReplica ir\u00e1 usar as configura\u00e7\u00f5es do arquivo <code>.conf</code> para acessar o NetBox e iniciar a replica\u00e7\u00e3o e an\u00e1lise da rede. Acompanhe a sa\u00edda do terminal para ver o progresso e qualquer mensagem relevante.</li> <li>Resultados da Execu\u00e7\u00e3o: Ap\u00f3s a execu\u00e7\u00e3o ser conclu\u00edda, os resultados da replica\u00e7\u00e3o e an\u00e1lise estar\u00e3o dispon\u00edveis no diret\u00f3rio de sa\u00edda especificado no arquivo <code>.conf</code> (geralmente o diret\u00f3rio <code>OUTPUT_DIR</code>). Voc\u00ea poder\u00e1 encontrar os arquivos exportados, como imagens, configura\u00e7\u00f5es de dispositivos e outros dados, de acordo com as configura\u00e7\u00f5es definidas.</li> </ol> <p>Lembre-se de que o NetReplica \u00e9 uma ferramenta poderosa para replica\u00e7\u00e3o e an\u00e1lise de redes com base nas informa\u00e7\u00f5es do NetBox. Ao executar o NetReplica com o arquivo de configura\u00e7\u00e3o corretamente configurado, voc\u00ea estar\u00e1 explorando as capacidades de integra\u00e7\u00e3o entre essas duas ferramentas para obter insights valiosos sobre sua rede.</p>"},{"location":"Guias/Netreplica/NetReplica%20Criando%20Templates/#fontes","title":"Fontes","text":"<ol> <li>NetReplica (NRX) GitHub Repository. Dispon\u00edvel em: https://github.com/netreplica/nrx</li> <li>NetReplica Templates GitHub Repository. Dispon\u00edvel em: https://github.com/netreplica/templates</li> <li>ContainerLab Manual - Kinds. Dispon\u00edvel em: https://containerlab.dev/manual/kinds/</li> </ol>"},{"location":"Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/","title":"NetReplica Guia: Configura\u00e7\u00e3o e Execu\u00e7\u00e3o com NetBox","text":"<p>Este guia descreve as configura\u00e7\u00f5es necess\u00e1rias para integrar o NetReplica com o NetBox. O NetReplica \u00e9 uma ferramenta usada para replicar e analisar redes, enquanto o NetBox \u00e9 uma plataforma de gerenciamento de ativos de rede.</p>"},{"location":"Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#passo-1-execucao-direta-com-nrx","title":"Passo 1: Execu\u00e7\u00e3o Direta com NRX","text":"<p>Observa\u00e7\u00e3o</p> <p>antes de prosseguir verifique se o NetReplica est\u00e1 instalado e se o NetBox est\u00e1 instalado, pode ter mais informa\u00e7\u00f5es aqui: Intala\u00e7\u00e3o Netreplica</p> <p>O <code>nrx</code> \u00e9 a interface de linha de comando do NetReplica que permite configurar e executar tarefas diretamente sem a necessidade de criar um arquivo de configura\u00e7\u00e3o. A seguir, s\u00e3o apresentados os principais comandos que voc\u00ea pode usar:</p>"},{"location":"Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#comandos-basicos","title":"Comandos B\u00e1sicos","text":"<p>1 Comando para Exportar uma Topologia:</p> <pre><code>nrx -c conf/&lt;Nome_da_Topologia&gt;.conf\n</code></pre> <p>Este comando utiliza o arquivo de configura\u00e7\u00e3o <code>.conf</code> para exportar a topologia especificada.</p> <p>2 Exportar a partir de uma URL de API do NetBox:</p> <pre><code>nrx -a http://&lt;ip_do_netbox&gt;:&lt;porta&gt; -t '&lt;tags&gt;' -s '&lt;site&gt;' -o clab\n</code></pre> <p>Este comando permite a exporta\u00e7\u00e3o utilizando par\u00e2metros diretamente na linha de comando, como URL da API do NetBox, tags, site, e formato de sa\u00edda.</p> <p>3 Utilizar Tokens de Autentica\u00e7\u00e3o:</p> <p>Para passar o token de autentica\u00e7\u00e3o sem usar um arquivo de configura\u00e7\u00e3o:</p> <pre><code>export NB_API_TOKEN='seu_token_aqui'\nnrx -a http://&lt;ip_do_netbox&gt;:&lt;porta&gt; -t '&lt;tags&gt;' -s '&lt;site&gt;' -o clab\n</code></pre> <p>4 Especificar o Diret\u00f3rio de Sa\u00edda:</p> <pre><code>nrx -c conf/&lt;Nome_da_Topologia&gt;.conf -D /caminho/para/saida\n</code></pre> <p>Este comando permite definir um diret\u00f3rio espec\u00edfico para a sa\u00edda dos arquivos exportados.</p> <p>5 Ignorar Certificado TLS:</p> <pre><code>nrx -c conf/&lt;Nome_da_Topologia&gt;.conf --insecure\n</code></pre> <p>Este comando desativa a verifica\u00e7\u00e3o do certificado TLS.</p>"},{"location":"Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#argumentos-comuns-do-nrx","title":"Argumentos Comuns do <code>nrx</code>","text":"<ul> <li><code>-c, --config CONFIG</code>: Define o arquivo de configura\u00e7\u00e3o a ser utilizado.</li> <li><code>-a, --api API</code>: Define a URL da API do NetBox.</li> <li><code>-s, --site SITE</code>: Especifica o site do NetBox a ser exportado.</li> <li><code>-t, --tags TAGS</code>: Define as tags do NetBox a serem exportadas.</li> <li><code>-o, --output OUTPUT</code>: Define o formato de sa\u00edda (ex.: 'clab', 'cyjs').</li> <li><code>-D, --dir DIR</code>: Define o diret\u00f3rio de sa\u00edda.</li> <li><code>--insecure</code>: Desativa a verifica\u00e7\u00e3o do certificado TLS.</li> </ul>"},{"location":"Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#passo-2-configuracao-do-arquivo-conf","title":"Passo 2: Configura\u00e7\u00e3o do Arquivo <code>.conf</code>","text":"<p>O arquivo de configura\u00e7\u00e3o <code>.conf</code> fornece um meio estruturado de definir as vari\u00e1veis necess\u00e1rias para a exporta\u00e7\u00e3o de topologias. Ele \u00e9 particularmente \u00fatil quando voc\u00ea deseja reutilizar as mesmas configura\u00e7\u00f5es ou quando h\u00e1 muitas op\u00e7\u00f5es a serem definidas.</p> <p>Claro, aqui est\u00e1 o arquivo de configura\u00e7\u00e3o com uma explica\u00e7\u00e3o detalhada para cada campo:</p>"},{"location":"Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#arquivo-de-configuracao-resumido","title":"Arquivo de Configura\u00e7\u00e3o Resumido","text":"<pre><code>NB_API_URL           = 'http://localhost:8000'    # NetBox API URL or NB_API_URL env var\nNB_API_TOKEN         = ''                         # API Token or NB_API_TOKEN env var\nTLS_VALIDATE         = false                      # TLS certificate validation\nAPI_TIMEOUT          = 10                         # API timeout (s)\n\nTOPOLOGY_NAME        = 'lab'         # Topology name\nOUTPUT_FORMAT        = 'clab'        # Output format: gml | cyjs | clab\nOUTPUT_DIR           = 'conf/lab'    # Output directory (default: ./&lt;topology&gt;)\nTEMPLATES_PATH       = ['templates']\nPLATFORM_MAP         = 'templates/platform_map.yaml'   # Platform mapping file\nEXPORT_CONFIGS       = true           # Export configs if available\n\nEXPORT_DEVICE_ROLES  = []             # Device roles to export\nEXPORT_SITES         = ['DM-Akron']   # Sites to export\nEXPORT_TAGS          = []             # Tags to export\n</code></pre>"},{"location":"Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#configuracoes-da-api-do-netbox","title":"Configura\u00e7\u00f5es da API do NetBox","text":""},{"location":"Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#1-nb_api_url","title":"1. NB_API_URL","text":"<ul> <li>Descri\u00e7\u00e3o: URL da API do NetBox.</li> <li>Uso: Define o endere\u00e7o da inst\u00e2ncia do NetBox a ser consultada pelo NetReplica.</li> <li>Exemplo: <code>'http://localhost:8000'</code>.</li> </ul>"},{"location":"Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#2-nb_api_token","title":"2. NB_API_TOKEN","text":"<ul> <li>Descri\u00e7\u00e3o: Token de autentica\u00e7\u00e3o da API do NetBox.</li> <li>Uso: Necess\u00e1rio para autenticar requisi\u00e7\u00f5es \u00e0 API.</li> <li>Exemplo: <code>''</code> (deve ser preenchido com o token real).</li> </ul>"},{"location":"Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#3-tls_validate","title":"3. TLS_VALIDATE","text":"<ul> <li>Descri\u00e7\u00e3o: Controla a valida\u00e7\u00e3o de certificados TLS.</li> <li>Uso: <code>true</code> ativa valida\u00e7\u00e3o (recomendado em produ\u00e7\u00e3o); <code>false</code> desativa (\u00fatil em testes).</li> <li>Exemplo: <code>false</code>.</li> </ul>"},{"location":"Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#4-api_timeout","title":"4. API_TIMEOUT","text":"<ul> <li>Descri\u00e7\u00e3o: Tempo limite para requisi\u00e7\u00f5es \u00e0 API, em segundos.</li> <li>Uso: Define quanto tempo o NetReplica espera por uma resposta antes de considerar a requisi\u00e7\u00e3o falha.</li> <li>Exemplo: <code>10</code>.</li> </ul>"},{"location":"Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#configuracoes-de-exportacao","title":"Configura\u00e7\u00f5es de Exporta\u00e7\u00e3o","text":""},{"location":"Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#5-topology_name","title":"5. TOPOLOGY_NAME","text":"<ul> <li>Descri\u00e7\u00e3o: Nome da topologia exportada.</li> <li>Uso: Identifica os arquivos exportados e agrupa a topologia.</li> <li>Exemplo: <code>'lab'</code>.</li> </ul>"},{"location":"Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#6-output_format","title":"6. OUTPUT_FORMAT","text":"<ul> <li>Descri\u00e7\u00e3o: Formato dos dados exportados.</li> <li>Uso: Pode ser <code>'gml'</code>, <code>'cyjs'</code> ou <code>'clab'</code>.</li> <li>Exemplo: <code>'clab'</code>.</li> </ul>"},{"location":"Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#7-output_dir","title":"7. OUTPUT_DIR","text":"<ul> <li>Descri\u00e7\u00e3o: Diret\u00f3rio de destino dos arquivos exportados.</li> <li>Uso: Substitui o diret\u00f3rio padr\u00e3o de exporta\u00e7\u00e3o.</li> <li>Exemplo: <code>'conf/lab'</code>.</li> </ul>"},{"location":"Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#8-templates_path","title":"8. TEMPLATES_PATH","text":"<ul> <li>Descri\u00e7\u00e3o: Lista de diret\u00f3rios de templates usados na exporta\u00e7\u00e3o.</li> <li>Uso: Permite localizar templates personalizados.</li> <li>Exemplo: <code>['templates']</code>.</li> </ul>"},{"location":"Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#9-platform_map","title":"9. PLATFORM_MAP","text":"<ul> <li>Descri\u00e7\u00e3o: Arquivo de mapeamento de plataformas.</li> <li>Uso: Define como cada plataforma de dispositivo ser\u00e1 representada nos arquivos exportados.</li> <li>Exemplo: <code>'templates/platform_map.yaml'</code>.</li> </ul>"},{"location":"Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#10-export_configs","title":"10. EXPORT_CONFIGS","text":"<ul> <li>Descri\u00e7\u00e3o: Define se configura\u00e7\u00f5es dos dispositivos devem ser exportadas.</li> <li>Uso: <code>true</code> inclui as configs, <code>false</code> as ignora.</li> <li>Exemplo: <code>true</code>.</li> </ul>"},{"location":"Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#configuracoes-de-filtro-de-dispositivos","title":"Configura\u00e7\u00f5es de Filtro de Dispositivos","text":""},{"location":"Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#11-export_device_roles","title":"11. EXPORT_DEVICE_ROLES","text":"<ul> <li>Descri\u00e7\u00e3o: Lista de fun\u00e7\u00f5es de dispositivos a serem exportadas.</li> <li>Uso: Filtra quais dispositivos ser\u00e3o inclu\u00eddos.</li> <li>Exemplo: <code>[]</code> (exporta todas se vazio).</li> </ul>"},{"location":"Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#12-export_sites","title":"12. EXPORT_SITES","text":"<ul> <li>Descri\u00e7\u00e3o: Lista de sites do NetBox a serem exportados.</li> <li>Uso: Filtra dispositivos por site.</li> <li>Exemplo: <code>['DM-Akron']</code>.</li> </ul>"},{"location":"Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#13-export_tags","title":"13. EXPORT_TAGS","text":"<ul> <li>Descri\u00e7\u00e3o: Lista de tags usadas como filtro para exporta\u00e7\u00e3o.</li> <li>Uso: Somente dispositivos com essas tags ser\u00e3o exportados.</li> <li>Exemplo: <code>[]</code> (exporta todos se vazio).</li> </ul> <p>Esse arquivo de configura\u00e7\u00e3o permite uma personaliza\u00e7\u00e3o detalhada da forma como o NetReplica interage com o NetBox e exporta os dados,  ajudando a atender a necessidades espec\u00edficas de visualiza\u00e7\u00e3o e exporta\u00e7\u00e3o.</p>"},{"location":"Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<p>Agora para se aprofundar mais pode conferir o proximo guia que mostra como criar e configurar novos Templates e adicionar novas imagens ao netreplica. confira aqui NetReplica Criando Templates.</p>"},{"location":"Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#referencias","title":"Refere\u0302ncias","text":"<ul> <li>NetReplica GitHub Repository</li> </ul>"},{"location":"Laborat%C3%B3rios/","title":"Containerlab","text":"<p>Containerlab \u00e9 uma ferramenta poderosa para criar e gerenciar laborat\u00f3rios de rede virtualizados. Com ele, voc\u00ea pode simular topologias de rede complexas utilizando cont\u00eaineres Docker. A seguir, voc\u00ea encontrar\u00e1 informa\u00e7\u00f5es sobre os pr\u00e9-requisitos, ferramentas recomendadas e como documentar seus laborat\u00f3rios.</p>"},{"location":"Laborat%C3%B3rios/#pre-requisitos","title":"Pr\u00e9-requisitos","text":"<p>Antes de come\u00e7ar a utilizar o Containerlab, certifique-se de ter os seguintes pr\u00e9-requisitos instalados:</p>"},{"location":"Laborat%C3%B3rios/#docker","title":"Docker","text":"<ul> <li>O Docker \u00e9 utilizado pelo Containerlab para criar e executar os cont\u00eaineres que comp\u00f5em a rede virtualizada.</li> <li>Link: Documenta\u00e7\u00e3o oficial do Docker.</li> </ul>"},{"location":"Laborat%C3%B3rios/#containerlab_1","title":"Containerlab","text":"<ul> <li>Instale o Containerlab conforme as instru\u00e7\u00f5es fornecidas na documenta\u00e7\u00e3o oficial.</li> <li>Link: Documenta\u00e7\u00e3o oficial do Containerlab.</li> </ul>"},{"location":"Laborat%C3%B3rios/#labs-disponiveis","title":"Labs Dispon\u00edveis","text":"<p>Aqui est\u00e1 um exemplo de laborat\u00f3rio configurado para simular OSPF utilizando Junos:</p>"},{"location":"Laborat%C3%B3rios/#roteamento-ospf-junos","title":"Roteamento OSPF (Junos)","text":"<ul> <li>Simula\u00e7\u00e3o de OSPF com Junos, uma das tecnologias de roteamento mais utilizadas.</li> <li>Link: Roteamento OSPF (Junos) Lab.</li> </ul>"},{"location":"Laborat%C3%B3rios/#descoberta-junos","title":"Descoberta (Junos)","text":"<ul> <li>Importa\u00e7\u00e3o de roteadores com scripts, utilizando Zabbix e Netbox.</li> <li>Link: Descoberta (Junos) Lab.</li> </ul>"},{"location":"Laborat%C3%B3rios/#monitoramento-elk-junos","title":"Monitoramento ELK (Junos)","text":"<ul> <li>Exporta\u00e7\u00e3o de fluxos IPFIX para Elasticsearch com Elastic Agent.</li> <li>Visualiza\u00e7\u00e3o dos fluxos em tempo real com dashboards no Kibana.</li> <li>Link: Monitoramento ELK (Junos).</li> </ul>"},{"location":"Laborat%C3%B3rios/#monitoramento-telegraf-junos","title":"Monitoramento Telegraf (junos)","text":"<ul> <li>Exporta\u00e7\u00e3o de fluxos de tr\u00e1fego via Telegraf/IPFIX para InfluxDB.</li> <li>Dashboards prontos no Grafana para an\u00e1lise de tr\u00e1fego por interface e protocolo.</li> <li>Link: Monitoramento Telegraf (Junos).</li> </ul>"},{"location":"Laborat%C3%B3rios/#monitoramento-zabbix-junos","title":"Monitoramento Zabbix (junos)","text":"<ul> <li>Monitoramento de roteadores via SNMP com coleta centralizada pelo Zabbix Server.</li> <li>Permite visualiza\u00e7\u00e3o de m\u00e9tricas e alertas em tempo real no frontend do Zabbix.</li> <li>Link: Monitoramento Zabbix (Junos).</li> </ul>"},{"location":"Laborat%C3%B3rios/#ferramentas-de-analise-recomendadas","title":"Ferramentas de An\u00e1lise Recomendadas","text":"<p>Al\u00e9m do Containerlab, voc\u00ea pode utilizar as seguintes ferramentas de an\u00e1lise para monitorar e depurar sua rede virtualizada:</p>"},{"location":"Laborat%C3%B3rios/#librenms","title":"LibreNMS","text":"<ul> <li>Uma plataforma de monitoramento de rede baseada na web, que fornece insights sobre o desempenho e a sa\u00fade da rede. Ideal para monitoramento cont\u00ednuo da rede em tempo real.</li> </ul>"},{"location":"Laborat%C3%B3rios/#wireshark","title":"Wireshark","text":"<ul> <li>Ferramenta de captura e an\u00e1lise de pacotes que permite examinar o tr\u00e1fego de rede em detalhes. Essencial para depura\u00e7\u00e3o e an\u00e1lise de protocolos de rede.</li> </ul> <p>al\u00e9m destas ferramentas mencionadas ha outras que podem ser configuradas conforme suas necessidades, para saber mais acesse: Ferramentas de An\u00e1lise.</p>"},{"location":"Laborat%C3%B3rios/#documentando-seus-labs","title":"Documentando Seus Labs","text":"<p>Para garantir que seus laborat\u00f3rios sejam bem documentados e f\u00e1ceis de entender, consulte a se\u00e7\u00e3o sobre Documenta\u00e7\u00e3o de Labs. L\u00e1, voc\u00ea encontrar\u00e1 boas pr\u00e1ticas e exemplos para criar documenta\u00e7\u00e3o clara e \u00fatil para os seus ambientes simulados.</p> <ul> <li>Link: Documenta\u00e7\u00e3o de Labs.</li> </ul>"},{"location":"Laborat%C3%B3rios/Contribua/","title":"Documentando os laboratorios","text":"<p>Contribuir para a documenta\u00e7\u00e3o dos laborat\u00f3rios no Containerlab \u00e9 um processo simples, mas \u00e9 importante seguir algumas etapas para garantir que todos os links e funcionalidades funcionem corretamente. Esta p\u00e1gina fornece as instru\u00e7\u00f5es necess\u00e1rias para documentar um laborat\u00f3rio, bem como para configurar os scripts essenciais para o funcionamento adequado do processo de implanta\u00e7\u00e3o.</p>"},{"location":"Laborat%C3%B3rios/Contribua/#1-criando-a-documentacao-do-lab","title":"1. Criando a Documenta\u00e7\u00e3o do Lab","text":""},{"location":"Laborat%C3%B3rios/Contribua/#criando-imagens-para-representar-laboratorios","title":"Criando Imagens para Representar Laborat\u00f3rios","text":"<p>Na documenta\u00e7\u00e3o e importante os laborat\u00f3rios tenham imagens representando a topologia de rede do laborat\u00f3rio. Para isso, seguir o Guia Criando Imagens para Representar Laborat\u00f3rios.</p>"},{"location":"Laborat%C3%B3rios/Contribua/#passos-para-documentar-o-lab","title":"Passos para Documentar o Lab","text":"<p>Aqui est\u00e3o os principais passos para a documenta\u00e7\u00e3o do seu laborat\u00f3rio:</p> <ol> <li>Criar Descri\u00e7\u00e3o e Objetivo do Lab:<ul> <li>Descreva o que o laborat\u00f3rio faz e qual protocolo ou funcionalidade est\u00e1 sendo demonstrada.</li> </ul> </li> <li>Documentar a Topologia do Lab:<ul> <li>Utilize as imagens criadas para ilustrar a topologia da rede do laborat\u00f3rio. Se necess\u00e1rio, insira diagramas adicionais explicando como os dispositivos est\u00e3o interconectados.</li> </ul> </li> <li>Incluir Exemplos de Uso:<ul> <li>Forne\u00e7a exemplos de comandos e a\u00e7\u00f5es que os usu\u00e1rios podem executar dentro do laborat\u00f3rio para testar a funcionalidade.</li> </ul> </li> <li>Listar Requisitos:<ul> <li>Defina claramente os requisitos de hardware e software, como a vers\u00e3o do Docker, Containerlab e as configura\u00e7\u00f5es da rede.</li> </ul> </li> <li>Instru\u00e7\u00f5es de Implanta\u00e7\u00e3o:<ul> <li>Documente a implanta\u00e7\u00e3o do laborat\u00f3rio, seja a vers\u00e3o pronta ou personalizada. Certifique-se de seguir os guias de implanta\u00e7\u00e3o com links adequados.</li> </ul> </li> <li>Acessos e Credenciais:<ul> <li>Crie uma tabela detalhando os IPs de cada dispositivo no laborat\u00f3rio e suas respectivas credenciais de acesso.</li> </ul> </li> </ol> <p>Dica</p> <p>Para seguir um padr\u00e3o consistente de documenta\u00e7\u00e3o, voc\u00ea pode usar o template que j\u00e1 vem estruturado com dicas. Ele servir\u00e1 de base para voc\u00ea adaptar o conte\u00fado do seu laborat\u00f3rio, garantindo que todas as se\u00e7\u00f5es estejam corretamente abordadas.</p> <p>para usar o template de documenta\u00e7\u00e3o, basta acessar docs/pt/Laborat\u00f3rios/Contribua/Template lab.md criar uma copia para pasta laboratorios e colocar o nome de seu laboratorio e preencher as informacoes.</p>"},{"location":"Laborat%C3%B3rios/Contribua/#2-scripts-para-download-rapido","title":"2. Scripts para Download R\u00e1pido","text":"<p>Para garantir que o processo de download e implanta\u00e7\u00e3o do laborat\u00f3rio funcione corretamente, \u00e9 necess\u00e1rio incluir dois scripts essenciais dentro da pasta do laborat\u00f3rio no GitLab. Esses scripts permitir\u00e3o que o laborat\u00f3rio seja baixado e configurado automaticamente com um simples comando.</p>"},{"location":"Laborat%C3%B3rios/Contribua/#21-script-getsh","title":"2.1 Script <code>get.sh</code>","text":"<p>O script <code>get.sh</code> \u00e9 utilizado em sistemas Linux/Mac para baixar e descompactar automaticamente o laborat\u00f3rio. Ele verifica se o comando <code>tar</code> est\u00e1 instalado e, se n\u00e3o estiver, instala o pacote necess\u00e1rio antes de baixar o arquivo.</p>"},{"location":"Laborat%C3%B3rios/Contribua/#como-funciona","title":"Como Funciona:","text":"<ol> <li>Verifica\u00e7\u00e3o de Depend\u00eancias: O script verifica se o pacote <code>tar</code> est\u00e1 instalado. Se n\u00e3o, ele tenta instalar usando o gerenciador de pacotes do sistema (<code>apt-get</code>, <code>dnf</code>, <code>yum</code>, ou <code>pacman</code>).</li> <li>Download e Descompacta\u00e7\u00e3o: O script baixa o arquivo <code>.tar</code> contendo o laborat\u00f3rio e o descompacta no diret\u00f3rio de destino.</li> </ol>"},{"location":"Laborat%C3%B3rios/Contribua/#script-getsh","title":"Script <code>get.sh</code>:","text":"<pre><code>#!/bin/bash\n\n# Fun\u00e7\u00e3o para verificar se um comando est\u00e1 instalado\ncheck_command() {\n    command -v \"$1\" &gt;/dev/null 2&gt;&amp;1\n}\n\n# Fun\u00e7\u00e3o para instalar pacotes\ninstall_package() {\n    if [ -x \"$(command -v apt-get)\" ]; then\n        sudo apt-get update\n        sudo apt-get install -y \"$1\"\n    elif [ -x \"$(command -v dnf)\" ]; then\n        sudo dnf install -y \"$1\"\n    elif [ -x \"$(command -v yum)\" ]; then\n        sudo yum install -y \"$1\"\n    elif [ -x \"$(command -v pacman)\" ]; then\n        sudo pacman -Sy --noconfirm \"$1\"\n    else\n        echo \"Erro: Gerenciador de pacotes n\u00e3o suportado. Instale '$1' manualmente.\"\n        exit 1\n    fi\n}\n\nif ! check_command tar; then\n    echo \"O pacote 'tar' n\u00e3o est\u00e1 instalado. Instalando...\"\n    install_package tar\nfi\n\n# URL do arquivo tar\nURL=\"&lt;https://git.rnp.br/redes-abertas/lab/-/archive/main/labs-main.tar?path=&lt;nome-do-lab&gt;&gt;\"\n\n# Nome do arquivo para salvar\nFILENAME=\"lab-main.tar\"\n\n# Diret\u00f3rio onde descompactar os arquivos\nDEST_DIR=\"./\"\n\n# Baixar o arquivo\necho \"Baixando $FILENAME...\"\ncurl -L -o $FILENAME \"$URL\"\n\n# Verificar se o download foi bem-sucedido\nif [ $? -ne 0 ]; then\n    echo \"Erro ao baixar o arquivo.\"\n    exit 1\nfi\n\n# Descompactar o arquivo\necho \"Descompactando $FILENAME...\"\ntar -xf $FILENAME -C $DEST_DIR --strip-components=1\n\n# Verificar se a descompacta\u00e7\u00e3o foi bem-sucedida\nif [ $? -ne 0 ]; then\n    echo \"Erro ao descompactar o arquivo.\"\n    exit 1\nfi\n\n# Remover o arquivo tar ap\u00f3s descompactar\nrm $FILENAME\n\necho \"Download e descompacta\u00e7\u00e3o conclu\u00eddos com sucesso.\"\n</code></pre>"},{"location":"Laborat%C3%B3rios/Contribua/#variaveis-a-modificar","title":"Vari\u00e1veis a Modificar:","text":"<ul> <li><code>URL</code>: Alterar a URL para corresponder ao reposit\u00f3rio e ao caminho do laborat\u00f3rio dentro do GitLab.</li> </ul>"},{"location":"Laborat%C3%B3rios/Contribua/#22-script-getbat","title":"2.2 Script <code>get.bat</code>","text":"<p>O script <code>get.bat</code> \u00e9 usado em sistemas Windows para baixar e descompactar o laborat\u00f3rio de maneira similar ao <code>get.sh</code>, mas com comandos compat\u00edveis com o ambiente Windows.</p>"},{"location":"Laborat%C3%B3rios/Contribua/#script-getbat","title":"Script <code>get.bat</code>:","text":"<pre><code>@echo off\nsetlocal\n\nREM URL do arquivo tar\nset \"URL=https://git.rnp.br/redes-abertas/docker-composes/-/archive/main/docker-composes-main.tar?path=&lt;nome-do-lab&gt;\"\n\nREM Nome do arquivo para salvar\nset \"FILENAME=lab-main.tar\"\n\nREM Diret\u00f3rio onde descompactar os arquivos\nset \"DEST_DIR=.\"\n\necho Baixando %FILENAME%...\ncurl -L -o %FILENAME% %URL%\n\nREM Verificar se o download foi bem-sucedido\nif not exist %FILENAME% (\n    echo Erro ao baixar o arquivo.\n    exit /b 1\n)\n\necho Descompactando %FILENAME%...\ntar -xf %FILENAME% -C %DEST_DIR% --strip-components=1\n\nREM Verificar se a descompacta\u00e7\u00e3o foi bem-sucedida\nif %errorlevel% neq 0 (\n    echo Erro ao descompactar o arquivo.\n    exit /b 1\n)\n\nREM Remover o arquivo tar ap\u00f3s descompactar\ndel %FILENAME%\n\necho Download e descompacta\u00e7\u00e3o conclu\u00eddos com sucesso.\n\nendlocal\npause\n</code></pre>"},{"location":"Laborat%C3%B3rios/Contribua/#variaveis-a-modificar_1","title":"Vari\u00e1veis a Modificar:","text":"<ul> <li><code>URL</code>: Alterar a URL para o caminho espec\u00edfico do seu laborat\u00f3rio no reposit\u00f3rio GitLab.</li> </ul>"},{"location":"Laborat%C3%B3rios/Contribua/#3-certificando-se-de-que-os-scripts-estao-corretos","title":"3. Certificando-se de que os Scripts est\u00e3o Corretos","text":"<p>Para garantir que o processo de download r\u00e1pido funcione corretamente, os dois scripts (get.sh e get.bat) devem ser inclu\u00eddos na pasta do lab em quest\u00e3o dentro do reposit\u00f3rio do laborat\u00f3rio. Isso assegura que, ao usar os links de download, os usu\u00e1rios possam baixar e descompactar o laborat\u00f3rio de forma eficiente, sem problemas.</p> <p>Dica</p> <p>Quando for incluir os scripts no GitLab, verifique se as URLs est\u00e3o configuradas corretamente com os nomes correspondentes \u00e0 pasta do reposit\u00f3rio e ao nome do laborat\u00f3rio.</p> <p>Com essas etapas, voc\u00ea poder\u00e1 contribuir efetivamente para a documenta\u00e7\u00e3o do laborat\u00f3rio e garantir que todos os links de download e scripts estejam funcionando corretamente.</p>"},{"location":"Laborat%C3%B3rios/Contribua/Guia%20Criando%20Imagens%20para%20Representar%20Laborat%C3%B3rios/","title":"Guia : Criando Imagens para Representar Laborat\u00f3rios","text":"<p>Este guia ensina como criar imagens representando topologias de rede para os laborat\u00f3rios, utilizando o template do Draw.io fornecido no reposit\u00f3rio. As imagens devem seguir a identidade visual do projeto e ser salvas no formato SVG dentro da pasta correta.</p>"},{"location":"Laborat%C3%B3rios/Contribua/Guia%20Criando%20Imagens%20para%20Representar%20Laborat%C3%B3rios/#1-abrindo-o-template","title":"1. Abrindo o Template","text":"<p>Na raiz do reposit\u00f3rio <code>docs/Templates</code>, voc\u00ea encontrar\u00e1 um template do Draw.io. que pode v\u00ea-lo abaixo Abra o arquivo e ver\u00e1 que ele j\u00e1 cont\u00e9m todos os componentes necess\u00e1rios para criar topologias de rede, incluindo:</p> <p></p> <ul> <li>Cards de Aplica\u00e7\u00f5es: Representam ativos ou protocolos como Grafana e OpenConfig.</li> <li>Componentes de Rede: \u00cdcones de roteadores, switches e servidores.</li> </ul>"},{"location":"Laborat%C3%B3rios/Contribua/Guia%20Criando%20Imagens%20para%20Representar%20Laborat%C3%B3rios/#2-montando-a-topologia","title":"2. Montando a Topologia","text":"<ol> <li>Adicione Componentes de Rede: Copie e cole os \u00edcones de roteadores, switches e servidores da \u00e1rea de componentes do template.</li> <li>Adicione Cards de Aplica\u00e7\u00f5es: Posicione os cards que representam os ativos/protocolos na topologia.</li> <li>Conecte os Componentes: Use linhas (para interconex\u00f5es) e setas (para direcionar para os IPs) para conectar os componentes e criar a estrutura de rede.</li> </ol>"},{"location":"Laborat%C3%B3rios/Contribua/Guia%20Criando%20Imagens%20para%20Representar%20Laborat%C3%B3rios/#especificacoes-de-estilo-para-a-topologia","title":"Especifica\u00e7\u00f5es de Estilo para a Topologia","text":"Elemento Especifica\u00e7\u00e3o Fonte de T\u00edtulo Fonte: Times New Roman, Tamanho: 28px Fonte de Subt\u00edtulo Fonte: Times New Roman, Tamanho: 25px Linhas de Conex\u00e3o Espessura: 11px, Tipo: Linhas retas (para interconex\u00f5es) Setas para IPs Espessura: 11px, Tipo: Setas (para direcionar para os IPs) Caixas de Interface Tamanho da Fonte: 11px <p>Com essas especifica\u00e7\u00f5es, voc\u00ea garante que as topologias sigam o padr\u00e3o visual do projeto e fiquem consistentes com o restante da documenta\u00e7\u00e3o.</p>"},{"location":"Laborat%C3%B3rios/Contribua/Guia%20Criando%20Imagens%20para%20Representar%20Laborat%C3%B3rios/#3-adicionando-interfaces-e-ips","title":"3. Adicionando Interfaces e IPs","text":"<ol> <li>Crie a Caixa de Texto para Interfaces: Para cada conex\u00e3o, desenhe um quadrado representando a interface.</li> <li>Adicione Propriedade de IP:<ul> <li>Selecione o quadrado.</li> <li>Clique com o bot\u00e3o direito e escolha Adicionar/Editar dados.</li> <li>Clique em Adicionar Propriedade, coloque o nome como ip e adicione o endere\u00e7o IP da interface.</li> </ul> </li> </ol> <p>Quando o mouse passar sobre o quadrado, o IP ser\u00e1 exibido como uma dica de ferramenta.</p>"},{"location":"Laborat%C3%B3rios/Contribua/Guia%20Criando%20Imagens%20para%20Representar%20Laborat%C3%B3rios/#4-salvando-a-imagem","title":"4. Salvando a Imagem","text":"<p>Ap\u00f3s finalizar a topologia, salve a imagem no formato SVG:</p> <ol> <li>Salve como SVG: No Draw.io, v\u00e1 em Arquivo &gt; Exportar Como &gt; svg.</li> <li>Pasta de Destino: Salve a imagem na pasta <code>docs/img/labs_imgs/</code>.</li> </ol> <p>Aten\u00e7\u00e3o</p> <p>Certifique-se de selecionar na hora de exportar selecionar na op\u00e7\u00e3o Appearance: como Light.</p>"},{"location":"Laborat%C3%B3rios/Contribua/Guia%20Criando%20Imagens%20para%20Representar%20Laborat%C3%B3rios/#5-atualizando-a-documentacao","title":"5. Atualizando a Documenta\u00e7\u00e3o","text":"<p>Ap\u00f3s salvar a imagem, atualize o arquivo Markdown da documenta\u00e7\u00e3o, incluindo a imagem da topologia:</p> <pre><code>![Diagrama de Topologia de Rede](../../labs_imgs/nome-do-lab/nome-da-imagem.svg)\n</code></pre>"},{"location":"Laborat%C3%B3rios/Contribua/Template%20lab/","title":"Template lab (Nome Do lab)","text":"<p>Este template serve como um exemplo para a cria\u00e7\u00e3o de guias de implementa\u00e7\u00e3o de laborat\u00f3rios no Containerlab. Ele est\u00e1 estruturado de forma a servir como modelo para todos os laborat\u00f3rios do projeto, com informa\u00e7\u00f5es que devem ser seguidas de maneira consistente em cada documenta\u00e7\u00e3o. Cada laborat\u00f3rio pode ter suas especificidades, mas a estrutura geral e as se\u00e7\u00f5es a seguir permanecem iguais para todos os labs.</p>"},{"location":"Laborat%C3%B3rios/Contribua/Template%20lab/#1-descricao","title":"1. Descri\u00e7\u00e3o","text":""},{"location":"Laborat%C3%B3rios/Contribua/Template%20lab/#objetivo-do-lab","title":"Objetivo do Lab","text":"<p>Descreva o objetivo do laborat\u00f3rio de forma clara, explicando o que ser\u00e1 demonstrado ou testado. Seja breve, mas inclua as funcionalidades principais que o usu\u00e1rio ir\u00e1 explorar.</p> <p>Nesta parte deve conter uma imagem contendo a topologia do lab Topologia do Lab</p> <p>Exemplo:O laborat\u00f3rio \"ospf-lab\" demonstra a configura\u00e7\u00e3o e teste de roteamento OSPF (Open Shortest Path First) em uma rede composta por m\u00faltiplos roteadores. O foco principal \u00e9 verificar o estabelecimento da vizinhan\u00e7a OSPF e o roteamento entre os dispositivos da rede.</p> <p>Dica</p> <p>Mantenha a descri\u00e7\u00e3o clara e concisa, destacando o que \u00e9 essencial para o usu\u00e1rio entender rapidamente o que o laborat\u00f3rio ir\u00e1 proporcionar.</p> <p>Topologia do Lab Aqui, inclua o diagrama ou uma descri\u00e7\u00e3o textual detalhada da topologia, mencionando os dispositivos e como est\u00e3o interligados.</p> <p>Claro! Abaixo est\u00e1 um template geral da se\u00e7\u00e3o \"Exemplo de Aplica\u00e7\u00e3o\", com uma descri\u00e7\u00e3o orientativa para o usu\u00e1rio entender o que incluir nessa parte do guia, seguida por um exemplo pr\u00e1tico que pode ser adaptado em qualquer laborat\u00f3rio semelhante:</p>"},{"location":"Laborat%C3%B3rios/Contribua/Template%20lab/#exemplo-de-aplicacao","title":"Exemplo de Aplica\u00e7\u00e3o","text":"<p>Descri\u00e7\u00e3o: Utilize esta se\u00e7\u00e3o para apresentar cen\u00e1rios pr\u00e1ticos e objetivos nos quais o laborat\u00f3rio pode ser aplicado. O foco deve estar nas poss\u00edveis finalidades de uso, como treinamento, testes de desempenho, valida\u00e7\u00e3o de configura\u00e7\u00f5es ou estudo de protocolos. Evite detalhes t\u00e9cnicos da implementa\u00e7\u00e3o e concentre-se em para que o laborat\u00f3rio pode ser usado em ambientes reais ou acad\u00eamicos.</p> <p>Exemplo de Aplica\u00e7\u00e3o:</p> <p>Este laborat\u00f3rio \u00e9 ideal para cen\u00e1rios de simula\u00e7\u00e3o de redes reais, especialmente no contexto de roteamento din\u00e2mico e monitoramento. Ele pode ser aplicado em:</p> <ul> <li>Capacita\u00e7\u00e3o t\u00e9cnica: Treinamento de profissionais em protocolos de roteamento (como OSPF) e monitoramento com SNMP, utilizando ferramentas como o Zabbix.</li> <li>Testes de ambientes monitorados: Avalia\u00e7\u00e3o de como roteadores se comportam sob monitoramento cont\u00ednuo e descoberta autom\u00e1tica de dispositivos.</li> <li>Ensino em disciplinas de redes: Ambiente de apoio a aulas pr\u00e1ticas de redes de computadores, com foco em topologias ponto a ponto e integra\u00e7\u00e3o com sistemas de gest\u00e3o de rede.</li> <li>Valida\u00e7\u00e3o de integra\u00e7\u00e3o de ferramentas: Utilizado para validar a comunica\u00e7\u00e3o entre roteadores e plataformas de monitoramento em ambientes virtualizados.</li> </ul>"},{"location":"Laborat%C3%B3rios/Contribua/Template%20lab/#3-requisitos","title":"3. Requisitos","text":"<p>Este t\u00f3pico deve listar os requisitos m\u00ednimos de hardware e software necess\u00e1rios para executar o laborat\u00f3rio. Certifique-se de incluir as ferramentas essenciais, como Containerlab e Docker, al\u00e9m da rede <code>br-lab</code>.</p>"},{"location":"Laborat%C3%B3rios/Contribua/Template%20lab/#exemplo-de-tabela-de-requisitos","title":"Exemplo de Tabela de Requisitos:","text":"Requisito Detalhes CPUs [x] CPUs (especificar) Mem\u00f3ria RAM [x] GB Espa\u00e7o em Disco [x] GB Containerlab [Vers\u00e3o do Containerlab] Rede Criada [ br-lab] <p>Dica</p> <p>Verifique se a vers\u00e3o do Docker e do Containerlab s\u00e3o compat\u00edveis para evitar erros durante a implanta\u00e7\u00e3o.</p>"},{"location":"Laborat%C3%B3rios/Contribua/Template%20lab/#4-implantando-o-lab","title":"4. Implantando o Lab","text":"<p>Este t\u00f3pico descreve o processo de implanta\u00e7\u00e3o do laborat\u00f3rio, com as instru\u00e7\u00f5es detalhadas para o usu\u00e1rio baixar e iniciar o ambiente.</p>"},{"location":"Laborat%C3%B3rios/Contribua/Template%20lab/#41-implantacao-pronta","title":"4.1 Implanta\u00e7\u00e3o Pronta","text":"<p>Este m\u00e9todo permite ao usu\u00e1rio baixar uma vers\u00e3o pr\u00e9-montada do laborat\u00f3rio, com a topologia e as configura\u00e7\u00f5es j\u00e1 definidas. Basta baixar o reposit\u00f3rio e seguir para o in\u00edcio da execu\u00e7\u00e3o.</p> <p>Dica</p> <p>A implanta\u00e7\u00e3o pronta \u00e9 \u00fatil para quem deseja come\u00e7ar rapidamente com um ambiente configurado, mas n\u00e3o permite modifica\u00e7\u00f5es na topologia inicial.</p>"},{"location":"Laborat%C3%B3rios/Contribua/Template%20lab/#baixando-o-lab","title":"Baixando o Lab","text":"<p>Para baixar o laborat\u00f3rio, execute o comando correspondente ao seu sistema operacional.</p> Linux/MacWindows <pre><code>curl -L -o get.sh \"&lt;https://git.rnp.br/redes-abertas/labs/-/raw/main/&gt;&lt;nome-do-lab&gt;/get.sh?inline=false\" &amp;&amp; sh get.sh &amp;&amp; cd &lt;nome-do-lab&gt;\n</code></pre> <pre><code>curl -L -o get.bat \"&lt;https://git.rnp.br/redes-abertas/labs/-/raw/main/&gt;&lt;nome-do-lab&gt;/get.bat?inline=false\" &amp;&amp; call get.bat &amp;&amp; cd &lt;nome-do-lab&gt;\n</code></pre> <p>Este comando far\u00e1 o download do script de instala\u00e7\u00e3o e o direcionar\u00e1 para o diret\u00f3rio do laborat\u00f3rio.</p> <p>Dica</p> <p>Antes de executar os scripts, verifique se as permiss\u00f5es de execu\u00e7\u00e3o est\u00e3o corretas (use <code>chmod +x get.sh</code> no Linux/Mac).</p>"},{"location":"Laborat%C3%B3rios/Contribua/Template%20lab/#42-implantacao-customizada-em-desenvolvimento","title":"4.2 Implanta\u00e7\u00e3o Customizada (Em Desenvolvimento)","text":"<p>Se voc\u00ea deseja uma vers\u00e3o personalizada do laborat\u00f3rio, pode come\u00e7ar a modifica\u00e7\u00e3o utilizando ferramentas como NetBox e NetReplica. Este passo est\u00e1 em desenvolvimento, mas logo teremos mais informa\u00e7\u00f5es.</p> <p>Dica</p> <p>A personaliza\u00e7\u00e3o avan\u00e7ada pode ser \u00fatil para ajustar a topologia \u00e0s suas necessidades espec\u00edficas, como incluir mais dispositivos ou testar diferentes cen\u00e1rios.</p>"},{"location":"Laborat%C3%B3rios/Contribua/Template%20lab/#5-iniciando-o-lab","title":"5. Iniciando o Lab","text":"<p>Ap\u00f3s o download ou personaliza\u00e7\u00e3o, siga as etapas abaixo para iniciar o laborat\u00f3rio.</p>"},{"location":"Laborat%C3%B3rios/Contribua/Template%20lab/#51-subindo-o-lab","title":"5.1 Subindo o Lab","text":"<p>Execute o comando abaixo dentro do diret\u00f3rio onde o laborat\u00f3rio foi baixado ou personalizado:</p> <pre><code>sudo containerlab deploy\n</code></pre> <p>Esse comando iniciar\u00e1 a topologia definida no laborat\u00f3rio e criar\u00e1 todos os containers necess\u00e1rios.</p> <p>Dica</p> <p>Caso ocorra algum erro, verifique a sa\u00edda do comando para poss\u00edveis mensagens de erro. Use <code>docker logs &lt;container_name&gt;</code> para depurar.</p>"},{"location":"Laborat%C3%B3rios/Contribua/Template%20lab/#6-acesso","title":"6. Acesso","text":"<p>Ap\u00f3s o laborat\u00f3rio ser iniciado, voc\u00ea poder\u00e1 acessar os dispositivos e servi\u00e7os configurados na rede.</p>"},{"location":"Laborat%C3%B3rios/Contribua/Template%20lab/#61-tabela-de-ips-e-portas-de-servico","title":"6.1 Tabela de IPs e Portas de Servi\u00e7o","text":"<p>Aqui est\u00e1 um exemplo de tabela de dispositivos, IPs e portas de servi\u00e7o dispon\u00edveis no laborat\u00f3rio.</p> Dispositivo IP de Acesso Porta Servi\u00e7o Roteador 1 192.168.1.1 22 SSH Roteador 2 192.168.1.2 22 SSH Servidor de Monitoramento 192.168.1.3 8080 Web (Graphite) Servidor DB 192.168.1.4 3306 MySQL"},{"location":"Laborat%C3%B3rios/Contribua/Template%20lab/#62-senhas-de-acesso","title":"6.2 Senhas de Acesso","text":"<p>Aqui est\u00e1 um exemplo de tabela com as senhas de acesso dos servi\u00e7os configurados no laborat\u00f3rio.</p> Servi\u00e7o Usu\u00e1rio Senha Roteador 1 (SSH) admin admin@123 Roteador 2 (SSH) admin admin@123 Graphite (Web) admin admin@123 Banco de Dados MySQL root mysql@123 <p>Aten\u00e7\u00e3o</p> <p>antes de acessar acesse o log de um dispositivo para verificar se ele foi iniciado e configurado corretamente.</p>"},{"location":"Laborat%C3%B3rios/Contribua/Template%20lab/#7-proximos-passos","title":"7.  Pr\u00f3ximos Passos","text":"<p>esta parte destina-se para o que fazer depois de ter iniciado o laborat\u00f3rio. vc pode adicionar outros guias aqui como de  uso de alguma ferramenta ou opera\u00e7\u00e3o do laboratorio </p>"},{"location":"Laborat%C3%B3rios/Contribua/Template%20lab/#conclusao-apagar-depois","title":"Conclus\u00e3o (Apagar depois)","text":"<p>Este template foi projetado para servir como estrutura padr\u00e3o para documenta\u00e7\u00e3o de todos os laborat\u00f3rios do projeto. Ele deve ser seguido de maneira consistente para garantir clareza e padroniza\u00e7\u00e3o na cria\u00e7\u00e3o de novos laborat\u00f3rios. As se\u00e7\u00f5es descritas s\u00e3o essenciais e aplic\u00e1veis a qualquer laborat\u00f3rio dentro do Containerlab, com o objetivo de proporcionar uma experi\u00eancia fluida tanto para os desenvolvedores quanto para os usu\u00e1rios.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/","title":"Juniper Vjuniper Descoberta","text":""},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Este laborat\u00f3rio simula uma rede com 3 roteadores configurados com OSPF e SNMP, integrando o Zabbix e o Netbox para importa\u00e7\u00e3o e gerenciamento automatizado de dispositivos.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#1-descricao","title":"1. Descri\u00e7\u00e3o","text":""},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#11-objetivo-do-lab","title":"1.1 Objetivo do Lab","text":"<p>O objetivo deste laborat\u00f3rio \u00e9 importar os dispositivos de rede e suas configura\u00e7\u00f5es no Netbox a partir do Zabbix, al\u00e9m de demonstrar o funcionamento b\u00e1sico do roteamento OSPF entre tr\u00eas roteadores conectados em anel e monitorados via SNMP.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#12-topologia-do-lab","title":"1.2 Topologia do Lab","text":"<p>Abaixo a topologia em formato imagem, representando os roteadores, servidores e suas conex\u00f5es.</p> <p></p> <p>Os roteadores est\u00e3o configurados com as seguintes tecnologias:</p> <ul> <li>OSPF (Open Shortest Path First): Utilizado para roteamento din\u00e2mico na rede, permitindo que os roteadores troquem informa\u00e7\u00f5es sobre rotas e atualiza\u00e7\u00f5es de topologia.</li> <li>SNMP (Simple Network Management Protocol): Utilizado para monitoramento e gerenciamento da rede, permitindo o acesso a informa\u00e7\u00f5es de telemetria dos dispositivos.</li> </ul>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#2-aplicacoes","title":"2. Aplica\u00e7\u00f5es","text":""},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#exemplos-de-aplicacoes","title":"Exemplos de Aplica\u00e7\u00f5es","text":"<p>Este laborat\u00f3rio \u00e9 voltado \u00e0 experimenta\u00e7\u00e3o pr\u00e1tica com descoberta autom\u00e1tica de dispositivos em redes IP, integrando ferramentas de monitoramento (Zabbix) e documenta\u00e7\u00e3o (Netbox). Ele \u00e9 ideal para estudos e treinamentos que envolvem automa\u00e7\u00e3o de invent\u00e1rio, descoberta de topologia e integra\u00e7\u00e3o de dados de rede.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#possiveis-aplicacoes","title":"Poss\u00edveis Aplica\u00e7\u00f5es:","text":"<ul> <li> <p>Automa\u00e7\u00e3o da descoberta de rede: Demonstra como identificar automaticamente dispositivos ativos em uma rede usando Zabbix e como importar esses dados para o Netbox, reduzindo o esfor\u00e7o manual no mapeamento de ativos.</p> </li> <li> <p>Capacita\u00e7\u00e3o em NetDevOps e gest\u00e3o de invent\u00e1rio: Excelente para treinar profissionais em pr\u00e1ticas modernas de opera\u00e7\u00f5es de rede, com foco em integra\u00e7\u00e3o de ferramentas via API e automa\u00e7\u00e3o da documenta\u00e7\u00e3o de infraestrutura.</p> </li> <li> <p>Cria\u00e7\u00e3o de reposit\u00f3rio centralizado de dispositivos: Possibilita construir uma base confi\u00e1vel de dados sobre a rede em tempo real, a partir de informa\u00e7\u00f5es descobertas via SNMP e documentadas no Netbox.</p> </li> <li> <p>Estudo da integra\u00e7\u00e3o Zabbix + Netbox via API: Permite explorar o uso de APIs RESTful para sincronizar informa\u00e7\u00f5es entre ferramentas de monitoramento e gest\u00e3o de ativos de rede.</p> </li> <li> <p>Ensino de descoberta SNMP e gerenciamento centralizado: Proporciona uma experi\u00eancia pr\u00e1tica para alunos e profissionais entenderem como ocorre a coleta de dados de rede (interfaces, IPs, fabricantes etc.) e como esses dados s\u00e3o tratados por ferramentas de gerenciamento.</p> </li> </ul>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#3-requisitos","title":"3. Requisitos","text":""},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#31-pre-requisitos","title":"3.1 Pr\u00e9 requisitos","text":"<p>Para iniciar o laborat\u00f3rio, \u00e9 necess\u00e1rio a instala\u00e7\u00e3o e configura\u00e7\u00e3o dos seguintes componentes:</p> <ul> <li>Netbox</li> <li>Containerlab</li> <li>Docker</li> <li>Python</li> </ul> <p>Caso o seu ambiente n\u00e3o esteja configurado, siga os passos Guia de Configura\u00e7\u00e3o</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#32-tabela-de-requisitos-computacionais","title":"3.2 Tabela de Requisitos Computacionais","text":"Requisito Detalhes CPUs 4 vCPUs (m\u00ednimo recomendado) Mem\u00f3ria RAM 12 GB Espa\u00e7o em Disco 10 GB Containerlab 0.64.0 Rede Criada br-lab <p>Dica</p> <p>Verifique se a vers\u00e3o do Docker e do Containerlab s\u00e3o compat\u00edveis para evitar erros durante a implanta\u00e7\u00e3o.</p> <p>Aten\u00e7\u00e3o</p> <p>Verifique se o seu processador possui suporte \u00e0 virtualiza\u00e7\u00e3o por hardware e se essa funcionalidade est\u00e1 ativada na BIOS/UEFI. - Em processadores Intel, essa tecnologia \u00e9 chamada de VT-x (Intel Virtualization Technology). - Em processadores AMD, \u00e9 conhecida como AMD-V (AMD Virtualization).  </p> <p>Sem essa funcionalidade ativada, as imagens como o vJunos-router n\u00e3o funcionar\u00e3o corretamente.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#4-instalacao","title":"4. Instala\u00e7\u00e3o","text":""},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#41-configurando-a-rede-docker","title":"4.1 Configurando a Rede Docker","text":"<p>Antes de iniciar os containers, crie a rede bridge que interligar\u00e1 os dispositivos:</p> <pre><code>docker network create \\\n  --driver=bridge \\\n  --opt com.docker.network.bridge.name=br-lab \\\n  --subnet=172.10.10.0/24 \\\n  br-lab\n</code></pre>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#42-clonando-o-repositorio-do-lab","title":"4.2 Clonando o Reposit\u00f3rio do Lab","text":"<p>Execute o script abaixo para baixar e configurar o laborat\u00f3rio automaticamente:</p> Linux/MacWindows <pre><code>curl -L -o get.sh \"https://git.rnp.br/redes-abertas/labs/-/raw/main/discovery-lab/get.sh?ref_type=heads&amp;inline=false\" &amp;&amp; sh get.sh &amp;&amp; cd discovery-lab\n</code></pre> <pre><code>curl -L -o get.bat \"https://git.rnp.br/redes-abertas/labs/-/raw/main/discovery-lab/get.bat?ref_type=heads&amp;inline=false\" &amp;&amp; call get.bat &amp;&amp; cd discovery-lab\n</code></pre> <p>Dica</p> <p>No Linux/Mac, use <code>chmod +x get.sh</code> antes de executar o script, caso ele n\u00e3o esteja com permiss\u00e3o de execu\u00e7\u00e3o.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#5-implantacao-do-ambiente","title":"5. Implanta\u00e7\u00e3o do Ambiente","text":""},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#51-subindo-os-roteadores-com-containerlab","title":"5.1 Subindo os Roteadores com Containerlab","text":"<p>Inicie a topologia com o comando:</p> <pre><code>sudo clab deploy -t clab/discovery-lab.clab.yaml\n</code></pre> <p>Debug</p> <p>Os dispositivos podem levar cerca de 10 minutos para estarem totalmente operacionais. Caso ocorra algum erro, verifique a sa\u00edda do comando para poss\u00edveis mensagens de erro. Use <code>docker logs &lt;container_name&gt;</code> para depurar.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#52-levantando-o-zabbix","title":"5.2 Levantando o Zabbix","text":"<p>Dica</p> <p>Caso voc\u00ea j\u00e1 possua um ambiente Zabbix configurado, basta pular esse passo.</p> <p>Para subir o container com o Zabbix:</p> <p><pre><code>docker compose -f zabbix-docker/docker-compose.yml up -d\n</code></pre> A interface web do Zabbix ficar\u00e1 dispon\u00edvel na porta 81.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#6-integracao-com-zabbix-e-netbox","title":"6. Integra\u00e7\u00e3o com Zabbix e Netbox","text":"<p>Neste passo \u00e9 preciso que voc\u00ea crie um token de API tanto no Zabbix quanto no Netbox para adicionar o token no arquivo .env</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#61-importacao-dos-roteadores-para-o-zabbix","title":"6.1 Importa\u00e7\u00e3o dos Roteadores para o Zabbix","text":"<ol> <li>Acesse a pasta de scripts: <pre><code>cd scripts/\n</code></pre></li> <li>Crie e ative o ambiente virtual Python: <pre><code>python3 -m venv venv\nsource venv/bin/activate\n</code></pre></li> <li>Instale as depend\u00eancias do python: <pre><code>pip install -r requirements.txt\n</code></pre></li> <li>Configure o ambiente com as suas credenciais: <pre><code>mv .env.example .env\nnano .env\n</code></pre> Exemplo de .env: <pre><code> # Zabbix\nZABBIX_TOKEN=zabbix_token                     # Token de API \nZABBIX_URL=http://yourdomain/api_jsonrpc.php  # Url de acesso a API\nZABBIX_USER=Admin                             # Usu\u00e1rio Default\nZABBIX_PASSWORD=zabbix                        # Senha Default\nZABBIX_GROUP=Juniper                          # Grupo \u00e0 adicionar os roteadores\nZABBIX_TEMPLATE=\"Juniper by SNMP\"             # Template de monitoramento para roteadores Juniper\n\n# Netbox\nNETBOX_URL=http://yourdomain/api              # Url de acesso a API\nNETBOX_TOKEN=netbox_token                     # Token de API \n\n# Devices\nDEVICE_USERNAME=admin                         # Usu\u00e1rio Default de acesso aos roteadores\nDEVICE_PASSWORD=admin@123                     # Senha Default de acesso aos roteadores\n</code></pre></li> <li>Agora para importar os roteadores para o Zabbix, execute o comando: <pre><code>python3 import_zabbix.py\n</code></pre></li> </ol>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#62-gerando-tokens-de-api","title":"6.2 Gerando Tokens de API","text":"<p>Criando Token de API no Zabbix.</p> <ol> <li>Acesse a interface do Zabbix.</li> <li>V\u00e1 em Usu\u00e1rios &gt; Tokens da API.</li> <li>Clique em Criar, preencha e copie o token gerado.</li> <li>Atualize o campo <code>ZABBIX_TOKEN</code> no <code>.env</code>.</li> </ol> <p>Criando Token de API no Netbox.</p> <ol> <li>Acesse a interface do Netbox.</li> <li>Navegue at\u00e9 Admin &gt; API Tokens.</li> <li>Clique em Add, associe a um usu\u00e1rio e copie o token.</li> <li>Atualize o campo <code>NETBOX_TOKEN</code> no <code>.env</code>.</li> </ol>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#63-importacao-dos-roteadores-para-o-netbox","title":"6.3 Importa\u00e7\u00e3o dos Roteadores para o Netbox","text":"<p>Agora com o ambiente totalmente configurado, voc\u00ea pode importar os roteadores ao Netbox com o comando: <pre><code>python3 import_netbox.py\n</code></pre></p> <p>Com o script bem sucessido, voc\u00ea pode visualizar os roteadores dentro do Netbox com as suas respectivas informa\u00e7\u00f5es!</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#7-acesso","title":"7. Acesso","text":"<p>Ap\u00f3s o laborat\u00f3rio ser iniciado, voc\u00ea poder\u00e1 acessar os dispositivos e servi\u00e7os configurados na rede.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#71-tabela-de-ips-e-portas-de-servico","title":"7.1 Tabela de IPs e Portas de Servi\u00e7o","text":"<p>Aqui est\u00e1 a tabela de dispositivos, IPs e portas de servi\u00e7o dispon\u00edveis no laborat\u00f3rio.</p> Dispositivo IP de Acesso Porta Servi\u00e7o GO 172.10.10.12 22 SSH MS 172.10.10.17 22 SSH MT 172.10.10.18 22 SSH Servidor de Monitoramento 172.20.20.1 8080 Web (Graphite) Servidor Zabbix 172.10.10.115 81 Zabbix"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#72-senhas-de-acesso","title":"7.2 Senhas de Acesso","text":"<p>Aqui est\u00e1 a tabela com as senhas de acesso dos servi\u00e7os configurados no laborat\u00f3rio.</p> Servi\u00e7o Usu\u00e1rio Senha AC (SSH) admin admin@123 MS (SSH) admin admin@123 MT (SSH) admin admin@123 Graphite (Web) admin admin@123 Servidor Zabbix(Web) Admin zabbix <p>Aten\u00e7\u00e3o</p> <p>antes de acessar acesse o log de um dispositivo para verificar se ele foi iniciado e configurado corretamente.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#8-proximos-passos","title":"8. Pr\u00f3ximos Passos","text":"<p>Com o laborat\u00f3rio finalizado, voc\u00ea pode seguir algum passos abaixo como extra.</p> <ul> <li>Monitorar os roteadores via SNMP na interface do Zabbix.</li> <li>Explorar o Netbox para visualizar e gerenciar o invent\u00e1rio da rede.</li> <li>Modificar a topologia conforme a necessidade (em futuras vers\u00f5es personalizadas).</li> <li>Consultar o guia de OSPF para validar a comunica\u00e7\u00e3o din\u00e2mica entre roteadores.</li> </ul>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#9-conclusao","title":"9. Conclus\u00e3o","text":"<p>\u2705 Pronto! Seu ambiente agora est\u00e1 configurado, monitorado e documentado no Netbox. Sinta-se \u00e0 vontade para personalizar ou expandir a topologia conforme os objetivos do seu estudo ou projeto.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/","title":"Juniper Vjuniper Descoberta","text":""},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Este laborat\u00f3rio simula uma rede com 3 roteadores configurados com OSPF e SNMP, integrando os componentes do Diode (plugin, server e agent) e o Netbox para importa\u00e7\u00e3o e gerenciamento automatizado de dispositivos.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#1-descricao","title":"1. Descri\u00e7\u00e3o","text":""},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#11-objetivo-do-lab","title":"1.1 Objetivo do Lab","text":"<p>O objetivo deste laborat\u00f3rio \u00e9 demonstrar, de forma pr\u00e1tica, o processo de importa\u00e7\u00e3o automatizada de dispositivos de rede e suas respectivas configura\u00e7\u00f5es para o Netbox, utilizando o diodo-plugin, o diode-server e o orb-agent.</p> <p></p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#12-topologia-do-lab","title":"1.2 Topologia do Lab","text":"<p>Abaixo a topologia em formato imagem, representando os roteadores, servidores e suas conex\u00f5es.</p> <p></p> <p>Os roteadores est\u00e3o configurados com as seguintes tecnologias:</p> <ul> <li>OSPF (Open Shortest Path First): Utilizado para roteamento din\u00e2mico na rede, permitindo que os roteadores troquem informa\u00e7\u00f5es sobre rotas e atualiza\u00e7\u00f5es de topologia.</li> <li>SNMP (Simple Network Management Protocol): Utilizado para monitoramento e gerenciamento da rede, permitindo o acesso a informa\u00e7\u00f5es de telemetria dos dispositivos.</li> </ul>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#2-aplicacoes","title":"2. Aplica\u00e7\u00f5es","text":""},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#exemplos-de-aplicacoes","title":"Exemplos de Aplica\u00e7\u00f5es","text":"<p>Este laborat\u00f3rio \u00e9 voltado \u00e0 experimenta\u00e7\u00e3o pr\u00e1tica com descoberta e importa\u00e7\u00e3o autom\u00e1tica de dispositivos em redes IP, integrando o Diode e o Netbox.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#possiveis-aplicacoes","title":"Poss\u00edveis Aplica\u00e7\u00f5es:","text":"<ul> <li>Automa\u00e7\u00e3o da descoberta de rede: Identifica\u00e7\u00e3o autom\u00e1tica de dispositivos e registro no Netbox.</li> <li>Capacita\u00e7\u00e3o em NetDevOps e gest\u00e3o de invent\u00e1rio: Treino em integra\u00e7\u00e3o de ferramentas de documenta\u00e7\u00e3o de rede via API.</li> <li>Cria\u00e7\u00e3o de reposit\u00f3rio centralizado de dispositivos: Constru\u00e7\u00e3o de uma base confi\u00e1vel de dados da rede em tempo real.</li> <li>Estudo da integra\u00e7\u00e3o Diode + Netbox via API: Demonstra como o agente coleta, o servidor processa e o plugin registra no invent\u00e1rio.</li> <li>Ensino de descoberta SNMP e gerenciamento centralizado: Pr\u00e1tica de coleta e integra\u00e7\u00e3o de dados de rede.</li> </ul>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#3-requisitos","title":"3. Requisitos","text":""},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#31-pre-requisitos","title":"3.1 Pr\u00e9 requisitos","text":"<p>Para iniciar o laborat\u00f3rio, \u00e9 necess\u00e1rio a instala\u00e7\u00e3o e configura\u00e7\u00e3o dos seguintes componentes:</p> <ul> <li>Netbox</li> <li>Diode Plugin</li> <li>Diode Server</li> <li>Orb Agent</li> <li>Containerlab</li> <li>Docker</li> </ul> <p>Caso o seu ambiente n\u00e3o esteja configurado, siga os passos Guia de Configura\u00e7\u00e3o</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#32-tabela-de-requisitos-computacionais","title":"3.2 Tabela de Requisitos Computacionais","text":"Requisito Detalhes CPUs 4 vCPUs (m\u00ednimo recomendado) Mem\u00f3ria RAM 12 GB Espa\u00e7o em Disco 10 GB Containerlab 0.64.0 Rede Criada br-lab <p>Dica</p> <p>Verifique se a vers\u00e3o do Docker e do Containerlab s\u00e3o compat\u00edveis para evitar erros durante a implanta\u00e7\u00e3o.</p> <p>Aten\u00e7\u00e3o</p> <p>Verifique se o seu processador possui suporte \u00e0 virtualiza\u00e7\u00e3o por hardware e se essa funcionalidade est\u00e1 ativada na BIOS/UEFI. - Em processadores Intel, essa tecnologia \u00e9 chamada de VT-x (Intel Virtualization Technology). - Em processadores AMD, \u00e9 conhecida como AMD-V (AMD Virtualization).  </p> <p>Sem essa funcionalidade ativada, as imagens como o vJunos-router n\u00e3o funcionar\u00e3o corretamente.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#4-instalacao","title":"4. Instala\u00e7\u00e3o","text":""},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#41-configurando-a-rede-docker","title":"4.1 Configurando a Rede Docker","text":"<p>Antes de iniciar os containers, crie a rede bridge que interligar\u00e1 os dispositivos:</p> <pre><code>docker network create \\\n  --driver=bridge \\\n  --opt com.docker.network.bridge.name=br-lab \\\n  --subnet=172.10.10.0/24 \\\n  br-lab\n</code></pre>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#42-clonando-o-repositorio-do-lab","title":"4.2 Clonando o Reposit\u00f3rio do Lab","text":"<p>Execute o script abaixo para baixar e configurar o laborat\u00f3rio automaticamente:</p> Linux/MacWindows <pre><code>curl -L -o get.sh \"https://git.rnp.br/redes-abertas/labs/-/raw/main/discovery-lab-diode/get.sh?ref_type=heads&amp;inline=false\" &amp;&amp; sh get.sh &amp;&amp; cd discovery-lab\n</code></pre> <pre><code>curl -L -o get.bat \"https://git.rnp.br/redes-abertas/labs/-/raw/main/discovery-lab-diode/get.bat?ref_type=heads&amp;inline=false\" &amp;&amp; call get.bat &amp;&amp; cd discovery-lab\n</code></pre> <p>Dica</p> <p>No Linux/Mac, use <code>chmod +x get.sh</code> antes de executar o script, caso ele n\u00e3o esteja com permiss\u00e3o de execu\u00e7\u00e3o.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#5-implantacao-do-ambiente","title":"5. Implanta\u00e7\u00e3o do Ambiente","text":""},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#51-subindo-os-roteadores-com-containerlab","title":"5.1 Subindo os Roteadores com Containerlab","text":"<p>Inicie a topologia com o comando:</p> <pre><code>sudo clab deploy -t clab/discovery-lab.clab.yaml\n</code></pre> <p>Debug</p> <p>Os dispositivos podem levar cerca de 10 minutos para estarem totalmente operacionais. Caso ocorra algum erro, verifique a sa\u00edda do comando para poss\u00edveis mensagens de erro. Use <code>docker logs &lt;container_name&gt;</code> para depurar.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#52-levantando-o-diode-server","title":"5.2 Levantando o Diode Server","text":"<p>Dica</p> <p>Caso voc\u00ea j\u00e1 possua o servidor do Diode configurado, basta pular esse passo.</p> <ol> <li> <p>Vamos criar uma nova pasta para armazenar os arquivos do diode-server: <pre><code>mkdir diode-server\ncd diode-server\n</code></pre></p> </li> <li> <p>Agora, vamos realizar o download do script de in\u00edcio r\u00e1pido: <pre><code>curl -sSfLo quickstart.sh https://raw.githubusercontent.com/netboxlabs/diode/release/diode-server/docker/scripts/quickstart.sh\nchmod +x quickstart.sh\n</code></pre></p> </li> <li> <p>Ent\u00e3o, basta executar o script passando a url do seu netbox: <pre><code>./quickstart.sh https://&lt;netbox-server&gt;\n</code></pre></p> </li> <li> <p>Por fim, basta iniciar os containers: <pre><code>docker compose up -d\n</code></pre></p> </li> <li> <p>Para extrair as credenciais necess\u00e1rias na instala\u00e7\u00e3o do plugin, execute o comando abaixo: <pre><code>echo $(jq -r '.[] | select(.client_id == \"netbox-to-diode\") | .client_secret' ./oauth2/client/client-credentials.json)\n</code></pre></p> </li> </ol> <p>Dica</p> <p>Armazene o token, voc\u00ea vai precisar adicion\u00e1-lo na configura\u00e7\u00e3o a seguir.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#53-instalando-o-plugin-no-netbox","title":"5.3 Instalando o Plugin no Netbox","text":"<p>Neste passo, vamos instalar o plugin do diode, respons\u00e1vel por estabelecer a conex\u00e3o entre o diode-server e o Netbox.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#531-configurando-a-versao-do-netbox","title":"5.3.1 Configurando a vers\u00e3o do Netbox:","text":"<ol> <li>Primeiro, vamos clonar o reposit\u00f3rio do Netbox Docker: <pre><code>git clone -b release https://github.com/netbox-community/netbox-docker.git\n</code></pre></li> <li>Agora, vamos para a Release 3.2.1: <pre><code>cd netbox-docker/\ngit checkout 3.2.1\n</code></pre></li> </ol> <p>Informa\u00e7\u00e3o</p> <p>Alteramos a branch do reposit\u00f3rio para termos acesso \u00e0 vers\u00e3o 4.2.4 do Netbox.</p> <p>Dica</p> <p>Todos os comandos abaixos ser\u00e3o executados dentro diret\u00f3rio raiz do netbox <code>netbox-docker/</code>.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#532-plugin_requirementstxt","title":"5.3.2 plugin_requirements.txt","text":"<p>Este arquivo cont\u00e9m ama lista dos plugins do Netbox (como pacotes Python do PyPO) que devem ser instalados durante a constru\u00e7\u00e3o da imagem Docker.</p> <p>Execute o seguinte comando para escrever o pacote dentro do arquivo <code>plugin_requirements.txt</code>.</p> <pre><code>echo \"netboxlabs-diode-netbox-plugin\" &gt;&gt; plugin_requirements.txt\n</code></pre>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#533-dockerfile-plugins","title":"5.3.3 DockerFile-Plugins","text":"<p>Esse \u00e9 o DockerFile usado para construir a imagem docker customizada.</p> <ol> <li> <p>Crie o arquivo e acesse com um editor:  <pre><code>nano DockerFile-Plugins\n</code></pre></p> </li> <li> <p>Copie o conte\u00fado abaixo e cole no arquivo: <pre><code>FROM netboxcommunity/netbox:v4.2.4\n\nCOPY ./plugin_requirements.txt /opt/netbox/\nRUN /usr/local/bin/uv pip install -r /opt/netbox/plugin_requirements.txt\n</code></pre></p> </li> </ol>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#534-docker-composeoverrideyml","title":"5.3.4. docker-compose.override.yml","text":"<p>Como o nome implica, esse arquivo contaim as configura\u00e7\u00f5es que v\u00e3o sobrescrever o <code>docker-compose.yml</code>.</p> <p>Caso voc\u00ea ainda n\u00e3o tenha configurado a rede <code>br-lab</code>. Acesse: Configurando a Rede Docker</p> <ol> <li> <p>Crie o arquivo e acesse com um editor: <pre><code>nano docker-compose.override.yml\n</code></pre></p> </li> <li> <p>Copie o conte\u00fado abaixo e cole no arquivo: <pre><code>services:\n  netbox:\n    image: netbox:latest-plugins\n    pull_policy: never\n    ports:\n      - 8000:8080\n    build:\n      context: .\n      dockerfile: Dockerfile-Plugins\n    networks:\n      - br-lab\n\n  netbox-worker:\n    image: netbox:latest-plugins\n    pull_policy: never\n    networks:\n      - br-lab\n\n  netbox-housekeeping:\n    image: netbox:latest-plugins\n    pull_policy: never\n    networks:\n      - br-lab\n\n  postgres:\n    networks:\n      - br-lab\n\n  redis:\n    networks:\n      - br-lab\n\n  redis-cache:\n    networks:\n      - br-lab\n\nnetworks:\n  br-lab:\n    external: true\n</code></pre></p> </li> </ol> <p>As altera\u00e7\u00f5es feitas foram: </p> <ul> <li>adicionar o Netbox na rede <code>br-lab</code>.</li> <li>altera\u00e7\u00e3o do dockerfile para o <code>Dockerfile-Plugins</code>, criado anteriormente.</li> <li>Tamb\u00e9m alterado a imagem dos servi\u00e7os para: <code>netbox:latest-plugins</code>.</li> </ul>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#535-pluginspy","title":"5.3.5. plugins.py","text":"<p>Este arquivo \u00e9 respons\u00e1vel por setar as configura\u00e7\u00f5es espec\u00edficas de cada plugin.</p> <ol> <li> <p>Acesse o arquivo com o editor: <pre><code>nano configuration/plugins.py\n</code></pre></p> </li> <li> <p>Copie e cole o conte\u00fado no arquivo: <pre><code>PLUGINS = [\n    \"netbox_diode_plugin\",\n]\n\nPLUGINS_CONFIG = {\n    \"netbox_diode_plugin\": {\n        # Diode gRPC target for communication with Diode server\n        \"diode_target_override\": \"grpc://localhost:8080/diode\",\n\n        # Username associated with changes applied via plugin\n        \"diode_username\": \"diode\",\n\n        # netbox-to-diode client_secret created during diode bootstrap.\n        \"netbox_to_diode_client_secret\": \"...\"\n    },\n}\n</code></pre></p> </li> </ol> <p>Dica</p> <p>O token armazenado na instala\u00e7\u00e3o do diode-server deve ser passado na op\u00e7\u00e3o: <code>netbox_to_diode_client_secret</code>.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#536-build-e-deploy","title":"5.3.6 Build e Deploy!","text":"<p>Agora seu Netbox est\u00e1 configurado e pronto para o deploy, siga os comandos abaixo e construa a nova instancia do Netbox!</p> <ol> <li> <p>Construa a imagem: <pre><code>docker compose build --no-cache\n</code></pre></p> </li> <li> <p>Suba os containeres: <pre><code>docker compose up -d\n</code></pre></p> </li> <li> <p>Crie as migra\u00e7\u00f5es necess\u00e1rias com o comando abaixo: <pre><code>docker compose exec -it netbox ./manage.py migrate netbox_diode_plugin\n</code></pre></p> </li> </ol>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#537-gerando-as-credenciais-para-o-agente","title":"5.3.7. Gerando as credenciais para o agente","text":"<p>Precisamos criar as credenciais para que o agente do diode se comunique e repasse os dados coletados dos dispositivos para o diode-server </p> <ol> <li>Acesse seu Netbox e v\u00e1 no menu lateral.</li> <li>V\u00e1 em <code>Diode</code> &gt; <code>Client Credentials</code>.</li> <li>Clique no bot\u00e3o superior <code>Adicionar Credencial</code>.</li> <li>Digite um nome para sua credencial.</li> <li>Armazene o <code>Client Id</code> e o <code>Client Secret</code>.</li> </ol>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#6-orb-agent","title":"6. Orb-Agent","text":"<p>O orb-agent \u00e9 um component do diode respons\u00e1vel por realizar a coleta dos dados nos dispositivos.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#61-configurando-o-agente","title":"6.1 Configurando o agente","text":"<ol> <li> <p>Acesse a pasta do <code>orb-agent</code>: <pre><code>cd ./orb-agent\n</code></pre></p> </li> <li> <p>No arquivo <code>.env</code>, configure as vari\u00e1veis de acordo com o seu ambiente. <pre><code>DOCKER_NETWORK=br-lab           # Container Network\nDOCKER_SUBNET=172.10.10.0/24    # Devices Network\nDIODE_CLIENT_ID=                # Diode Client Id\nDIODE_CLIENT_SECRET=            # Diode Client Secret\nDIODE_HOST=&lt;your-ip&gt;:8080       # Diode Server Url\nAGENT_NAME=agent1               # Agent Name\nSITE_NAME=RNP                   # Netbox Site Name \nDEVICE_USERNAME=admin           # Device username \nJUNIPER_PASSWORD=admin@123      # Device Password\nJUNIPER_COMMUNITY=\"public\"      # Device Community\n</code></pre></p> </li> </ol> <p>Aqui fica o <code>Client Id</code> e o <code>Client Secret</code> gerados no plugin do diode no Netbox.</p> <ol> <li>Agora, vamos aplicar as vari\u00e1veis no template de importa\u00e7\u00e3o do juniper com o comando: <pre><code>set -o allexport &amp;&amp; source .env &amp;&amp; envsubst &lt; ./juniper/agent.device.template.yaml &gt; agent.yaml\n</code></pre></li> </ol>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#62-iniciando-a-coleta-dos-dados","title":"6.2 Iniciando a coleta dos dados","text":"<p>Por fim, basta subir o container para iniciar a importa\u00e7\u00e3o dos dispositivos para o Netbox!</p> <pre><code>docker compose up\n</code></pre> <p>\u2705 Acompanhe em tempo real no Netbox os dispositivos sendo coletados pelo agente.</p> <p>\u23f1\ufe0f Al\u00e9m disso, voc\u00ea pode configurar um intervalo de coleta para que o agente realize a importa\u00e7\u00e3o de forma autom\u00e1tica e peri\u00f3dica, sem necessidade de interven\u00e7\u00e3o manual.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#7-acesso","title":"7. Acesso","text":"<p>Ap\u00f3s o laborat\u00f3rio ser iniciado, voc\u00ea poder\u00e1 acessar os dispositivos e servi\u00e7os configurados na rede.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#71-tabela-de-ips-e-portas-de-servico","title":"7.1 Tabela de IPs e Portas de Servi\u00e7o","text":"<p>Aqui est\u00e1 a tabela de dispositivos, IPs e portas de servi\u00e7o dispon\u00edveis no laborat\u00f3rio.</p> Dispositivo IP de Acesso Porta Servi\u00e7o GO 172.10.10.12 22 SSH MS 172.10.10.17 22 SSH MT 172.10.10.18 22 SSH Servidor de Monitoramento 172.20.20.1 8081 Web (Graphite) Netbox localhost 8000 Zabbix"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#72-senhas-de-acesso","title":"7.2 Senhas de Acesso","text":"<p>Aqui est\u00e1 a tabela com as senhas de acesso dos servi\u00e7os configurados no laborat\u00f3rio.</p> Servi\u00e7o Usu\u00e1rio Senha AC (SSH) admin admin@123 MS (SSH) admin admin@123 MT (SSH) admin admin@123 Graphite (Web) admin admin@123 Netbox (Web) Admin Admin <p>Aten\u00e7\u00e3o</p> <p>antes de acessar acesse o log de um dispositivo para verificar se ele foi iniciado e configurado corretamente.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#8-proximos-passos","title":"8. Pr\u00f3ximos Passos","text":"<p>Com o laborat\u00f3rio finalizado, voc\u00ea pode seguir algum passos abaixo como extra.</p> <ul> <li>Explorar outros tipos de importa\u00e7\u00e3o, como Network e SNMP discovery.</li> <li>Explorar o Netbox para visualizar e gerenciar o invent\u00e1rio da rede.</li> <li>Modificar a topologia conforme a necessidade (em futuras vers\u00f5es personalizadas).</li> <li>Consultar as configura\u00e7\u00f5es importadas pelo agente.</li> </ul>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#9-conclusao","title":"9. Conclus\u00e3o","text":"<p>\u2705 Pronto! Agora voc\u00ea j\u00e1 sabe como utilizar os componentes do Diode para importar a sua pr\u00f3pria rede para o Netbox, assim voc\u00ea consegue tamb\u00e9m, atrav\u00e9s do Netreplica, gerar seu pr\u00f3prio Digital Twin!.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/","title":"Juniper Vjunos Monitoramento ELK","text":"<p>Este laborat\u00f3rio simula, via Containerlab, a interliga\u00e7\u00e3o entre tr\u00eas roteadores representando a conex\u00e3o GO\u2013MS\u2013MT no backbone da RNP, com roteamento din\u00e2mico via OSPF, exporta\u00e7\u00e3o de fluxos via IPFIX e an\u00e1lise/visualiza\u00e7\u00e3o via Elastic Stack (Elasticsearch, Kibana, Fleet Server e Elastic Agent).</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#1-descricao","title":"1. Descri\u00e7\u00e3o","text":""},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#11-objetivo-do-lab","title":"1.1 Objetivo do Lab","text":"<p>O laborat\u00f3rio <code>elk-lab</code> tem como principal objetivo simular o envio e an\u00e1lise de fluxos de tr\u00e1fego IPFIX em uma topologia de tr\u00eas roteadores interligados (GO, MS e MT), utilizando OSPF para roteamento din\u00e2mico e ferramentas do Elastic Stack para observabilidade e an\u00e1lise de tr\u00e1fego em tempo real.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#12-topologia-do-lab","title":"1.2 Topologia do Lab","text":"<p>Descri\u00e7\u00e3o da Topologia</p> <ul> <li>Tr\u00eas roteadores (GO, MS, MT) interligados em topologia linear com links ponto a ponto /31.</li> <li>Roteamento din\u00e2mico via OSPF.</li> <li>Exporta\u00e7\u00e3o de fluxos IPFIX para o Fleet Server.</li> <li>Elastic Agent instalado para recebimento dos fluxos e envio ao Elasticsearch.</li> <li>Visualiza\u00e7\u00e3o de dados e an\u00e1lise via Kibana.</li> <li>Rede externa <code>br-lab</code> conecta os elementos de rede \u00e0 pilha ELK.</li> </ul>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#2-aplicacoes","title":"2. Aplica\u00e7\u00f5es","text":""},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#exemplos-de-aplicacoes","title":"Exemplos de Aplica\u00e7\u00f5es","text":"<p>O <code>elk-lab</code> pode ser aplicado a diferentes contextos educacionais e de pesquisa, permitindo a simula\u00e7\u00e3o de cen\u00e1rios reais de exporta\u00e7\u00e3o de tr\u00e1fego e an\u00e1lise com Elastic Stack.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#possiveis-aplicacoes","title":"Poss\u00edveis Aplica\u00e7\u00f5es:","text":"<ul> <li>Ensino de IPFIX em ambientes reais: Aplica\u00e7\u00e3o pr\u00e1tica da exporta\u00e7\u00e3o de fluxos para ferramentas de an\u00e1lise.</li> <li>Capacita\u00e7\u00e3o em Elastic Stack para redes: Demonstra a integra\u00e7\u00e3o do IPFIX com Elastic Agent e o uso de dashboards no Kibana.</li> <li>An\u00e1lise forense e de tr\u00e1fego de rede: Suporte a estudos sobre padr\u00f5es de tr\u00e1fego, anomalias e amea\u00e7as.</li> <li>Integra\u00e7\u00e3o com SIEMs baseados em Elasticsearch: Avalia\u00e7\u00e3o de pipelines de dados para uso com seguran\u00e7a de redes.</li> <li>Visualiza\u00e7\u00e3o de fluxos de tr\u00e1fego: Composi\u00e7\u00e3o de dashboards din\u00e2micos em tempo real.</li> </ul>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#3-requisitos","title":"3. Requisitos","text":"<p>Abaixo est\u00e3o listados os requisitos m\u00ednimos de hardware e software necess\u00e1rios para executar o laborat\u00f3rio. Certifique-se de incluir as ferramentas essenciais, como Containerlab e Docker, al\u00e9m da rede <code>br-lab</code> previamente criada. para saber mais sobre este itens acesse:</p> <ul> <li>Cria\u00e7\u00e3o da Rede br-lab</li> <li>Instala\u00e7\u00e3o do Docker</li> <li>Instala\u00e7\u00e3o do containerlab</li> </ul> <p>E tenha a stack ELK previamente instalado, para saber mais sobre a instala\u00e7\u00e3o do zabbix acesse: Instala\u00e7\u00e3o do ELK</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#tabela-de-requisitos-minimos","title":"Tabela de Requisitos Minimos:","text":"Requisito Detalhes CPUs 6 vCPUs Mem\u00f3ria RAM 24 GB Espa\u00e7o em Disco 30 GB (recomendado) Containerlab 0.45.0 ou superior Docker Engine 23.0.3 ou superior Imagens <code>vr-vjunos:23.2R1.14</code> Rede Docker <code>br-lab</code> <p>Aten\u00e7\u00e3o</p> <p>Verifique se o seu processador possui suporte \u00e0 virtualiza\u00e7\u00e3o por hardware e se essa funcionalidade est\u00e1 ativada na BIOS/UEFI. - Em processadores Intel, essa tecnologia \u00e9 chamada de VT-x (Intel Virtualization Technology). - Em processadores AMD, \u00e9 conhecida como AMD-V (AMD Virtualization).  </p> <p>Sem essa funcionalidade ativada, as imagens como o vJunos-router n\u00e3o funcionar\u00e3o corretamente.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#4-implantacao-do-lab","title":"4. Implanta\u00e7\u00e3o do Lab","text":"<p>Este m\u00e9todo permite ao usu\u00e1rio baixar uma vers\u00e3o pr\u00e9-montada do laborat\u00f3rio, com a topologia e as configura\u00e7\u00f5es j\u00e1 definidas. Basta baixar o reposit\u00f3rio e seguir para o in\u00edcio da execu\u00e7\u00e3o.</p> <p>Dica</p> <p>A implanta\u00e7\u00e3o pronta \u00e9 \u00fatil para quem deseja come\u00e7ar rapidamente com um ambiente configurado.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#baixando-o-lab","title":"Baixando o Lab","text":"<p>Execute o script abaixo para baixar os arquivos do laborat\u00f3rio:</p> Linux/MacWindows <pre><code>curl -L -o get.sh \"https://git.rnp.br/redes-abertas/labs/-/raw/main/elk-lab/get.sh?ref_type=heads&amp;inline=false\" &amp;&amp; sh get.sh &amp;&amp; cd elk-lab\n</code></pre> <pre><code>curl -L -o get.bat \"https://git.rnp.br/redes-abertas/labs/-/raw/main/elk-lab/get.bat?ref_type=heads&amp;inline=false\" &amp;&amp; call get.bat &amp;&amp; cd elk-lab\n</code></pre>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#5-iniciando-o-lab","title":"5. Iniciando o Lab","text":"<p>Ap\u00f3s o download ou personaliza\u00e7\u00e3o, siga as etapas abaixo para iniciar o laborat\u00f3rio. Execute o comando abaixo dentro do diret\u00f3rio baixado.</p> <pre><code>sudo containerlab deploy\n</code></pre> <p>Esse comando iniciar\u00e1 a topologia definida no laborat\u00f3rio e criar\u00e1 todos os containers necess\u00e1rios.</p> <p>Depura\u00e7\u00e3o</p> <p>Use <code>docker logs -f &lt;nome_container&gt;</code> para verificar o estado dos servi\u00e7os, caso algo n\u00e3o funcione.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#6-acesso-aos-dispositivos","title":"6. Acesso aos Dispositivos","text":""},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#61-ips-e-portas","title":"6.1 IPs e Portas","text":"Dispositivo IP de Acesso Porta(s) Servi\u00e7o Roteador GO 172.10.10.6 22 SSH Roteador MS 172.10.10.7 22 SSH Roteador MT 172.10.10.8 22 SSH Fleet Server 172.10.10.110 8220 Ingest\u00e3o de dados Elasticsearch 172.10.10.108 9200 Banco de dados Kibana 172.10.10.109 5601 Interface Web"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#62-credenciais-de-acesso","title":"6.2 Credenciais de Acesso","text":"Servi\u00e7o Usu\u00e1rio Senha SSH Roteadores <code>admin</code> <code>admin@123</code> Kibana <code>elastic</code> <code>admin@123</code>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#7-coleta-e-exportacao-de-fluxos","title":"7. Coleta e Exporta\u00e7\u00e3o de Fluxos","text":"<p>Para configurar a coleta de dados utilizando o IPFIX, com nosso guia de configura\u00e7\u00e3o de IPFIX.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/","title":"Juniper Vjunos Monitoramento Telegraf","text":"<p>Este laborat\u00f3rio simula, via Containerlab, a interliga\u00e7\u00e3o entre tr\u00eas roteadores representando a conex\u00e3o GO\u2013MS\u2013MT no backbone da RNP, com roteamento din\u00e2mico via OSPF, exporta\u00e7\u00e3o de fluxos via IPFIX e monitoramento via SNMP/Telemetria usando Telegraf, InfluxDB, Chronograf e Grafana.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#1-descricao","title":"1. Descri\u00e7\u00e3o","text":""},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#11-objetivo-do-lab","title":"1.1 Objetivo do Lab","text":"<p>O laborat\u00f3rio <code>telegraf-lab</code> tem como principal objetivo simular o monitoramento de tr\u00e1fego de uma topologia com tr\u00eas roteadores interligados (GO, MS e MT), utilizando protocolos de roteamento din\u00e2mico (OSPF), exporta\u00e7\u00e3o de fluxos (IPFIX) e monitoramento com SNMP. A coleta e visualiza\u00e7\u00e3o de m\u00e9tricas de rede s\u00e3o realizadas com ferramentas modernas de observabilidade: Telegraf, InfluxDB, Chronograf e Grafana.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#12-topologia-do-lab","title":"1.2 Topologia do Lab","text":"<p>Descri\u00e7\u00e3o da Topologia</p> <ul> <li>Tr\u00eas roteadores (GO, MS, MT) interligados em topologia linear com links ponto a ponto /31.</li> <li>Roteamento din\u00e2mico via OSPF entre os roteadores.</li> <li>Coleta de m\u00e9tricas de tr\u00e1fego via IPFIX e SNMP.</li> <li>Observabilidade com a pilha TICK (Telegraf, InfluxDB, Chronograf) e Grafana.</li> <li>Rede externa <code>br-lab</code> conecta os n\u00f3s \u00e0 infraestrutura de monitoramento.</li> </ul>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#2-aplicacoes","title":"2. Aplica\u00e7\u00f5es","text":""},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#exemplos-de-aplicacoes","title":"Exemplos de Aplica\u00e7\u00f5es","text":"<p>Este laborat\u00f3rio pode ser explorado em diversos cen\u00e1rios acad\u00eamicos e de pesquisa aplicada, servindo como base para experimenta\u00e7\u00e3o de monitoramento e visualiza\u00e7\u00e3o de tr\u00e1fego em redes com m\u00faltiplos roteadores.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#possiveis-aplicacoes","title":"Poss\u00edveis Aplica\u00e7\u00f5es:","text":"<ul> <li>Capacita\u00e7\u00e3o de equipes de redes e NOC: Simula opera\u00e7\u00f5es reais com OSPF, IPFIX e SNMP, facilitando a an\u00e1lise de comportamento de tr\u00e1fego.</li> <li>An\u00e1lise de tr\u00e1fego com IPFIX: Permite exportar fluxos e estudar padr\u00f5es de tr\u00e1fego entre dom\u00ednios.</li> <li>Visualiza\u00e7\u00e3o de m\u00e9tricas com Grafana: Apoia estudos de desempenho, gargalos e picos de utiliza\u00e7\u00e3o de rede.</li> <li>Monitoramento distribu\u00eddo com Telegraf: Avalia a coleta simult\u00e2nea de dados de m\u00faltiplos roteadores com diferentes protocolos.</li> <li>Ensino de protocolos de roteamento e telemetria: Ambiente ideal para aulas pr\u00e1ticas de redes avan\u00e7adas.</li> </ul>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#3-requisitos","title":"3. Requisitos","text":"<p>Abaixo est\u00e3o listados os requisitos m\u00ednimos de hardware e software necess\u00e1rios para executar o laborat\u00f3rio. Certifique-se de incluir as ferramentas essenciais, como Containerlab e Docker, al\u00e9m da rede <code>br-lab</code> previamente criada. para saber mais sobre este itens acesse:</p> <ul> <li>Cria\u00e7\u00e3o da Rede br-lab</li> <li>Instala\u00e7\u00e3o do Docker</li> <li>Instala\u00e7\u00e3o do containerlab</li> </ul> <p>E tenha a stack telegraf previamente instalado, para saber mais sobre a instala\u00e7\u00e3o do zabbix acesse: Instala\u00e7\u00e3o do Telegraf</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#tabela-de-requisitos-minimos","title":"Tabela de Requisitos Minimos:","text":"Requisito Detalhes CPUs 6 vCPUs Mem\u00f3ria RAM 12 GB Espa\u00e7o em Disco 10 GB (recomendado) Containerlab 0.45.0 ou superior Docker Engine 23.0.3 ou superior Imagens <code>vr-vjunos:23.2R1.14</code> Rede Docker <code>br-lab</code> <p>Aten\u00e7\u00e3o</p> <p>Verifique se o seu processador possui suporte \u00e0 virtualiza\u00e7\u00e3o por hardware e se essa funcionalidade est\u00e1 ativada na BIOS/UEFI. - Em processadores Intel, essa tecnologia \u00e9 chamada de VT-x (Intel Virtualization Technology). - Em processadores AMD, \u00e9 conhecida como AMD-V (AMD Virtualization).  </p> <p>Sem essa funcionalidade ativada, as imagens como o vJunos-router n\u00e3o funcionar\u00e3o corretamente.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#4-implantando-o-lab","title":"4. Implantando o Lab","text":"<p>Voc\u00ea pode realizar a implanta\u00e7\u00e3o por meio de um script pronto ou configurar manualmente os arquivos do lab.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#41-implantacao-pronta","title":"4.1 Implanta\u00e7\u00e3o Pronta","text":"<p>Este m\u00e9todo permite ao usu\u00e1rio baixar uma vers\u00e3o pr\u00e9-montada do laborat\u00f3rio, com a topologia e as configura\u00e7\u00f5es j\u00e1 definidas. Basta baixar o reposit\u00f3rio e seguir para o in\u00edcio da execu\u00e7\u00e3o.</p> <p>Dica</p> <p>A implanta\u00e7\u00e3o pronta \u00e9 \u00fatil para quem deseja come\u00e7ar rapidamente com um ambiente configurado.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#baixando-o-lab","title":"Baixando o Lab","text":"<p>Execute o script abaixo para baixar e configurar o laborat\u00f3rio automaticamente:</p> Linux/MacWindows <pre><code>curl -L -o get.sh \"https://git.rnp.br/redes-abertas/labs/-/raw/main/telegraf-lab/get.sh?ref_type=heads&amp;inline=false\" &amp;&amp; sh get.sh &amp;&amp; cd telegraf-lab\n</code></pre> <pre><code>curl -L -o get.bat \"https://git.rnp.br/redes-abertas/labs/-/raw/main/telegraf-lab/get.bat?ref_type=heads&amp;inline=false\" &amp;&amp; call get.bat &amp;&amp; cd telegraf-lab\n</code></pre> <p>Dica</p> <p>No Linux/Mac, use <code>chmod +x get.sh</code> antes de executar o script, caso ele n\u00e3o esteja com permiss\u00e3o de execu\u00e7\u00e3o.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#5-inicializando-o-lab","title":"5. Inicializando o Lab","text":"<p>Ap\u00f3s o download ou personaliza\u00e7\u00e3o, siga as etapas abaixo para iniciar o laborat\u00f3rio. Execute o comando abaixo dentro do diret\u00f3rio baixado.</p> <pre><code>sudo containerlab deploy\n</code></pre> <p>Esse comando criar\u00e1 os containers dos roteadores, configurar\u00e1 os links e iniciar\u00e1 os servi\u00e7os de monitoramento.</p> <p>Depura\u00e7\u00e3o</p> <p>Use <code>docker logs -f &lt;nome_container&gt;</code> para verificar o estado dos servi\u00e7os, caso algo n\u00e3o funcione.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#6-acesso-aos-dispositivos","title":"6. Acesso aos Dispositivos","text":""},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#61-ips-e-portas-dos-servicos","title":"6.1 IPs e Portas dos Servi\u00e7os","text":"Dispositivo IP de Acesso Porta(s) Servi\u00e7o Roteador GO 172.10.10.6 22 SSH Roteador MS 172.10.10.7 22 SSH Roteador MT 172.10.10.8 22 SSH Telegraf 172.10.10.114 161 Coleta de m\u00e9tricas InfluxDB 172.10.10.112 8086 Banco de s\u00e9ries Chronograf 172.10.10.113 8888 UI de an\u00e1lise Grafana 172.10.10.111 3000 Dashboard Web Graphite 172.10.10.119 8080 Web UI (Graphite) ###  6.2 Senhas de Acesso Servi\u00e7o Usu\u00e1rio Senha Roteadores (SSH) <code>admin</code> <code>admin@123</code> Grafana <code>admin</code> <code>admin</code> InfluxDB <code>admin</code> <code>influxpassword</code> <p>Verifica\u00e7\u00e3o de Inicializa\u00e7\u00e3o</p> <p>Antes de acessar os servi\u00e7os, use <code>docker ps</code> e verifique os logs dos containers para garantir que est\u00e3o funcionando corretamente.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#7-observabilidade-e-visualizacao","title":"7. Observabilidade e Visualiza\u00e7\u00e3o","text":""},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#71-telegraf","title":"7.1 Telegraf","text":"<p>O Telegraf est\u00e1 configurado para coletar m\u00e9tricas via:</p> <ul> <li>SNMP: leitura peri\u00f3dica dos roteadores.</li> <li>IPFIX: exporta\u00e7\u00e3o de fluxos de tr\u00e1fego.</li> <li>Docker e sistema: coleta de m\u00e9tricas locais dos containers.</li> </ul>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#72-influxdb","title":"7.2 InfluxDB","text":"<p>Banco de s\u00e9ries temporais onde as m\u00e9tricas do Telegraf s\u00e3o armazenadas. Pode ser acessado pela porta 8086.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#73-chronograf","title":"7.3 Chronograf","text":"<p>Interface web de an\u00e1lise de m\u00e9tricas armazenadas no InfluxDB. Acess\u00edvel em <code>http://172.10.10.113:8888</code>.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#74-grafana","title":"7.4 Grafana","text":"<p>Plataforma de visualiza\u00e7\u00e3o interativa onde os dados s\u00e3o apresentados em dashboards personalizados.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/","title":"Juniper Vjunos Monitoramento Zabbix","text":"<p>Este laborat\u00f3rio simula, via Containerlab, a interliga\u00e7\u00e3o entre dois roteadores representando a conex\u00e3o BA\u2013ES na RNP, com monitoramento via Zabbix e SNMPv2.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#1-descricao","title":"1. Descri\u00e7\u00e3o","text":""},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#11-objetivo-do-lab","title":"1.1 Objetivo do Lab","text":"<p>O laborat\u00f3rio \u201czabbix-rnp-lab\u201d demonstra a simula\u00e7\u00e3o da conex\u00e3o entre dois roteadores representando a interliga\u00e7\u00e3o entre BA e ES no backbone da RNP, utilizando o Containerlab. O roteamento entre os dispositivos \u00e9 realizado por meio do protocolo OSPF, garantindo a troca din\u00e2mica de rotas. O foco principal \u00e9 integrar essa topologia ao Zabbix via SNMPv2, possibilitando o monitoramento em tempo real. Al\u00e9m disso, o laborat\u00f3rio destaca a funcionalidade de descoberta autom\u00e1tica de dispositivos na rede.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#12-topologia-do-lab","title":"1.2 Topologia do Lab","text":"<p>A topologia deste laborat\u00f3rio \u00e9 composta por dois roteadores interligados por uma rede ponto a ponto /31, permitindo a comunica\u00e7\u00e3o direta entre eles. Os roteadores est\u00e3o configurados com OSPF para garantir o roteamento din\u00e2mico entre as interfaces. O monitoramento da rede \u00e9 feito por meio de uma rede externa chamada br-lab, onde os roteadores est\u00e3o conectados por interfaces virtuais. Atrav\u00e9s dessa configura\u00e7\u00e3o, o Zabbix \u00e9 capaz de monitorar a conectividade e o desempenho da rede, </p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#2-aplicacoes","title":"2. Aplica\u00e7\u00f5es","text":""},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#exemplo-de-aplicacao","title":"Exemplo de Aplica\u00e7\u00e3o","text":"<p>Este laborat\u00f3rio pode ser utilizado em diversos contextos acad\u00eamicos e profissionais. Ele \u00e9 \u00fatil para simular cen\u00e1rios reais de opera\u00e7\u00e3o e monitoramento de redes, servindo como ambiente de valida\u00e7\u00e3o de configura\u00e7\u00f5es e testes de interoperabilidade entre protocolos de roteamento e ferramentas de monitoramento.</p> <p>Poss\u00edveis Aplica\u00e7\u00f5es:</p> <ul> <li>Treinamento de equipes de NOC (Network Operations Center): Reproduz situa\u00e7\u00f5es reais de conectividade entre roteadores com OSPF e monitoramento via SNMP para familiarizar t\u00e9cnicos com detec\u00e7\u00e3o e an\u00e1lise de falhas.</li> <li>Avalia\u00e7\u00e3o de desempenho da descoberta autom\u00e1tica via SNMP: Permite testar o funcionamento da descoberta de hosts em diferentes condi\u00e7\u00f5es de rede e topologia.</li> <li>Valida\u00e7\u00e3o de templates SNMP no Zabbix: Pode ser usado para validar ou desenvolver templates de monitoramento SNMP para roteadores em ambientes controlados.</li> <li>Ensino de protocolos de roteamento din\u00e2mico: Proporciona um ambiente de aprendizado pr\u00e1tico sobre configura\u00e7\u00e3o e troca de rotas via OSPF em redes ponto a ponto.</li> </ul>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#3-requisitos","title":"3. Requisitos","text":"<p>Abaixo est\u00e3o listados os requisitos m\u00ednimos de hardware e software necess\u00e1rios para executar o laborat\u00f3rio. Certifique-se de incluir as ferramentas essenciais, como Containerlab e Docker, al\u00e9m da rede <code>br-lab</code> previamente criada. para saber mais sobre este itens acesse:</p> <ul> <li>Cria\u00e7\u00e3o da Rede br-lab</li> <li>Instala\u00e7\u00e3o do Docker</li> <li>Instala\u00e7\u00e3o do containerlab</li> <li>E tenha o zabbix previamente instalado, para saber mais sobre a instala\u00e7\u00e3o do zabbix acesse: Instala\u00e7\u00e3o do Zabbix</li> </ul>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#tabela-de-requisitos-minimos","title":"Tabela de Requisitos Minimos:","text":"Requisito Detalhes CPUs 4 vCPUs Mem\u00f3ria RAM 8 GB Espa\u00e7o em Disco 10 GB (recomendado) Containerlab 0.45.0 Docker Engine 23.0.3 Imagens <code>vr-vjunos:23.2R1.14</code> Rede Criada <code>br-lab</code> <p>Aten\u00e7\u00e3o</p> <p>Verifique se o seu processador possui suporte \u00e0 virtualiza\u00e7\u00e3o por hardware e se essa funcionalidade est\u00e1 ativada na BIOS/UEFI. - Em processadores Intel, essa tecnologia \u00e9 chamada de VT-x (Intel Virtualization Technology). - Em processadores AMD, \u00e9 conhecida como AMD-V (AMD Virtualization).  </p> <p>Sem essa funcionalidade ativada, as imagens como o vJunos-router n\u00e3o funcionar\u00e3o corretamente.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#4-implantando-o-lab","title":"4. Implantando o Lab","text":"<p>Aqui est\u00e3o as instru\u00e7\u00f5es para implantar o laborat\u00f3rio. Voc\u00ea pode optar por uma implanta\u00e7\u00e3o pronta ou uma customizada.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#41-implantacao-pronta","title":"4.1 Implanta\u00e7\u00e3o Pronta","text":"<p>Este m\u00e9todo permite ao usu\u00e1rio baixar uma vers\u00e3o pr\u00e9-montada do laborat\u00f3rio, com a topologia e as configura\u00e7\u00f5es j\u00e1 definidas. Basta baixar o reposit\u00f3rio e seguir para o in\u00edcio da execu\u00e7\u00e3o.</p> <p>Dica</p> <p>A implanta\u00e7\u00e3o pronta \u00e9 \u00fatil para quem deseja come\u00e7ar rapidamente com um ambiente configurado.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#baixando-o-lab","title":"Baixando o Lab","text":"<p>Para baixar o laborat\u00f3rio, execute o comando correspondente ao seu sistema operacional.</p> Linux/MacWindows <pre><code>curl -L -o get.sh \"https://git.rnp.br/redes-abertas/labs/-/raw/main/zabbix-lab/get.sh?ref_type=heads&amp;inline=false\" &amp;&amp; sh get.sh &amp;&amp; cd zabbix-lab\n</code></pre> <pre><code>curl -L -o get.bat \"https://git.rnp.br/redes-abertas/labs/-/raw/main/zabbix-lab/get.bat?ref_type=heads&amp;inline=false\" &amp;&amp; call get.bat &amp;&amp; cd zabbix-lab\n</code></pre> <p>Este comando far\u00e1 o download do script de instala\u00e7\u00e3o e o direcionar\u00e1 para o diret\u00f3rio do laborat\u00f3rio.</p> <p>Dica</p> <p>Antes de executar os scripts, verifique se as permiss\u00f5es de execu\u00e7\u00e3o est\u00e3o corretas (use <code>chmod +x get.sh</code> no Linux/Mac).</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#5-iniciando-o-lab","title":"5. Iniciando o Lab","text":"<p>Ap\u00f3s o download ou personaliza\u00e7\u00e3o, siga as etapas abaixo para iniciar o laborat\u00f3rio. Execute o comando abaixo dentro do diret\u00f3rio baixado.</p> <pre><code>sudo containerlab deploy\n</code></pre> <p>Esse comando iniciar\u00e1 a topologia definida no laborat\u00f3rio e criar\u00e1 todos os containers necess\u00e1rios.</p> <p>Dica</p> <p>Caso ocorra algum erro, verifique a sa\u00edda do comando para poss\u00edveis mensagens de erro. Use <code>docker logs &lt;container_name&gt;</code> para depurar.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#6-acesso","title":"6. Acesso","text":"<p>Ap\u00f3s o laborat\u00f3rio ser iniciado, voc\u00ea poder\u00e1 acessar os dispositivos e servi\u00e7os configurados na rede.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#61-tabela-de-ips-e-portas-de-servico","title":"6.1 Tabela de IPs e Portas de Servi\u00e7o","text":"<p>Aqui est\u00e1 um exemplo de tabela de dispositivos, IPs e portas de servi\u00e7o dispon\u00edveis no laborat\u00f3rio.</p> Dispositivo IP de Acesso Porta Servi\u00e7o Roteador BA 172.10.10.6 22 SSH Roteador ES 172.10.10.11 22 SSH Zabbix Server 172.10.10.115 10051 Zabbix Server Zabbix Frontend 172.10.10.116 880/443 Web UI (Zabbix) Zabbix Agent 172.10.10.117 10050 Zabbix Agent Zabbix Database 172.10.10.118 5432 PostgreSQL Graphite 172.10.10.119 8080 Web UI (Graphite)"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#62-senhas-de-acesso","title":"6.2 Senhas de Acesso","text":"Servi\u00e7o Usu\u00e1rio Senha Roteador BA (SSH) <code>admin</code> <code>admin@123</code> Roteador ES (SSH) <code>admin</code> <code>admin@123</code> Zabbix (Web UI) <code>Admin</code> <code>zabbix</code> Zabbix Database <code>zabbix</code> <code>zabbixdatabase</code> <p>Aten\u00e7\u00e3o</p> <p>antes de acessar, acesse o log de um dispositivo para verificar se ele foi iniciado e configurado corretamente.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#7-proximos-passos","title":"7.  Pr\u00f3ximos Passos","text":"<p>Ao iniciar o laborat\u00f3rio, o zabbix vai esta cru sem templates, para configura a descoberta automatica e os templates, acesse o Configurando Auto Discovery</p>"},{"location":"Laborat%C3%B3rios/Juniper/vMX/Roteamento-OSPF/","title":"Roteamento OSPF","text":""},{"location":"Laborat%C3%B3rios/Juniper/vMX/Roteamento-OSPF/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Este laborat\u00f3rio simula uma rede com 3 roteadores em uma topologia em anel, configurados utilizando OSPF para roteamento din\u00e2mico e SNMP para envio de telemetria pela rede.</p>"},{"location":"Laborat%C3%B3rios/Juniper/vMX/Roteamento-OSPF/#1-topologia-e-configuracoes","title":"1. Topologia e Configura\u00e7\u00f5es","text":"<p>A topologia consiste em tr\u00eas roteadores (PB, PE, JPA) conectados em um anel. Cada roteador est\u00e1 configurado com interfaces de rede e endere\u00e7os IP, al\u00e9m de protocolos OSPF para roteamento e SNMP para monitoramento, como podemos ver na imagem a seguir.</p> <p></p> <p>Os roteadores est\u00e3o configurados com as seguintes tecnologias:</p> <ul> <li>OSPF (Open Shortest Path First): Utilizado para roteamento din\u00e2mico na rede, permitindo que os roteadores troquem informa\u00e7\u00f5es sobre rotas e atualiza\u00e7\u00f5es de topologia.</li> <li>SNMP (Simple Network Management Protocol): Utilizado para monitoramento e gerenciamento da rede, permitindo o acesso a informa\u00e7\u00f5es de telemetria dos dispositivos.</li> </ul>"},{"location":"Laborat%C3%B3rios/Juniper/vMX/Roteamento-OSPF/#2-instalacao","title":"2. Instala\u00e7\u00e3o","text":""},{"location":"Laborat%C3%B3rios/Juniper/vMX/Roteamento-OSPF/#21-pre-requisitos","title":"2.1 Pr\u00e9 requisitos:","text":"<p>Para iniciar o laborat\u00f3rio, \u00e9 necess\u00e1rio a instala\u00e7\u00e3o e configura\u00e7\u00e3o dos seguintes componentes:</p> <ul> <li>Netbox</li> <li>Netreplica</li> <li>Containerlab</li> </ul> <p>Caso o seu ambiente n\u00e3o esteja configurado, siga os passos Guia de Configura\u00e7\u00e3o</p>"},{"location":"Laborat%C3%B3rios/Juniper/vMX/Roteamento-OSPF/#22-importando-template-no-netbox","title":"2.2 Importando Template no Netbox:","text":"<p>O Containerlab utiliza startup-config para importar configura\u00e7\u00f5es aos equipamentos, essas definidas em templates dentro do Netbox.</p> <ol> <li> <p> No Netbox, crie um Data source e adicione o reposit\u00f3rio do git abaixo: <pre><code>https://git.rnp.br/gci/dev/inovacao-ciberinfraestrutura/config-templates-data-source\n</code></pre> Como adicionar: Render Templates - #Templates remotos</p> </li> <li> <p>Importe o template do laborat\u00f3rio de OSPF:</p> <ol> <li>Acesse seu Netbox e v\u00e1 em Provisionamento &gt; Modelos de Configura\u00e7\u00e3o.</li> <li>Crie um template e defina um nome de sua escolha.</li> <li>Em Data Source escolha o nome do data source criado no passo 1.</li> <li>Em File Selecione: <code>Juniper/&lt;imagem&gt;/OSPF.jinja2</code>]</li> </ol> <p>Aten\u00e7\u00e3o</p> <p>Atente-se a imagem do dispositivo, pois os templates de configura\u00e7\u00e3o s\u00e3o criados de maneiras distintas para cada tipo de imagem</p> </li> <li> <p> Associando Templates aos Dispositivos:</p> <ol> <li>No seu Netbox, acesse Dispositivos &gt; Dispositivos.</li> <li>Selecione o dispositivo que deseja associar ao template e clique em editar. </li> <li>Na categoria Gest\u00e3o, em Modelo de configura\u00e7\u00e3o selecione o nome do template definido no passo 2.2.</li> <li>Salve as altera\u00e7\u00f5es.</li> </ol> </li> </ol>"},{"location":"Laborat%C3%B3rios/Juniper/vMX/Roteamento-OSPF/#23-montando-o-laboratorio","title":"2.3 Montando o Laborat\u00f3rio:","text":"<p>Agora, com o Netreplica iremos puxar as informa\u00e7\u00f5es do Netbox para montar  o arquivo <code>.clab</code> que ser\u00e1 utilizado pelo Containerlab para subir o laborat\u00f3rio. </p> <ol> <li>Na pasta onde o container do Netreplica est\u00e1, d\u00ea o seguinte comando para importar as configura\u00e7\u00f5es do Netbox:  <pre><code>nrx -c conf/&lt;arquivo&gt;.conf -n ospf-lab\n</code></pre></li> <li>Agora com o arquivo <code>.clab</code> criado, utilize o comando para subir o laborat\u00f3rio: <pre><code>sudo -E clab dep -t conf/lab/ospf-lab.clab.yaml\n</code></pre></li> </ol> <p>Aten\u00e7\u00e3o</p> <p>Os dispositivos necessitam de um tempo para serem incializados e configurados, pode ser que o laborat\u00f3rio (graphite) j\u00e1 esteja dispon\u00edvel e voc\u00ea n\u00e3o consiga acessar os dispositivos. </p> <p>Dica</p> <p>Para visualizar os logs do container e verificar se j\u00e1 foi configurado, voc\u00ea pode usar: <pre><code>docker logs &lt;nome_do_container&gt; -f\n</code></pre></p>"},{"location":"Laborat%C3%B3rios/Juniper/vMX/Roteamento-OSPF/#3-acesso","title":"3. Acesso","text":"<p>Existem duas formas de acesso aos dispositivos na rede:</p> <ul> <li> <p>Acesso via SSH aos roteadores: Utilize um cliente SSH para se conectar aos roteadores utilizando o endere\u00e7o IP de cada dispositivo ou o nome atribu\u00eddo pelo Containerlab, juntamente com as credenciais de login fornecidas. O endere\u00e7o IP de ger\u00eancia de cada roteador \u00e9 exibido ap\u00f3s a execu\u00e7\u00e3o do laborat\u00f3rio pelo Containerlab.</p> <p>Exemplo:</p> <pre><code>ssh admin@&lt;endere\u00e7o_IP_do_roteador&gt;\n</code></pre> <p>ou</p> <pre><code>ssh admin@&lt;nome_do_roteador&gt;\n</code></pre> </li> <li> <p>Acesso ao Graphite (Servidor de Tepologia): Acesse o Graphite atrav\u00e9s do navegador utilizando o endere\u00e7o IP e a porta configurados. Voc\u00ea tamb\u00e9m pode acessar diretamente clicando no \u00edcone de SSH no roteador desejado.</p> <p>URL: <code>http://&lt;endere\u00e7o_IP_do_Graphite&gt;:8080/graphite/</code></p> <p>Credenciais:</p> </li> <li> <p>Usu\u00e1rio: admin</p> </li> <li>Senha: admin@123</li> </ul>"},{"location":"Laborat%C3%B3rios/Juniper/vMX/Roteamento-OSPF/#4-monitoramento","title":"4. Monitoramento","text":"<p>Para monitorar a rede e os dispositivos, voc\u00ea pode utilizar ferramentas como edgeshark para an\u00e1lise de pacotes ou ferramentas de monitoramento SNMP.</p> <ul> <li>edgeshark: Capture e analise o tr\u00e1fego de rede para diagn\u00f3stico de problemas e monitoramento de desempenho.</li> <li>Monitoramento SNMP: Utilize ferramentas compat\u00edveis com SNMP para monitorar m\u00e9tricas de desempenho e sa\u00fade da rede.</li> </ul>"},{"location":"Laborat%C3%B3rios/Multivendor/Configura%C3%A7%C3%A3o-NETCONF/","title":"Index","text":""},{"location":"Laborat%C3%B3rios/Multivendor/Configura%C3%A7%C3%A3o-NETCONF/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Este laborat\u00f3rio oferece uma abordagem pr\u00e1tica para configurar dispositivos de rede utilizando o protocolo NETCONF e modelos de dados YANG. </p>"},{"location":"Laborat%C3%B3rios/Multivendor/Configura%C3%A7%C3%A3o-NETCONF/#pre-requisitos","title":"Pr\u00e9-requisitos","text":"<ul> <li>containerlab</li> <li><code>uv</code> (caso queira criar manualmente o ambiente virtual, utilize Python 3.12)</li> </ul> <p>Para iniciar, clone o reposit\u00f3rio contendo scripts e exemplos em: <pre><code>ssh://git@git.rnp.br:2022/redes-abertas/schema-driven-cfg.git\n</code></pre></p>"},{"location":"Laborat%C3%B3rios/Multivendor/Configura%C3%A7%C3%A3o-NETCONF/#construindo-o-ambiente-de-teste-com-containerlab","title":"Construindo o Ambiente de Teste com <code>containerlab</code>","text":"<p>Nesta se\u00e7\u00e3o, utilizaremos o <code>containerlab</code> para implantar uma topologia de rede simples definida no arquivo <code>simple-lab.yaml</code>.</p> <ol> <li> <p>Gera\u00e7\u00e3o de Imagens (se necess\u00e1rio):     As imagens dos roteadores virtuais (vSRX para Juniper e NE40E para Huawei) precisam estar dispon\u00edveis localmente. Utilize o <code>vrnetlab</code> para construir essas imagens. Consulte a documenta\u00e7\u00e3o do <code>vrnetlab</code> para instru\u00e7\u00f5es detalhadas sobre como gerar as imagens <code>VSRX 20.1R1.13</code> e <code>Huawei NE40E V800R011C00SPC607B607</code>. A imagem Cisco XRd n\u00e3o precisa ser gerada dessa maneira, pois j\u00e1 \u00e9 um container, basta seguir as instru\u00e7\u00f5es no site do containerlab.</p> </li> <li> <p>Implanta\u00e7\u00e3o da Topologia:     Com as imagens prontas, execute o seguinte comando para iniciar o laborat\u00f3rio:</p> <p><pre><code>sudo containerlab deploy -t simple-lab.yaml\n</code></pre> O <code>containerlab</code> provisionar\u00e1 os cont\u00eaineres e exibir\u00e1 uma tabela com os endere\u00e7os IP para cada dispositivo. Anote esses IPs, pois ser\u00e3o utilizados nas etapas subsequentes.</p> </li> </ol>"},{"location":"Laborat%C3%B3rios/Multivendor/Configura%C3%A7%C3%A3o-NETCONF/#instalando-dependencias-python","title":"Instalando Depend\u00eancias Python","text":"<p>Os scripts Python utilizados neste laborat\u00f3rio possuem depend\u00eancias externas. Siga um dos m\u00e9todos abaixo para instal\u00e1-las:</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Configura%C3%A7%C3%A3o-NETCONF/#usando-uv-recomendado","title":"Usando <code>uv</code> (Recomendado)","text":"<p>Se voc\u00ea possui o <code>uv</code> instalado, execute o comando abaixo na raiz do reposit\u00f3rio clonado para criar um ambiente virtual e instalar as depend\u00eancias:</p> <p><pre><code>uv sync\n</code></pre> Em seguida, ative o ambiente virtual: <pre><code>source .venv/bin/activate\n</code></pre></p>"},{"location":"Laborat%C3%B3rios/Multivendor/Configura%C3%A7%C3%A3o-NETCONF/#usando-pip-com-um-ambiente-virtual-manual","title":"Usando <code>pip</code> com um Ambiente Virtual Manual","text":"<p>Se preferir gerenciar o ambiente virtual manualmente com Python 3.12+ e <code>pip</code>:</p> <ol> <li>Crie um ambiente virtual:     <pre><code>python3 -m venv .venv\n</code></pre></li> <li>Ative o ambiente virtual:     <pre><code>source .venv/bin/activate\n</code></pre></li> <li>Instale as depend\u00eancias:     <pre><code>pip install -r requirements.txt\n</code></pre></li> </ol>"},{"location":"Laborat%C3%B3rios/Multivendor/Configura%C3%A7%C3%A3o-NETCONF/#testando-operacoes-netconf","title":"Testando Opera\u00e7\u00f5es NETCONF","text":"<p>Com o ambiente configurado, podemos testar as opera\u00e7\u00f5es NETCONF usando o script <code>netconf_test.py</code>. Este script utiliza arquivos de configura\u00e7\u00e3o YAML para definir os par\u00e2metros de conex\u00e3o do dispositivo e payloads XML para as opera\u00e7\u00f5es NETCONF.</p> <ol> <li> <p>Atualize os Arquivos de Configura\u00e7\u00e3o do Dispositivo:     Modifique os arquivos <code>huawei_device_config.yaml</code>, <code>junos_device_config.yaml</code> e <code>cisco_device_config.yaml</code> com os endere\u00e7os IP corretos dos seus dispositivos (fornecidos pelo <code>containerlab</code>) e as credenciais correspondentes.</p> <p>Exemplo (<code>huawei_device_config.yaml</code>): <pre><code># filepath: huawei_device_config.yaml\ndevice:\nhostname: \"172.20.20.5\"\nusername: \"admin\"\npassword: \"admin\"\nport: 830\ntype: \"huaweiyang\"\n</code></pre></p> </li> <li> <p>Execute o Script <code>netconf_test.py</code>:</p> <p>Uso do Script: <pre><code>python netconf_test.py -c &lt;arquivo_config_yaml&gt; -p &lt;arquivo_payload_xml&gt;\n</code></pre></p> <p>Argumentos: -   <code>-c CONFIG</code>, <code>--config CONFIG</code>: Caminho para o arquivo de configura\u00e7\u00e3o YAML do dispositivo (e.g., <code>huawei_device_config.yaml</code>). -   <code>-p PAYLOAD</code>, <code>--payload PAYLOAD</code>: Caminho para o arquivo XML contendo o payload NETCONF (e.g., <code>xml/huawei-native-interface-ip.xml</code>).</p> <p>Exemplo de Aplica\u00e7\u00e3o de Configura\u00e7\u00e3o de Interface em um Dispositivo Huawei: <pre><code>python netconf_test.py -c huawei_device_config.yaml -p xml/huawei-native-interface-ip.xml\n</code></pre> Acesse o dispositivo e verifique que o IP <code>10.1.1.2/24</code> foi configurado na interface <code>Ethernet1/0/1</code>.</p> <p>Para remover a configura\u00e7\u00e3o utilize o payload de dele\u00e7\u00e3o: <pre><code>python netconf_test.py -c huawei_device_config.yaml -p xml/huawei-native-interface-ip-delete.xml\n</code></pre></p> <p>Exemplo de Aplica\u00e7\u00e3o de Configura\u00e7\u00e3o de Interface em um Dispositivo Juniper: <pre><code>python netconf_test.py -c junos_device_config.yaml -p xml/junos-native-interface-ip.xml\n</code></pre> Acesse o dispositivo e verifique que o IP <code>10.1.1.2/24</code> foi configurado na interface <code>ge-0/0/0</code>.</p> <p>Para remover a configura\u00e7\u00e3o utilize o payload de dele\u00e7\u00e3o: <pre><code>python netconf_test.py -c junos_device_config.yaml -p xml/junos-native-interface-ip-delete.xml\n</code></pre></p> <p>Exemplo de Aplica\u00e7\u00e3o de Configura\u00e7\u00e3o de Interface em um Dispositivo Cisco: <pre><code>python netconf_test.py -c cisco_device_config.yaml -p xml/cisco-native-interface-ip.xml\n</code></pre> Acesse o dispositivo e verifique que o IP <code>192.168.1.12</code> foi configurado na interface <code>GigabitEthernet0/0/0/0</code>.</p> <p>Para remover a configura\u00e7\u00e3o utilize o payload de dele\u00e7\u00e3o: <pre><code>python netconf_test.py -c cisco_device_config.yaml -p xml/cisco-native-interface-ip-delete.xml\n</code></pre></p> <p>Exemplo com o uso de modelos OpenConfig:</p> <p>Agora tente realizar a mesma opera\u00e7\u00e3o utilizando os payloads do modelo OpenConfig: <pre><code>#Huawei\npython netconf_test.py -c huawei_device_config.yaml -p xml/openconfig-huawei-interface-ip.xml\n#Juniper\npython netconf_test.py -c junos_device_config.yaml -p xml/openconfig-junos-interface-ip.xml\n</code></pre></p> </li> </ol>"},{"location":"Laborat%C3%B3rios/Multivendor/Configura%C3%A7%C3%A3o-NETCONF/#obtendo-modelos-yang-dos-dispositivos","title":"Obtendo Modelos YANG dos Dispositivos","text":"<p>Os modelos YANG definem a estrutura dos dados de configura\u00e7\u00e3o e estado dos dispositivos de rede, servindo como base para automa\u00e7\u00e3o e interoperabilidade via NETCONF. Compreender e explorar esses modelos \u00e9 fundamental para criar payloads NETCONF corretos.</p> <p>A seguir, apresentamos m\u00e9todos para obter os modelos YANG dos dispositivos Huawei, Juniper e Cisco deste exemplo.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Configura%C3%A7%C3%A3o-NETCONF/#obtendo-modelos-yang-de-dispositivos-huawei","title":"Obtendo Modelos YANG de Dispositivos Huawei","text":"<p>No caso de dispositivos Huawei, podemos obter os modelos YANG via NETCONF, sem necessidade de alterar a configura\u00e7\u00e3o inicial do dispositivo feita pelo containerlab. Utilize o script <code>huawei_get_schema.py</code> para baixar os modelos para uma pasta local.</p> <p>Uso do Script:</p> <pre><code>python huawei_get_schema.py &lt;host&gt; &lt;username&gt; &lt;password&gt; [output_dir]\n</code></pre> <p>Argumentos:</p> <ul> <li><code>host</code>: Endere\u00e7o IP ou hostname do dispositivo Huawei (obtido do <code>containerlab</code>).</li> <li><code>username</code>: Nome de usu\u00e1rio para autentica\u00e7\u00e3o NETCONF.</li> <li><code>password</code>: Senha para autentica\u00e7\u00e3o NETCONF.</li> <li><code>output_dir</code> (Opcional): Diret\u00f3rio para salvar os arquivos YANG. Padr\u00e3o: <code>huawei-schema</code>.</li> </ul>"},{"location":"Laborat%C3%B3rios/Multivendor/Configura%C3%A7%C3%A3o-NETCONF/#obtendo-modelos-yang-de-dispositivos-juniper","title":"Obtendo Modelos YANG de Dispositivos Juniper","text":"<p>Para dispositivos Juniper (Junos OS), recomenda-se obter os modelos YANG diretamente pela CLI do equipamento e transferi-los para sua m\u00e1quina local.</p> <p>Consulte a documenta\u00e7\u00e3o oficial da Juniper para orienta\u00e7\u00f5es detalhadas.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Configura%C3%A7%C3%A3o-NETCONF/#obtendo-o-modelo-yang-de-dispositivos-cisco","title":"Obtendo o modelo YANG de dispositivos Cisco","text":"<p>Para obter o modelo YANG de um dispositivo Cisco, execute o script <code>cisco_get_schema.py</code> da seguinte maneira: <pre><code>usage: cisco_get_schema.py [-h] [--port PORT] host username password [output_dir]\nargumentos:\n  host          Endere\u00e7o IP ou hostname do dispositivo Cisco\n  username      Nome de usu\u00e1rio para autentica\u00e7\u00e3o no dispositivo\n  password      Senha para autentica\u00e7\u00e3o no dispositivo\n  output_dir    (Opcional) Caminho para o diret\u00f3rio onde os arquivos YANG ser\u00e3o salvos - default=cisco-schema\n  --port        (Opcional) Porta NETCONF - default=830\nex:\npython cisco_get_schema.py 192.168.1.2 admin 'senha' cisco-schema --port 830\n</code></pre></p> <p>Os arquivos YANG ser\u00e3o baixados e salvos no diret\u00f3rio especificado (quando dispon\u00edvel, o nome seguir\u00e1 o padr\u00e3o <code>&lt;modulo&gt;@&lt;revision&gt;.yang</code>).</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/","title":"Descoberta Diode Multivendor","text":""},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Este laborat\u00f3rio simula uma rede com 3 roteadores de diferentes fabricantes (Juniper, Cisco e Huawei) configurados com OSPF e SNMP, integrando os componentes do Diode (plugin, server e agent) e o Netbox para importa\u00e7\u00e3o e gerenciamento automatizado de dispositivos.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#1-descricao","title":"1. Descri\u00e7\u00e3o","text":""},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#11-objetivo-do-lab","title":"1.1 Objetivo do Lab","text":"<p>O objetivo deste laborat\u00f3rio \u00e9 demonstrar, de forma pr\u00e1tica, o processo de descoberta e importa\u00e7\u00e3o automatizada de dispositivos de rede multivendor, abrangendo diferentes modelos e fabricantes, e suas respectivas configura\u00e7\u00f5es para o Netbox, utilizando o diodo-plugin, o diode-server e o orb-agent.</p> <p></p>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#12-topologia-do-lab","title":"1.2 Topologia do Lab","text":"<p>Abaixo est\u00e1 a topologia mostrando os tr\u00eas roteadores \u2014 Juniper, Cisco e Huawei \u2014 al\u00e9m dos servidores envolvidos na arquitetura.</p> <p></p> <p>Os roteadores est\u00e3o configurados com as seguintes tecnologias:</p> <ul> <li>OSPF (Open Shortest Path First): Utilizado para roteamento din\u00e2mico, permitindo que dispositivos (independentemente do fabricante) troquem informa\u00e7\u00f5es sobre rotas e topologia.</li> <li>SNMP (Simple Network Management Protocol): Usado para coleta de telemetria e descoberta, garantindo compatibilidade com dispositivos Juniper, Cisco e Huawei.</li> </ul>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#2-aplicacoes","title":"2. Aplica\u00e7\u00f5es","text":""},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#exemplos-de-aplicacoes","title":"Exemplos de Aplica\u00e7\u00f5es","text":"<p>Este laborat\u00f3rio demonstra uma arquitetura realista de descoberta autom\u00e1tica de dispositivos em ambientes onde coexistem m\u00faltiplos fabricantes.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#possiveis-aplicacoes","title":"Poss\u00edveis Aplica\u00e7\u00f5es:","text":"<ul> <li>Automa\u00e7\u00e3o da descoberta multivendor: Detec\u00e7\u00e3o autom\u00e1tica de dispositivos Juniper, Cisco e Huawei e registro de seus invent\u00e1rios no Netbox.</li> <li>Padroniza\u00e7\u00e3o de invent\u00e1rio heterog\u00eaneo: Cria\u00e7\u00e3o de uma base unificada de dispositivos independentemente do fornecedor.</li> <li>Cria\u00e7\u00e3o de reposit\u00f3rio centralizado de dispositivos: Constru\u00e7\u00e3o de uma base confi\u00e1vel de dados da rede em tempo real.</li> <li>Estudo pr\u00e1tico de SNMP em ambientes h\u00edbridos: Compara\u00e7\u00e3o na pr\u00e1tica entre diferentes MIBs e padr\u00f5es dos fabricantes.</li> <li>Integra\u00e7\u00e3o Diode + Netbox em cen\u00e1rios reais: Pr\u00e1tica de coleta e integra\u00e7\u00e3o de dados de rede.</li> </ul>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#3-requisitos","title":"3. Requisitos","text":""},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#31-pre-requisitos","title":"3.1 Pr\u00e9 requisitos","text":"<p>Para iniciar o laborat\u00f3rio, \u00e9 necess\u00e1rio a instala\u00e7\u00e3o e configura\u00e7\u00e3o dos seguintes componentes:</p> <ul> <li>Netbox</li> <li>Diode Plugin</li> <li>Diode Server</li> <li>Orb Agent</li> <li>Containerlab</li> <li>Docker</li> </ul> <p>Caso o seu ambiente n\u00e3o esteja configurado, siga os passos Guia de Configura\u00e7\u00e3o</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#32-tabela-de-requisitos-computacionais","title":"3.2 Tabela de Requisitos Computacionais","text":"Requisito Detalhes CPUs 4 vCPUs (m\u00ednimo recomendado) Mem\u00f3ria RAM 12 GB Espa\u00e7o em Disco 10 GB Containerlab 0.64.0 Rede Criada br-lab <p>Dica</p> <p>Verifique se a vers\u00e3o do Docker e do Containerlab s\u00e3o compat\u00edveis para evitar erros durante a implanta\u00e7\u00e3o.</p> <p>Aten\u00e7\u00e3o</p> <p>Verifique se o seu processador possui suporte \u00e0 virtualiza\u00e7\u00e3o por hardware e se essa funcionalidade est\u00e1 ativada na BIOS/UEFI. - Em processadores Intel, essa tecnologia \u00e9 chamada de VT-x (Intel Virtualization Technology). - Em processadores AMD, \u00e9 conhecida como AMD-V (AMD Virtualization).  </p> <p>Sem essa funcionalidade ativada, as imagens como o vJunos-router n\u00e3o funcionar\u00e3o corretamente.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#4-instalacao","title":"4. Instala\u00e7\u00e3o","text":""},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#41-configurando-a-rede-docker","title":"4.1 Configurando a Rede Docker","text":"<p>Antes de iniciar os containers, crie a rede bridge que interligar\u00e1 os dispositivos:</p> <pre><code>docker network create \\\n  --driver=bridge \\\n  --opt com.docker.network.bridge.name=br-lab \\\n  --subnet=172.10.10.0/24 \\\n  br-lab\n</code></pre>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#42-clonando-o-repositorio-do-lab","title":"4.2 Clonando o Reposit\u00f3rio do Lab","text":"<p>Execute o script abaixo para baixar e configurar o laborat\u00f3rio automaticamente:</p> Linux/MacWindows <pre><code>curl -L -o get.sh \"https://git.rnp.br/redes-abertas/labs/-/raw/main/discovery-lab-diode-multivendor/get.sh?ref_type=heads&amp;inline=false\" &amp;&amp; sh get.sh &amp;&amp; cd discovery-lab\n</code></pre> <pre><code>curl -L -o get.bat \"https://git.rnp.br/redes-abertas/labs/-/raw/main/discovery-lab-diode-multivendor/get.bat?ref_type=heads&amp;inline=false\" &amp;&amp; call get.bat &amp;&amp; cd discovery-lab\n</code></pre> <p>Dica</p> <p>No Linux/Mac, use <code>chmod +x get.sh</code> antes de executar o script, caso ele n\u00e3o esteja com permiss\u00e3o de execu\u00e7\u00e3o.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#5-implantacao-do-ambiente","title":"5. Implanta\u00e7\u00e3o do Ambiente","text":""},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#51-subindo-os-roteadores-com-containerlab","title":"5.1 Subindo os Roteadores com Containerlab","text":"<p>Aqui, os tr\u00eas dispositivos Juniper/Cisco/Huawei ser\u00e3o inicializados. O tempo de boot pode variar conforme o fabricante.</p> <pre><code>sudo clab deploy -t clab/discovery-lab.clab.yaml\n</code></pre> <p>Debug</p> <p>Os dispositivos podem levar cerca de 10 minutos para estarem totalmente operacionais. Caso ocorra algum erro, verifique a sa\u00edda do comando para poss\u00edveis mensagens de erro. Use <code>docker logs &lt;container_name&gt;</code> para depurar.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#52-levantando-o-diode-server","title":"5.2 Levantando o Diode Server","text":"<p>Dica</p> <p>Caso voc\u00ea j\u00e1 possua o servidor do Diode configurado, basta pular esse passo.</p> <ol> <li> <p>Vamos criar uma nova pasta para armazenar os arquivos do diode-server: <pre><code>mkdir diode-server\ncd diode-server\n</code></pre></p> </li> <li> <p>Agora, vamos realizar o download do script de in\u00edcio r\u00e1pido: <pre><code>curl -sSfLo quickstart.sh https://raw.githubusercontent.com/netboxlabs/diode/release/diode-server/docker/scripts/quickstart.sh\nchmod +x quickstart.sh\n</code></pre></p> </li> <li> <p>Ent\u00e3o, basta executar o script passando a url do seu netbox: <pre><code>./quickstart.sh https://&lt;netbox-server&gt;\n</code></pre></p> </li> <li> <p>Por fim, basta iniciar os containers: <pre><code>docker compose up -d\n</code></pre></p> </li> <li> <p>Para extrair as credenciais necess\u00e1rias na instala\u00e7\u00e3o do plugin, execute o comando abaixo: <pre><code>echo $(jq -r '.[] | select(.client_id == \"netbox-to-diode\") | .client_secret' ./oauth2/client/client-credentials.json)\n</code></pre></p> </li> </ol> <p>Dica</p> <p>Armazene o token, voc\u00ea vai precisar adicion\u00e1-lo na configura\u00e7\u00e3o a seguir.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#53-instalando-o-plugin-no-netbox","title":"5.3 Instalando o Plugin no Netbox","text":"<p>Neste passo, vamos instalar o plugin do diode, respons\u00e1vel por estabelecer a conex\u00e3o entre o diode-server e o Netbox.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#531-configurando-a-versao-do-netbox","title":"5.3.1 Configurando a vers\u00e3o do Netbox:","text":"<ol> <li>Primeiro, vamos clonar o reposit\u00f3rio do Netbox Docker: <pre><code>git clone -b release https://github.com/netbox-community/netbox-docker.git\n</code></pre></li> <li>Agora, vamos para a Release 3.2.1: <pre><code>cd netbox-docker/\ngit checkout 3.2.1\n</code></pre></li> </ol> <p>Informa\u00e7\u00e3o</p> <p>Alteramos a branch do reposit\u00f3rio para termos acesso \u00e0 vers\u00e3o 4.2.4 do Netbox.</p> <p>Dica</p> <p>Todos os comandos abaixos ser\u00e3o executados dentro diret\u00f3rio raiz do netbox <code>netbox-docker/</code>.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#532-plugin_requirementstxt","title":"5.3.2 plugin_requirements.txt","text":"<p>Este arquivo cont\u00e9m ama lista dos plugins do Netbox (como pacotes Python do PyPO) que devem ser instalados durante a constru\u00e7\u00e3o da imagem Docker.</p> <p>Execute o seguinte comando para escrever o pacote dentro do arquivo <code>plugin_requirements.txt</code>.</p> <pre><code>echo \"netboxlabs-diode-netbox-plugin\" &gt;&gt; plugin_requirements.txt\n</code></pre>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#533-dockerfile-plugins","title":"5.3.3 DockerFile-Plugins","text":"<p>Esse \u00e9 o DockerFile usado para construir a imagem docker customizada.</p> <ol> <li> <p>Crie o arquivo e acesse com um editor:  <pre><code>nano DockerFile-Plugins\n</code></pre></p> </li> <li> <p>Copie o conte\u00fado abaixo e cole no arquivo: <pre><code>FROM netboxcommunity/netbox:v4.2.4\n\nCOPY ./plugin_requirements.txt /opt/netbox/\nRUN /usr/local/bin/uv pip install -r /opt/netbox/plugin_requirements.txt\n</code></pre></p> </li> </ol>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#534-docker-composeoverrideyml","title":"5.3.4. docker-compose.override.yml","text":"<p>Como o nome implica, esse arquivo contaim as configura\u00e7\u00f5es que v\u00e3o sobrescrever o <code>docker-compose.yml</code>.</p> <p>Caso voc\u00ea ainda n\u00e3o tenha configurado a rede <code>br-lab</code>. Acesse: Configurando a Rede Docker</p> <ol> <li> <p>Crie o arquivo e acesse com um editor: <pre><code>nano docker-compose.override.yml\n</code></pre></p> </li> <li> <p>Copie o conte\u00fado abaixo e cole no arquivo: <pre><code>services:\n  netbox:\n    image: netbox:latest-plugins\n    pull_policy: never\n    ports:\n      - 8000:8080\n    build:\n      context: .\n      dockerfile: Dockerfile-Plugins\n    networks:\n      - br-lab\n\n  netbox-worker:\n    image: netbox:latest-plugins\n    pull_policy: never\n    networks:\n      - br-lab\n\n  netbox-housekeeping:\n    image: netbox:latest-plugins\n    pull_policy: never\n    networks:\n      - br-lab\n\n  postgres:\n    networks:\n      - br-lab\n\n  redis:\n    networks:\n      - br-lab\n\n  redis-cache:\n    networks:\n      - br-lab\n\nnetworks:\n  br-lab:\n    external: true\n</code></pre></p> </li> </ol> <p>As altera\u00e7\u00f5es feitas foram: </p> <ul> <li>adicionar o Netbox na rede <code>br-lab</code>.</li> <li>altera\u00e7\u00e3o do dockerfile para o <code>Dockerfile-Plugins</code>, criado anteriormente.</li> <li>Tamb\u00e9m alterado a imagem dos servi\u00e7os para: <code>netbox:latest-plugins</code>.</li> </ul>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#535-pluginspy","title":"5.3.5. plugins.py","text":"<p>Este arquivo \u00e9 respons\u00e1vel por setar as configura\u00e7\u00f5es espec\u00edficas de cada plugin.</p> <ol> <li> <p>Acesse o arquivo com o editor: <pre><code>nano configuration/plugins.py\n</code></pre></p> </li> <li> <p>Copie e cole o conte\u00fado no arquivo: <pre><code>PLUGINS = [\n    \"netbox_diode_plugin\",\n]\n\nPLUGINS_CONFIG = {\n    \"netbox_diode_plugin\": {\n        # Diode gRPC target for communication with Diode server\n        \"diode_target_override\": \"grpc://localhost:8080/diode\",\n\n        # Username associated with changes applied via plugin\n        \"diode_username\": \"diode\",\n\n        # netbox-to-diode client_secret created during diode bootstrap.\n        \"netbox_to_diode_client_secret\": \"...\"\n    },\n}\n</code></pre></p> </li> </ol> <p>Dica</p> <p>O token armazenado na instala\u00e7\u00e3o do diode-server deve ser passado na op\u00e7\u00e3o: <code>netbox_to_diode_client_secret</code>.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#536-build-e-deploy","title":"5.3.6 Build e Deploy!","text":"<p>Agora seu Netbox est\u00e1 configurado e pronto para o deploy, siga os comandos abaixo e construa a nova instancia do Netbox!</p> <ol> <li> <p>Construa a imagem: <pre><code>docker compose build --no-cache\n</code></pre></p> </li> <li> <p>Suba os containeres: <pre><code>docker compose up -d\n</code></pre></p> </li> <li> <p>Crie as migra\u00e7\u00f5es necess\u00e1rias com o comando abaixo: <pre><code>docker compose exec -it netbox ./manage.py migrate netbox_diode_plugin\n</code></pre></p> </li> </ol>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#537-gerando-as-credenciais-para-o-agente","title":"5.3.7. Gerando as credenciais para o agente","text":"<p>Precisamos criar as credenciais para que o agente do diode se comunique e repasse os dados coletados dos dispositivos para o diode-server </p> <ol> <li>Acesse seu Netbox e v\u00e1 no menu lateral.</li> <li>V\u00e1 em <code>Diode</code> &gt; <code>Client Credentials</code>.</li> <li>Clique no bot\u00e3o superior <code>Adicionar Credencial</code>.</li> <li>Digite um nome para sua credencial.</li> <li>Armazene o <code>Client Id</code> e o <code>Client Secret</code>.</li> </ol>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#6-orb-agent","title":"6. Orb-Agent","text":"<p>O orb-agent \u00e9 um component do diode respons\u00e1vel por realizar a coleta dos dados nos dispositivos.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#61-configurando-o-agente","title":"6.1 Configurando o agente","text":"<ol> <li> <p>Acesse a pasta do <code>orb-agent</code>: <pre><code>cd ./orb-agent\n</code></pre></p> </li> <li> <p>No arquivo <code>.env</code>, configure as vari\u00e1veis de acordo com o seu ambiente. <pre><code>DOCKER_NETWORK=br-lab                      # Container Network\nDOCKER_SUBNET=172.10.10.0/24               # Devices Network\nDIODE_CLIENT_ID=                           # Diode Client Id\nDIODE_CLIENT_SECRET=                       # Diode Client Secret\nDIODE_HOST=&lt;your-ip&gt;:8080                  # Diode Server Url\nAGENT_NAME=agent1                          # Agent Name\nSITE_NAME=RNP                              # Netbox Site Name \nMULTIDEVICE_COMMUNITY=\"public\"             # Device Community\n</code></pre></p> </li> </ol> <p>Aqui fica o <code>Client Id</code> e o <code>Client Secret</code> gerados no plugin do diode no Netbox.</p> <ol> <li>Agora, vamos aplicar as vari\u00e1veis no template de importa\u00e7\u00e3o do juniper com o comando: <pre><code>set -o allexport &amp;&amp; source .env &amp;&amp; envsubst &lt; agent.snmp.template.yaml &gt; agent.yaml\n</code></pre></li> </ol>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#62-iniciando-a-coleta-dos-dados","title":"6.2 Iniciando a coleta dos dados","text":"<p>Por fim, basta subir o container para iniciar a importa\u00e7\u00e3o dos dispositivos para o Netbox!</p> <pre><code>docker compose up\n</code></pre> <p>\u2705 Acompanhe em tempo real no Netbox os dispositivos sendo coletados pelo agente.</p> <p>\u23f1\ufe0f Al\u00e9m disso, voc\u00ea pode configurar um intervalo de coleta para que o agente realize a importa\u00e7\u00e3o de forma autom\u00e1tica e peri\u00f3dica, sem necessidade de interven\u00e7\u00e3o manual.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#7-acesso","title":"7. Acesso","text":"<p>Ap\u00f3s o laborat\u00f3rio ser iniciado, voc\u00ea poder\u00e1 acessar os dispositivos e servi\u00e7os configurados na rede.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#71-tabela-de-ips-e-portas-de-servico","title":"7.1 Tabela de IPs e Portas de Servi\u00e7o","text":"<p>Aqui est\u00e1 a tabela de dispositivos, IPs e portas de servi\u00e7o dispon\u00edveis no laborat\u00f3rio.</p> Dispositivo Fabricante IP Porta Servi\u00e7o node1 Juniper 172.10.10.201 22 SSH node2 Cisco 172.10.10.202 22 SSH node3 Huawei 172.10.10.203 22 SSH Diode \u2014 localhost 8080 API Netbox \u2014 localhost 8000 Web UI Graphite \u2014 172.20.20.1 8081 Web UI"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#72-senhas-de-acesso","title":"7.2 Senhas de Acesso","text":"<p>Aqui est\u00e1 a tabela com as senhas de acesso dos servi\u00e7os configurados no laborat\u00f3rio.</p> Servi\u00e7o Usu\u00e1rio Senha node1 (SSH) admin admin@123 node2 (SSH) clab clab@123 node3 (SSH) admin admin Netbox (Web) Admin Admin <p>Aten\u00e7\u00e3o</p> <p>antes de acessar acesse o log de um dispositivo para verificar se ele foi iniciado e configurado corretamente.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#8-proximos-passos","title":"8. Pr\u00f3ximos Passos","text":"<p>Com o laborat\u00f3rio finalizado, voc\u00ea pode seguir algum passos abaixo como extra.</p> <ul> <li>Testar diferen\u00e7as de coleta SNMP entre Juniper, Cisco e Huawei.</li> <li>Comparar estrutura de MIBs utilizadas na importa\u00e7\u00e3o.</li> <li>Adicionar novos dispositivos de qualquer fabricante para verificar compatibilidade.</li> </ul>"},{"location":"Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#9-conclusao","title":"9. Conclus\u00e3o","text":"<p>\u2705 Agora voc\u00ea aprendeu como utilizar os componentes do Diode para importar automaticamente uma rede composta por dispositivos Juniper, Cisco e Huawei, construindo um invent\u00e1rio completo no Netbox e possibilitando a cria\u00e7\u00e3o do seu Digital Twin com o Netreplica.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-ELK/","title":"Multvendor logs ELK","text":"<p>Este laborat\u00f3rio simula, via Containerlab, a interliga\u00e7\u00e3o entre tr\u00eas roteadores \u2014 Juniper, Huawei e Cisco \u2014 com roteamento din\u00e2mico via OSPF, e exporta\u00e7\u00e3o de logs via Syslog para uma infraestrutura de observabilidade baseada na pilha ELK (Elasticsearch, Logstash, Kibana), utilizando Elastic Agents gerenciados pelo Fleet para coleta e envio dos dados.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-ELK/#1-descricao","title":"1. Descri\u00e7\u00e3o","text":""},{"location":"Laborat%C3%B3rios/Multivendor/Logs-ELK/#11-objetivo-do-lab","title":"1.1 Objetivo do Lab","text":"<p>O objetivo deste laborat\u00f3rio \u00e9 simular a exporta\u00e7\u00e3o e coleta centralizada de logs provenientes de roteadores de diferentes fabricantes (Juniper, Huawei e Cisco) utilizando o protocolo Syslog (UDP 514). A coleta \u00e9 realizada por Elastic Agents, configurados para receber logs diretamente dos dispositivos e encaminhar os eventos para o Elasticsearch, sob gerenciamento do Fleet Server. A visualiza\u00e7\u00e3o e an\u00e1lise dos logs ocorrem por meio do Kibana, possibilitando uma abordagem moderna de observabilidade multivendor.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-ELK/#12-topologia-do-lab","title":"1.2 Topologia do Lab","text":"<p>Descri\u00e7\u00e3o da Topologia</p> <ul> <li>Tr\u00eas roteadores (Juniper, Cisco, Huawei) interligados em topologia em anel com links ponto a ponto /31.</li> <li>Roteamento din\u00e2mico via OSPF entre os roteadores.</li> <li>Exporta\u00e7\u00e3o de logs via Syslog (UDP/514) para o servidor de monitoramento.</li> <li>Elastic Agent atua como coletor, escutando na porta 514/UDP, parseando os eventos e enviando-os ao Elasticsearch.</li> <li>Fleet Server gerencia e monitora os agentes Elastic.</li> <li>Elasticsearch armazena e indexa os logs recebidos.</li> <li>Kibana fornece a interface gr\u00e1fica para visualiza\u00e7\u00e3o, busca e correla\u00e7\u00e3o dos logs.</li> <li>Rede externa br-lab conecta os roteadores \u00e0 infraestrutura de monitoramento baseada em ELK.</li> </ul>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-ELK/#2-aplicacoes","title":"2. Aplica\u00e7\u00f5es","text":""},{"location":"Laborat%C3%B3rios/Multivendor/Logs-ELK/#exemplos-de-aplicacoes","title":"Exemplos de Aplica\u00e7\u00f5es","text":"<p>Este laborat\u00f3rio constitui uma base para experimenta\u00e7\u00e3o acad\u00eamica e aplicada em monitoramento, observabilidade e an\u00e1lise de eventos em ambientes multivendor, com foco no uso do Elastic Stack e Fleet Management.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-ELK/#possiveis-aplicacoes","title":"Poss\u00edveis Aplica\u00e7\u00f5es:","text":"<ul> <li>Treinamento NOC/SOC multivendor \u2013 Simula\u00e7\u00e3o pr\u00e1tica de exporta\u00e7\u00e3o e an\u00e1lise de logs em ambiente Juniper, Huawei e Cisco.</li> <li>Valida\u00e7\u00e3o da coleta Syslog \u2013 Teste de compatibilidade e parsing de logs via Elastic Agents sem uso de Logstash.</li> <li>Visualiza\u00e7\u00e3o em tempo real \u2013 Cria\u00e7\u00e3o de dashboards no Kibana para eventos e m\u00e9tricas de rede.</li> <li>Monitoramento centralizado \u2013 Uso do Fleet para gerenciar agentes e pol\u00edticas de coleta de forma unificada.</li> <li>Ensino de integra\u00e7\u00e3o de observabilidade \u2013 Aplica\u00e7\u00e3o educacional sobre Syslog, Elastic Agents, Fleet, Elasticsearch e Kibana em redes multivendor.</li> </ul>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-ELK/#3-requisitos","title":"3. Requisitos","text":"<p>Abaixo est\u00e3o listados os requisitos m\u00ednimos de hardware e software necess\u00e1rios para executar o laborat\u00f3rio. Certifique-se de incluir as ferramentas essenciais, como Containerlab e Docker, al\u00e9m da rede <code>br-lab</code> previamente criada. para saber mais sobre este itens acesse:</p> <ul> <li>Cria\u00e7\u00e3o da Rede br-lab</li> <li>Instala\u00e7\u00e3o do Docker</li> <li>Instala\u00e7\u00e3o do containerlab</li> </ul> <p>E tenha a stack ELK previamente instalado e configurado para ingest\u00e3o de logs, para saber mais sobre a instala\u00e7\u00e3o acesse: Configurando Syslog no ELK</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-ELK/#tabela-de-requisitos-minimos","title":"Tabela de Requisitos Minimos:","text":"Requisito Detalhes CPUs 6 vCPUs Mem\u00f3ria RAM 16 GB Espa\u00e7o em Disco 20 GB (recomendado) Containerlab 0.45.0 ou superior Docker Engine 23.0.3 ou superior Imagens <code>vr-vjunos:23.2R1.14</code>, <code>vrnetlab/huawei_vrp:ne40e-8.180</code>, <code>xrd-control-plane:7.10.2</code> Rede Docker <code>br-lab</code> <p>Aten\u00e7\u00e3o</p> <p>Verifique se o seu processador possui suporte \u00e0 virtualiza\u00e7\u00e3o por hardware e se essa funcionalidade est\u00e1 ativada na BIOS/UEFI. - Em processadores Intel, essa tecnologia \u00e9 chamada de VT-x (Intel Virtualization Technology). - Em processadores AMD, \u00e9 conhecida como AMD-V (AMD Virtualization).  </p> <p>Sem essa funcionalidade ativada, as imagens como o vJunos-router n\u00e3o funcionar\u00e3o corretamente.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-ELK/#4-implantando-o-lab","title":"4. Implantando o Lab","text":"<p>Voc\u00ea pode realizar a implanta\u00e7\u00e3o por meio de um script pronto ou configurar manualmente os arquivos do lab.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-ELK/#41-implantacao-pronta","title":"4.1 Implanta\u00e7\u00e3o Pronta","text":"<p>Este m\u00e9todo permite ao usu\u00e1rio baixar uma vers\u00e3o pr\u00e9-montada do laborat\u00f3rio, com a topologia e as configura\u00e7\u00f5es j\u00e1 definidas. Basta baixar o reposit\u00f3rio e seguir para o in\u00edcio da execu\u00e7\u00e3o.</p> <p>Dica</p> <p>A implanta\u00e7\u00e3o pronta \u00e9 \u00fatil para quem deseja come\u00e7ar rapidamente com um ambiente configurado.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-ELK/#baixando-o-lab","title":"Baixando o Lab","text":"<p>Execute o script abaixo para baixar e configurar o laborat\u00f3rio automaticamente:</p> Linux/MacWindows <pre><code>curl -L -o get.sh \"https://git.rnp.br/redes-abertas/labs/-/raw/main/logs-elk-multvendor/get.sh\" &amp;&amp; sh get.sh &amp;&amp; cd logs-elk-multvendor\n</code></pre> <pre><code>curl -L -o get.bat \"https://git.rnp.br/redes-abertas/labs/-/raw/main/logs-elk-multvendor/get.bat\" &amp;&amp; call get.bat &amp;&amp; cd logs-elk-multvendor\n</code></pre> <p>Dica</p> <p>No Linux/Mac, use <code>chmod +x get.sh</code> antes de executar o script, caso ele n\u00e3o esteja com permiss\u00e3o de execu\u00e7\u00e3o.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-ELK/#5-inicializando-o-lab","title":"5. Inicializando o Lab","text":"<p>Ap\u00f3s o download ou personaliza\u00e7\u00e3o, siga as etapas abaixo para iniciar o laborat\u00f3rio. Execute o comando abaixo dentro do diret\u00f3rio baixado.</p> <pre><code>sudo containerlab deploy\n</code></pre> <p>Esse comando criar\u00e1 os containers dos roteadores, configurar\u00e1 os links e iniciar\u00e1 os servi\u00e7os de monitoramento.</p> <p>Depura\u00e7\u00e3o</p> <p>Use <code>docker logs -f &lt;nome_container&gt;</code> para verificar o estado dos servi\u00e7os, caso algo n\u00e3o funcione.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-ELK/#6-acesso-aos-dispositivos","title":"6. Acesso aos Dispositivos","text":""},{"location":"Laborat%C3%B3rios/Multivendor/Logs-ELK/#61-ips-e-portas-dos-servicos","title":"6.1 IPs e Portas dos Servi\u00e7os","text":"Dispositivo IP de Acesso Porta(s) Servi\u00e7o node1 172.10.10.201 22 SSH node2 172.10.10.202 22 SSH node3 172.10.10.203 22 SSH Fleet Server 172.10.10.110 8220 Ingest\u00e3o de dados Elasticsearch 172.10.10.108 9200 Banco de dados Kibana 172.10.10.109 5601 Interface Web Graphite 172.10.10.119 8080 Web UI (Graphite)"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-ELK/#62-senhas-de-acesso","title":"6.2 Senhas de Acesso","text":"Servi\u00e7o Usu\u00e1rio Senha node1 (SSH) <code>admin</code> <code>admin@123</code> node2 (SSH) <code>clab</code> <code>clab@123</code> node3 (SSH) <code>admin</code> <code>admin</code> Kibana <code>elastic</code> <code>admin@123</code> <p>Verifica\u00e7\u00e3o de Inicializa\u00e7\u00e3o</p> <p>Antes de acessar os servi\u00e7os, use <code>docker ps</code> e verifique os logs dos containers para garantir que est\u00e3o funcionando corretamente.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-ELK/#7-observabilidade-e-visualizacao","title":"7. Observabilidade e Visualiza\u00e7\u00e3o","text":"<p>Aten\u00e7\u00e3o</p> <p>Devido \u00e0 forma como as configura\u00e7\u00f5es s\u00e3o aplicadas no vJunos-router, a configura\u00e7\u00e3o do syslog deve ser feita manualmente. Siga o passo a passo abaixo para enviar todos os logs do sistema para o servidor de logs remoto.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-ELK/#passo-a-passo","title":"Passo a passo","text":"<p>Acesse o node1 via ssh e execute:</p> <pre><code>configure\n</code></pre> <ul> <li>Entra no modo de configura\u00e7\u00e3o do Junos.</li> <li>Todos os comandos seguintes v\u00e3o alterar a configura\u00e7\u00e3o do equipamento.</li> </ul> <pre><code>set system syslog host 172.10.10.110 any any\n</code></pre> <ul> <li>Define o servidor de logs remoto (172.10.10.110) como destino.</li> <li><code>any any</code> significa: enviar qualquer facility (sistema, kernel, daemon, auth etc.) em qualquer n\u00edvel de severidade (emergency, alert, critical, warning, info, debug).</li> <li>Na pr\u00e1tica: todos os eventos do sistema ser\u00e3o enviados para esse servidor.</li> </ul> <pre><code>set system syslog source-address 172.10.10.201\n</code></pre> <ul> <li>Define o IP de origem dos pacotes de log como 172.10.10.201 (o IP do vJunos-router).</li> <li>Isso garante que o tr\u00e1fego de syslog saia pela interface que possui esse endere\u00e7o.</li> <li>\u00c9 importante para o servidor de logs reconhecer corretamente a origem das mensagens.</li> </ul> <pre><code>commit\n</code></pre> <ul> <li>Aplica as altera\u00e7\u00f5es feitas na configura\u00e7\u00e3o.</li> </ul> <p>aten\u00e7\u00e3o</p> <p>Ap\u00f3s o inicio do Vjunos, pode levar entre 3 a 6 minutos para subir todas as rotas e a configura\u00e7\u00e3o funcionar corretamente.</p> <ul> <li>Somente ap\u00f3s esse comando os logs come\u00e7am a ser enviados para o destino configurado.</li> </ul> <p>Ao final da implata\u00e7\u00e3o voc\u00ea vera os logs no Kibana desta forma:</p> <p></p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-ELK/#71-elastic-agent","title":"7.1 Elastic Agent","text":"<p>O Elastic Agent \u00e9 respons\u00e1vel pela coleta e envio dos logs exportados via Syslog (UDP/514) pelos roteadores Juniper, Huawei e Cisco. Atua como agente unificado sob gerenciamento do Fleet Server, realizando o parsing, enriquecimento e encaminhamento dos dados diretamente ao Elasticsearch.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-ELK/#72-elasticsearch","title":"7.2 Elasticsearch","text":"<p>Banco de dados orientado a documentos utilizado para armazenar e indexar os logs coletados pelos agentes. Permite consultas, agrega\u00e7\u00f5es e correla\u00e7\u00f5es entre eventos de diferentes dispositivos. Acess\u00edvel pela porta 9200.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-ELK/#73-kibana","title":"7.3 Kibana","text":"<p>Interface web de an\u00e1lise e visualiza\u00e7\u00e3o dos logs armazenados no Elasticsearch. Permite a cria\u00e7\u00e3o de dashboards, consultas em tempo real e gerenciamento do Fleet. Acess\u00edvel em <code>https://&lt;seu IP ou localhost&gt;:5601</code>.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-ELK/#74-fleet-server","title":"7.4 Fleet Server","text":"<p>O Fleet Server \u00e9 executado no mesmo cont\u00eainer do Elastic Agent, unificando as fun\u00e7\u00f5es de coleta e gerenciamento. Gerencia os agentes Elastic, aplica pol\u00edticas de coleta, recebe logs via Syslog (UDP/514) e envia os dados ao Elasticsearch. Opera na porta 8220/TCP e \u00e9 administrado atrav\u00e9s do Kibana \u2192 Management \u2192 Fleet.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-Telegraf/","title":"Multvendor logs Telegraf","text":"<p>Este laborat\u00f3rio simula, via Containerlab, a interliga\u00e7\u00e3o entre tr\u00eas roteadores Juniper, Huawei e Cisco, com roteamento din\u00e2mico via OSPF, exporta\u00e7\u00e3o de logs via Syslog usando Telegraf, InfluxDB, Chronograf e Grafana.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#1-descricao","title":"1. Descri\u00e7\u00e3o","text":""},{"location":"Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#11-objetivo-do-lab","title":"1.1 Objetivo do Lab","text":"<p>O objetivo do laborat\u00f3rio \u00e9 simular a exporta\u00e7\u00e3o de logs de tr\u00eas roteadores de diferentes fabricantes (Juniper, Huawei e Cisco) para um servidor de monitoramento centralizado, utilizando o protocolo Syslog. O sistema de monitoramento \u00e9 composto por Telegraf, InfluxDB, Chronograf e Grafana, permitindo a coleta, armazenamento e visualiza\u00e7\u00e3o de m\u00e9tricas de rede em tempo real.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#12-topologia-do-lab","title":"1.2 Topologia do Lab","text":"<p>Descri\u00e7\u00e3o da Topologia</p> <ul> <li>Tr\u00eas roteadores (Juniper, Cisco, Huawei) interligados em topologia em anel com links ponto a ponto /31.</li> <li>Roteamento din\u00e2mico via OSPF entre os roteadores.</li> <li>Coleta de logs via Syslog udp (514).</li> <li>Observabilidade com a pilha TICK (Telegraf, InfluxDB, Chronograf) e Grafana.</li> <li>Rede externa <code>br-lab</code> conecta os n\u00f3s \u00e0 infraestrutura de monitoramento.</li> </ul>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#2-aplicacoes","title":"2. Aplica\u00e7\u00f5es","text":""},{"location":"Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#exemplos-de-aplicacoes","title":"Exemplos de Aplica\u00e7\u00f5es","text":"<p>Este laborat\u00f3rio pode ser explorado em diversos cen\u00e1rios acad\u00eamicos e de pesquisa aplicada, servindo como base para experimenta\u00e7\u00e3o de monitoramento e visualiza\u00e7\u00e3o de tr\u00e1fego em redes com m\u00faltiplos roteadores.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#possiveis-aplicacoes","title":"Poss\u00edveis Aplica\u00e7\u00f5es:","text":"<ul> <li>Treinamento de equipes de NOC em ambiente multivendor: Simula opera\u00e7\u00f5es reais com roteadores Juniper, Huawei e Cisco, utilizando OSPF e exporta\u00e7\u00e3o de logs via Syslog, permitindo an\u00e1lise de conectividade e resolu\u00e7\u00e3o de falhas.</li> <li>Valida\u00e7\u00e3o e testes de coleta de logs via Syslog: Permite verificar a compatibilidade e o comportamento de diferentes vendors no envio de logs para Telegraf.</li> <li>Visualiza\u00e7\u00e3o e an\u00e1lise de m\u00e9tricas em tempo real: Validar e testar formas de templates do grafana para trabalhar com logs.</li> <li>Monitoramento centralizado com Telegraf: Avalia a capacidade do Telegraf de receber e processar logs de dispositivos heterog\u00eaneos, garantindo integridade e consist\u00eancia dos dados.</li> <li>Ensino de integra\u00e7\u00e3o de sistemas de monitoramento: Proporciona aprendizado pr\u00e1tico sobre configura\u00e7\u00e3o de Syslog, coleta de m\u00e9tricas e visualiza\u00e7\u00e3o em pilhas TICK e Grafana em um cen\u00e1rio multivendor.</li> </ul>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#3-requisitos","title":"3. Requisitos","text":"<p>Abaixo est\u00e3o listados os requisitos m\u00ednimos de hardware e software necess\u00e1rios para executar o laborat\u00f3rio. Certifique-se de incluir as ferramentas essenciais, como Containerlab e Docker, al\u00e9m da rede <code>br-lab</code> previamente criada. para saber mais sobre este itens acesse:</p> <ul> <li>Cria\u00e7\u00e3o da Rede br-lab</li> <li>Instala\u00e7\u00e3o do Docker</li> <li>Instala\u00e7\u00e3o do containerlab</li> </ul> <p>E tenha a stack telegraf previamente instalado, para saber mais sobre a instala\u00e7\u00e3o do zabbix acesse: Instala\u00e7\u00e3o do Telegraf</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#tabela-de-requisitos-minimos","title":"Tabela de Requisitos Minimos:","text":"Requisito Detalhes CPUs 4 vCPUs Mem\u00f3ria RAM 8 GB Espa\u00e7o em Disco 10 GB (recomendado) Containerlab 0.45.0 ou superior Docker Engine 23.0.3 ou superior Imagens <code>vr-vjunos:23.2R1.14</code>, <code>vrnetlab/huawei_vrp:ne40e-8.180</code>, <code>xrd-control-plane:7.10.2</code> Rede Docker <code>br-lab</code> <p>Aten\u00e7\u00e3o</p> <p>Verifique se o seu processador possui suporte \u00e0 virtualiza\u00e7\u00e3o por hardware e se essa funcionalidade est\u00e1 ativada na BIOS/UEFI. - Em processadores Intel, essa tecnologia \u00e9 chamada de VT-x (Intel Virtualization Technology). - Em processadores AMD, \u00e9 conhecida como AMD-V (AMD Virtualization).  </p> <p>Sem essa funcionalidade ativada, as imagens como o vJunos-router n\u00e3o funcionar\u00e3o corretamente.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#4-implantando-o-lab","title":"4. Implantando o Lab","text":"<p>Voc\u00ea pode realizar a implanta\u00e7\u00e3o por meio de um script pronto ou configurar manualmente os arquivos do lab.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#41-implantacao-pronta","title":"4.1 Implanta\u00e7\u00e3o Pronta","text":"<p>Este m\u00e9todo permite ao usu\u00e1rio baixar uma vers\u00e3o pr\u00e9-montada do laborat\u00f3rio, com a topologia e as configura\u00e7\u00f5es j\u00e1 definidas. Basta baixar o reposit\u00f3rio e seguir para o in\u00edcio da execu\u00e7\u00e3o.</p> <p>Dica</p> <p>A implanta\u00e7\u00e3o pronta \u00e9 \u00fatil para quem deseja come\u00e7ar rapidamente com um ambiente configurado.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#baixando-o-lab","title":"Baixando o Lab","text":"<p>Execute o script abaixo para baixar e configurar o laborat\u00f3rio automaticamente:</p> Linux/MacWindows <pre><code>curl -L -o get.sh \"https://git.rnp.br/redes-abertas/labs/-/raw/main/logs-telegraf-multvendor/get.sh\" &amp;&amp; sh get.sh &amp;&amp; cd logs-telegraf-multvendor\n</code></pre> <pre><code>curl -L -o get.bat \"https://git.rnp.br/redes-abertas/labs/-/raw/main/logs-telegraf-multvendor/get.bat\" &amp;&amp; call get.bat &amp;&amp; cd logs-telegraf-multvendor\n</code></pre> <p>Dica</p> <p>No Linux/Mac, use <code>chmod +x get.sh</code> antes de executar o script, caso ele n\u00e3o esteja com permiss\u00e3o de execu\u00e7\u00e3o.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#5-inicializando-o-lab","title":"5. Inicializando o Lab","text":"<p>Ap\u00f3s o download ou personaliza\u00e7\u00e3o, siga as etapas abaixo para iniciar o laborat\u00f3rio. Execute o comando abaixo dentro do diret\u00f3rio baixado.</p> <pre><code>sudo containerlab deploy\n</code></pre> <p>Esse comando criar\u00e1 os containers dos roteadores, configurar\u00e1 os links e iniciar\u00e1 os servi\u00e7os de monitoramento.</p> <p>Depura\u00e7\u00e3o</p> <p>Use <code>docker logs -f &lt;nome_container&gt;</code> para verificar o estado dos servi\u00e7os, caso algo n\u00e3o funcione.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#6-acesso-aos-dispositivos","title":"6. Acesso aos Dispositivos","text":""},{"location":"Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#61-ips-e-portas-dos-servicos","title":"6.1 IPs e Portas dos Servi\u00e7os","text":"Dispositivo IP de Acesso Porta(s) Servi\u00e7o node1 172.10.10.201 22 SSH node2 172.10.10.202 22 SSH node3 172.10.10.203 22 SSH Telegraf 172.10.10.114 161 Coleta de m\u00e9tricas InfluxDB 172.10.10.112 8086 Banco de s\u00e9ries Chronograf 172.10.10.113 8888 UI de an\u00e1lise Grafana 172.10.10.111 3000 Dashboard Web Graphite 172.10.10.119 8080 Web UI (Graphite)"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#62-senhas-de-acesso","title":"6.2 Senhas de Acesso","text":"Servi\u00e7o Usu\u00e1rio Senha node1 (SSH) <code>admin</code> <code>admin@123</code> node2 (SSH) <code>clab</code> <code>clab@123</code> node3 (SSH) <code>admin</code> <code>admin</code> Grafana <code>admin</code> <code>admin</code> InfluxDB <code>admin</code> <code>influxpassword</code> <p>Verifica\u00e7\u00e3o de Inicializa\u00e7\u00e3o</p> <p>Antes de acessar os servi\u00e7os, use <code>docker ps</code> e verifique os logs dos containers para garantir que est\u00e3o funcionando corretamente.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#7-observabilidade-e-visualizacao","title":"7. Observabilidade e Visualiza\u00e7\u00e3o","text":"<p>Aten\u00e7\u00e3o</p> <p>Devido \u00e0 forma como as configura\u00e7\u00f5es s\u00e3o aplicadas no vJunos-router, a configura\u00e7\u00e3o do syslog deve ser feita manualmente. Siga o passo a passo abaixo para enviar todos os logs do sistema para o servidor de logs remoto.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#passo-a-passo","title":"Passo a passo","text":"<p>Acesse o node1 via ssh e execute:</p> <pre><code>configure\n</code></pre> <ul> <li>Entra no modo de configura\u00e7\u00e3o do Junos.</li> <li>Todos os comandos seguintes v\u00e3o alterar a configura\u00e7\u00e3o do equipamento.</li> </ul> <pre><code>set system syslog host 172.10.10.114 any any\n</code></pre> <ul> <li>Define o servidor de logs remoto (172.10.10.114) como destino.</li> <li><code>any any</code> significa: enviar qualquer facility (sistema, kernel, daemon, auth etc.) em qualquer n\u00edvel de severidade (emergency, alert, critical, warning, info, debug).</li> <li>Na pr\u00e1tica: todos os eventos do sistema ser\u00e3o enviados para esse servidor.</li> </ul> <pre><code>set system syslog source-address 172.10.10.201\n</code></pre> <ul> <li>Define o IP de origem dos pacotes de log como 172.10.10.201 (o IP do vJunos-router).</li> <li>Isso garante que o tr\u00e1fego de syslog saia pela interface que possui esse endere\u00e7o.</li> <li>\u00c9 importante para o servidor de logs reconhecer corretamente a origem das mensagens.</li> </ul> <pre><code>commit\n</code></pre> <ul> <li>Aplica as altera\u00e7\u00f5es feitas na configura\u00e7\u00e3o.</li> </ul> <p>aten\u00e7\u00e3o</p> <p>Ap\u00f3s o inicio do Vjunos, pode levar entre 3 a 6 minutos para subir todas as rotas e a configura\u00e7\u00e3o funcionar corretamente.</p> <ul> <li>Somente ap\u00f3s esse comando os logs come\u00e7am a ser enviados para o destino configurado.</li> </ul>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#71-telegraf","title":"7.1 Telegraf","text":"<p>O Telegraf est\u00e1 configurado para coletar m\u00e9tricas via:</p> <ul> <li>syslog: exporta\u00e7\u00e3o de logs </li> <li>IPFIX: exporta\u00e7\u00e3o de fluxos de tr\u00e1fego.</li> </ul>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#72-influxdb","title":"7.2 InfluxDB","text":"<p>Banco de s\u00e9ries temporais onde as m\u00e9tricas do Telegraf s\u00e3o armazenadas. Pode ser acessado pela porta 8086.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#73-chronograf","title":"7.3 Chronograf","text":"<p>Interface web de an\u00e1lise de m\u00e9tricas armazenadas no InfluxDB. Acess\u00edvel em <code>http://172.10.10.113:8888</code>.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#74-grafana","title":"7.4 Grafana","text":"<p>Plataforma de visualiza\u00e7\u00e3o interativa onde os dados s\u00e3o apresentados em dashboards personalizados.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/","title":"Multvendor Monitoramento Zabbix","text":"<p>Este laborat\u00f3rio, utilizando o Containerlab, simula a interconex\u00e3o de tr\u00eas roteadores de diferentes fabricantes: vJunos (Juniper), Huawei VRP e Cisco XRD. </p>"},{"location":"Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#1-descricao","title":"1. Descri\u00e7\u00e3o","text":""},{"location":"Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#11-objetivo-do-lab","title":"1.1 Objetivo do Lab","text":"<p>O laborat\u00f3rio \u201cMultvendor Monitoramento Zabbix\u201d demonstra a simula\u00e7\u00e3o da interconex\u00e3o de tr\u00eas roteadores de diferentes fabricantes \u2014 vJunos (Juniper), Huawei VRP e Cisco XRD \u2014 utilizando o Containerlab. Os dispositivos est\u00e3o interconectados em topologia em anel e o roteamento \u00e9 realizado pelo protocolo OSPF, permitindo a troca din\u00e2mica de rotas. A comunica\u00e7\u00e3o com o Zabbix ocorre via SNMP, possibilitando o monitoramento em tempo real.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#12-topologia-do-lab","title":"1.2 Topologia do Lab","text":"<p>A topologia deste laborat\u00f3rio \u00e9 composta por tr\u00eas roteadores interconectados em topologia em anel, permitindo comunica\u00e7\u00e3o direta entre os dispositivos. Cada roteador est\u00e1 configurado com OSPF, garantindo o roteamento din\u00e2mico entre as interfaces. O monitoramento \u00e9 realizado a partir de uma rede externa denominada br-lab, \u00e0 qual os roteadores est\u00e3o conectados por interfaces virtuais. Essa configura\u00e7\u00e3o possibilita que o Zabbix monitore a conectividade e o desempenho da rede em tempo real, utilizando SNMP como protocolo de coleta de m\u00e9tricas.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#2-aplicacoes","title":"2. Aplica\u00e7\u00f5es","text":""},{"location":"Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#exemplo-de-aplicacao","title":"Exemplo de Aplica\u00e7\u00e3o","text":"<p>Este laborat\u00f3rio pode ser utilizado em diversos contextos acad\u00eamicos e profissionais. Ele \u00e9 \u00fatil para simular cen\u00e1rios reais de opera\u00e7\u00e3o e monitoramento de redes, servindo como ambiente de valida\u00e7\u00e3o de configura\u00e7\u00f5es e testes de interoperabilidade entre protocolos de roteamento e ferramentas de monitoramento.</p> <p>Poss\u00edveis Aplica\u00e7\u00f5es:</p> <ul> <li>Treinamento de equipes de NOC (Network Operations Center):     Reproduz situa\u00e7\u00f5es reais de conectividade entre roteadores Juniper, Huawei e Cisco em topologia em anel, utilizando OSPF e SNMP, permitindo que t\u00e9cnicos aprendam a detectar, analisar e resolver falhas.</li> <li>Avalia\u00e7\u00e3o de interoperabilidade entre vendors: Permite testar como diferentes fabricantes interagem via OSPF, analisar converg\u00eancia de rotas e identificar inconsist\u00eancias na troca din\u00e2mica de informa\u00e7\u00f5es de roteamento.</li> <li>Valida\u00e7\u00e3o de templates SNMP no Zabbix: Ambiente controlado para validar, ajustar ou desenvolver templates de monitoramento SNMP para m\u00faltiplos fabricantes de roteadores, garantindo compatibilidade e precis\u00e3o na coleta de m\u00e9tricas.</li> <li>Ensino de protocolos de roteamento din\u00e2mico: Proporciona aprendizado pr\u00e1tico sobre configura\u00e7\u00e3o, manuten\u00e7\u00e3o e troca de rotas via OSPF em topologias ponto a ponto e em anel, incluindo an\u00e1lise de falhas e reconverg\u00eancia.</li> <li>Testes de monitoramento e descoberta autom\u00e1tica: Permite avaliar a funcionalidade de descoberta autom\u00e1tica de dispositivos via SNMP e o monitoramento de conectividade e desempenho em tempo real, simulando cen\u00e1rios variados de rede.</li> <li>Simula\u00e7\u00e3o de pol\u00edticas de rede e ACLs: Possibilita aplicar regras de filtragem de tr\u00e1fego e verificar seu impacto sobre a comunica\u00e7\u00e3o e monitoramento, com an\u00e1lise de logs e traps SNMP no Zabbix.</li> </ul>"},{"location":"Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#3-requisitos","title":"3. Requisitos","text":"<p>Abaixo est\u00e3o listados os requisitos m\u00ednimos de hardware e software necess\u00e1rios para executar o laborat\u00f3rio. Certifique-se de incluir as ferramentas essenciais, como Containerlab e Docker, al\u00e9m da rede <code>br-lab</code> previamente criada. para saber mais sobre este itens acesse:</p> <ul> <li>Cria\u00e7\u00e3o da Rede br-lab</li> <li>Instala\u00e7\u00e3o do Docker</li> <li>Instala\u00e7\u00e3o do containerlab</li> <li>E tenha o zabbix previamente instalado, para saber mais sobre a instala\u00e7\u00e3o do zabbix acesse: Instala\u00e7\u00e3o do Zabbix</li> </ul>"},{"location":"Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#tabela-de-requisitos-minimos","title":"Tabela de Requisitos Minimos:","text":"Requisito Detalhes CPUs 4 vCPUs Mem\u00f3ria RAM 8 GB Espa\u00e7o em Disco 10 GB (recomendado) Containerlab 0.45.0 Docker Engine 23.0.3 Imagens <code>vr-vjunos:23.2R1.14</code>, <code>vrnetlab/huawei_vrp:ne40e-8.180</code>, <code>xrd-control-plane:7.10.2</code> Rede Criada <code>br-lab</code> <p>Aten\u00e7\u00e3o</p> <p>Verifique se o seu processador possui suporte \u00e0 virtualiza\u00e7\u00e3o por hardware e se essa funcionalidade est\u00e1 ativada na BIOS/UEFI. - Em processadores Intel, essa tecnologia \u00e9 chamada de VT-x (Intel Virtualization Technology). - Em processadores AMD, \u00e9 conhecida como AMD-V (AMD Virtualization).  </p> <p>Sem essa funcionalidade ativada, as imagens como o vJunos-router n\u00e3o funcionar\u00e3o corretamente.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#4-implantando-o-lab","title":"4. Implantando o Lab","text":"<p>Aqui est\u00e3o as instru\u00e7\u00f5es para implantar o laborat\u00f3rio. Voc\u00ea pode optar por uma implanta\u00e7\u00e3o pronta ou uma customizada.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#41-implantacao-pronta","title":"4.1 Implanta\u00e7\u00e3o Pronta","text":"<p>Este m\u00e9todo permite ao usu\u00e1rio baixar uma vers\u00e3o pr\u00e9-montada do laborat\u00f3rio, com a topologia e as configura\u00e7\u00f5es j\u00e1 definidas. Basta baixar o reposit\u00f3rio e seguir para o in\u00edcio da execu\u00e7\u00e3o.</p> <p>Dica</p> <p>A implanta\u00e7\u00e3o pronta \u00e9 \u00fatil para quem deseja come\u00e7ar rapidamente com um ambiente configurado.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#baixando-o-lab","title":"Baixando o Lab","text":"<p>Para baixar o laborat\u00f3rio, execute o comando correspondente ao seu sistema operacional.</p> Linux/MacWindows <pre><code>curl -L -o get.sh \"https://git.rnp.br/redes-abertas/labs/-/raw/main/monitoramento-zabbix-multvendor/get.sh\" &amp;&amp; sh get.sh &amp;&amp; cd monitoramento-zabbix-multvendor\n</code></pre> <pre><code>curl -L -o get.bat \"https://git.rnp.br/redes-abertas/labs/-/raw/main/monitoramento-zabbix-multvendor/get.bat\" &amp;&amp; call get.bat &amp;&amp; cd monitoramento-zabbix-multvendor\n</code></pre> <p>Este comando far\u00e1 o download do script de instala\u00e7\u00e3o e o direcionar\u00e1 para o diret\u00f3rio do laborat\u00f3rio.</p> <p>Dica</p> <p>Antes de executar os scripts, verifique se as permiss\u00f5es de execu\u00e7\u00e3o est\u00e3o corretas (use <code>chmod +x get.sh</code> no Linux/Mac).</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#5-iniciando-o-lab","title":"5. Iniciando o Lab","text":"<p>Ap\u00f3s o download ou personaliza\u00e7\u00e3o, siga as etapas abaixo para iniciar o laborat\u00f3rio. Execute o comando abaixo dentro do diret\u00f3rio baixado.</p> <pre><code>sudo containerlab deploy\n</code></pre> <p>Esse comando iniciar\u00e1 a topologia definida no laborat\u00f3rio e criar\u00e1 todos os containers necess\u00e1rios.</p> <p>Dica</p> <p>Caso ocorra algum erro, verifique a sa\u00edda do comando para poss\u00edveis mensagens de erro. Use <code>docker logs &lt;container_name&gt;</code> para depurar.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#6-acesso","title":"6. Acesso","text":"<p>Ap\u00f3s o laborat\u00f3rio ser iniciado, voc\u00ea poder\u00e1 acessar os dispositivos e servi\u00e7os configurados na rede.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#61-tabela-de-ips-e-portas-de-servico","title":"6.1 Tabela de IPs e Portas de Servi\u00e7o","text":"<p>Aqui est\u00e1 um exemplo de tabela de dispositivos, IPs e portas de servi\u00e7o dispon\u00edveis no laborat\u00f3rio.</p> Dispositivo IP de Acesso Porta Servi\u00e7o node1 172.10.10.201 22 SSH node2 172.10.10.202 22 SSH node3 172.10.10.203 22 SSH Zabbix Server 172.10.10.115 10051 Zabbix Server Zabbix Frontend 172.10.10.116 880/443 Web UI (Zabbix) Zabbix Agent 172.10.10.117 10050 Zabbix Agent Zabbix Database 172.10.10.118 5432 PostgreSQL Graphite 172.10.10.119 8080 Web UI (Graphite)"},{"location":"Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#62-senhas-de-acesso","title":"6.2 Senhas de Acesso","text":"Servi\u00e7o Usu\u00e1rio Senha node1 (SSH) <code>admin</code> <code>admin@123</code> node2 (SSH) <code>clab</code> <code>clab@123</code> node3 (SSH) <code>admin</code> <code>admin</code> Zabbix (Web UI) <code>Admin</code> <code>zabbix</code> Zabbix Database <code>zabbix</code> <code>zabbixdatabase</code> <p>Aten\u00e7\u00e3o</p> <p>antes de acessar, acesse o log de um dispositivo para verificar se ele foi iniciado e configurado corretamente.</p>"},{"location":"Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#7-proximos-passos","title":"7.  Pr\u00f3ximos Passos","text":"<p>Ao iniciar o laborat\u00f3rio, o zabbix vai esta cru sem templates, para configura a descoberta automatica e os templates, acesse o Configurando Auto Discovery</p> <p>Aten\u00e7\u00e3o</p> <p>Atualmente a descoberta automatica s\u00f3 esta adicionando o template correto do juniper, para os outros fabricantes voc\u00ea deverar adicionar o template manualmente, </p>"},{"location":"en/","title":"Home","text":"<p>Welcome to the Open Networks project!</p> <p>This project aims to provide a solid foundation for configuring and simulating networks using modern and efficient tools: NetBox, Netreplica, and Containerlab.</p> <p>The Open Networks project was developed for networking professionals and enthusiasts who want to:</p> <ul> <li>Explore: Test different network configurations in a controlled environment.</li> <li>Automate: Use templates to standardize and automate network device configurations.</li> <li>Replicate: Reproduce real network environments in virtual labs for testing and validation.</li> <li>Manage: Centralize documentation and management of network infrastructures efficiently.</li> </ul> <p>With these tools, the project aims to simplify the creation, management, and documentation of complex network topologies, providing flexibility and scalability.</p>"},{"location":"en/#containerlab-capabilities","title":"Containerlab Capabilities","text":"<p>Containerlab is a powerful tool for creating and managing virtualized network labs using Docker containers. With it, you can test and simulate complex network topologies in a controlled environment. The tool supports various network devices, allowing the configuration of multivendor networks, which is ideal for testing interactions between different vendors in the same lab. Below is a list of the main vendors supported by Containerlab: </p>"},{"location":"en/#lab-workflow","title":"Lab Workflow","text":"<p>The flowchart illustrates the Netreplica workflow in the context of a network simulation environment, integrated with Containerlab:</p> <p></p>"},{"location":"en/#workflow-structure","title":"Workflow Structure","text":""},{"location":"en/#1-topology","title":"1. Topology","text":"<p>The network topology defines the structure and interconnection of network devices.</p>"},{"location":"en/#2-netbox","title":"2. NetBox","text":"<p>The topology is documented and managed in NetBox, a centralized platform for network infrastructure management. NetBox stores detailed information about devices, IP addresses, and physical connections.</p>"},{"location":"en/#3-netreplica","title":"3. Netreplica","text":"<p>Netreplica synchronizes configuration information from NetBox and prepares the data for simulation. It retrieves data via API and generates YAML configuration files needed for simulation.</p>"},{"location":"en/#4-configurations","title":"4. Configurations","text":"<p>Netreplica generates detailed YAML configuration files that describe how network devices should be configured.</p>"},{"location":"en/#5-containerlab","title":"5. Containerlab","text":"<p>Containerlab uses the generated configuration files to create and manage complex network topologies in Docker containers.</p>"},{"location":"en/#6-lab-docker-stack","title":"6. Lab (Docker Stack)","text":"<p>The simulation is executed in a lab environment using a Docker stack. The defined topology is reproduced, allowing tests and validations.</p>"},{"location":"en/#7-graphite","title":"7. Graphite","text":"<p>To monitor and visualize simulation metrics and performance, Graphite is integrated into the lab. It collects and displays relevant data for analysis.</p>"},{"location":"en/#workflow-summary","title":"Workflow Summary","text":"<ol> <li>Topology Definition: The structure and interconnection of network devices are defined.</li> <li>Documentation in NetBox: The topology is documented and managed in NetBox.</li> <li>Synchronization with Netreplica: Netreplica synchronizes information from NetBox via API and generates YAML configurations.</li> <li>Topology Creation with Containerlab: Containerlab uses YAML configurations to create the network topology in Docker containers.</li> <li>Simulation Execution: The topology is executed in a Docker lab environment.</li> <li>Monitoring with Graphite: The simulation's performance and metrics are monitored and visualized with Graphite.</li> </ol>"},{"location":"en/#project-status","title":"Project Status","text":"<p>Project in progress.</p>"},{"location":"en/#getting-started","title":"Getting Started","text":"<p>To get started, read the Configuration Guide to learn how to use NetBox, Containerlab, and Netreplica tools together.</p>"},{"location":"en/#available-labs","title":"Available Labs","text":"<ul> <li>OSPF Routing - OSPF Configuration Lab based on Juniper's MX platform in a ring topology.</li> <li>Discovery - Network device discovery lab using OSPF and SNMP, integrating Zabbix and NetBox.</li> <li>ELK Monitoring - IPFIX flow monitoring lab using the Elastic Stack (Elasticsearch, Kibana, Fleet Server, and Elastic Agent).</li> <li>Telegraf Monitoring - Traffic flow monitoring lab via Telegraf/IPFIX to InfluxDB.</li> <li>Zabbix Monitoring - Router monitoring lab via SNMP with centralized collection by Zabbix Server.</li> <li>NETCONF Configuration - Device configuration lab via NETCONF.</li> </ul>"},{"location":"en/#tools","title":"Tools","text":"<ul> <li>NetBox: Tool for network infrastructure management</li> <li>Containerlab: Tool for simulating complex network topologies</li> <li>Netreplica: Tool for replicating network environments from NetBox to Containerlab</li> <li>ELK: Stack for monitoring logs and data streams in real-time</li> <li>Edgeshark: Tool for capturing and visualizing network traffic</li> <li>LibreNMS: Tool for monitoring network devices</li> </ul>"},{"location":"en/#contribute","title":"Contribute","text":"<p>Contribute to the project by clicking here.</p>"},{"location":"en/Contribua/","title":"Contribute","text":""},{"location":"en/Contribua/#tools","title":"Tools","text":"<p>This project was developed using the following tools:</p> <ul> <li>poetry for dependency management</li> <li>taskpy for task automation</li> <li>mkdocs for documentation</li> <li>mkdocs-material for documentation theme</li> <li>commitizen for standardizing commit messages</li> </ul>"},{"location":"en/Contribua/#how-to-contribute","title":"How to Contribute","text":"<p>First of all, thank you for being part of this project! Your help is very welcome.</p> <p>To contribute to the project, follow the steps below:</p> <ol> <li>Clone the repository to your local machine:</li> </ol> <pre><code>git clone https://git.rnp.br/redes-abertas/docs.git\n</code></pre> <ol> <li>Install project dependencies:</li> </ol> <p>First, install pipx to install poetry, documentation here</p> <p>Now, install poetry, which is the project's dependency manager:</p> <pre><code>pipx install poetry\n</code></pre> <p>Now, inside the project folder, install the project dependencies:</p> <pre><code>poetry install\n</code></pre> <p>Done, now you have all the project dependencies installed.</p>"},{"location":"en/Contribua/#folder-structure","title":"Folder Structure","text":"<p>The project is organized as follows:</p> <pre><code>flowchart TD\n    A[./] --&gt; B[docs]\n    B --&gt; C[pt]\n    B --&gt; D[en]\n    B --&gt; E[img]\n    C --&gt; F[Ferramentas]\n    C --&gt; G[Guias]\n    C --&gt; H[inventarios]\n    C --&gt; I[Laborat\u00f3rios]\n    C --&gt; J[Templates]</code></pre> <p>Where each folder has the following function:</p> <ul> <li><code>docs</code>: contains the project documentation, written in Markdown.</li> <li><code>pt</code>: contains the documentation in Portuguese.</li> <li><code>en</code>: contains the documentation in English.</li> <li><code>img</code>: contains the images used in the documentation.</li> <li><code>Ferramentas</code>: contains the tools that have been tested and documented in the labs.</li> <li><code>Guias</code>: contains the configuration guides for the labs and more specific uses of the labs.</li> <li><code>inventarios</code>: contains the lab inventories in the Netbox import format.</li> <li><code>Laborat\u00f3rios</code>: contains the labs that have been tested and documented in network topologies.</li> <li><code>Templates</code>: contains the Netreplica templates for vendors not yet supported by default.</li> </ul>"},{"location":"en/Contribua/#docs","title":"docs","text":"<p>The project documentation is written in Markdown and is located in the docs folder. To contribute, edit the existing Markdown files or create new ones, following the established folder and file structure. Each file should include a title and a description, making it a page of the documentation.</p> <p>The folder structure should follow the pattern of the corresponding section name, with an index.md file for the section's home page. Other necessary pages should also be in Markdown. The site organization is done automatically by MkDocs.</p> <p>Example:</p> <pre><code>docs/\n    \u251c\u2500\u2500 Se\u00e7\u00e3o/\n    \u2502   \u251c\u2500\u2500 index.md\n</code></pre>"},{"location":"en/Contribua/#get-your-hands-dirty","title":"Get Your Hands Dirty","text":"<p>Now that you have the dependencies installed and understand how poetry works, you can start contributing to the code, following are some tips for contributing to the project as well as using the project's automation and standardization tools.</p> <p>Tip</p> <p>Before you start editing the code, it is important to enter the poetry virtual environment. To do this, run the following command:</p> <p>Attention</p> <p>After the poetry update of 2025, the <code>poetry shell</code> command was transferred to a plugin, to work, run the following command: <pre><code>poetry self add poetry-plugin-shell\n</code></pre></p> <pre><code>poetry shell\n</code></pre>"},{"location":"en/Contribua/#tools_1","title":"Tools","text":"<p>The project has some automation and standardization tools, such as <code>taskpy</code> and <code>black</code>, which are used to automate tasks and standardize the code, respectively.</p>"},{"location":"en/Contribua/#automatic-translation","title":"Automatic Translation","text":"<p>The <code>task translate</code> command is responsible for translating the Markdown files located in the <code>docs/pt</code> folder to the English language and saving the translations in <code>docs/en</code> using the Gemini 2.0 Flash model to perform the translation. It ensures that the content is translated accurately without altering the structure of the documentation and keeping all references and links intact.</p>"},{"location":"en/Contribua/#how-to-configure-and-use-file-translation","title":"How to configure and use file translation","text":"<p>The following are instructions for properly configuring the environment and performing translations.</p>"},{"location":"en/Contribua/#step-1-obtain-the-gemini-api-key","title":"Step 1: Obtain the Gemini API Key","text":"<p>To use the Gemini translation model, you need to obtain a free API key. Follow the steps below:</p> <ol> <li>Go to Google AI Studio.</li> <li>Log in to a valid Google account.</li> <li>Click Create API key.</li> <li>Copy the generated key to use in the project.</li> </ol> <p>Info</p> <p>More about the Google Gemini API implementation can be found in the Official Documentation.</p>"},{"location":"en/Contribua/#step-2-configure-the-env-file","title":"Step 2: Configure the <code>.env</code> file","text":"<p>In the project directory, you will find a file called <code>.env.example</code>. It will serve as a template to create your <code>.env</code> file containing sensitive settings, such as the API key.</p> <ol> <li>Make a copy of the <code>.env.example</code> file and rename it to <code>.env</code>:</li> </ol> <pre><code>cp .env.example .env\n</code></pre> <ol> <li>Open the <code>.env</code> file in any text editor and enter the Gemini key:</li> </ol> <pre><code>GEMINI_API_KEY=your-key-here\n</code></pre> <p>Replace <code>your-key-here</code> with the key obtained in Step 1.</p>"},{"location":"en/Contribua/#step-3-run-the-translation","title":"Step 3: Run the translation","text":"<p>After configuring the API key in the <code>.env</code> file, simply run the command below to start the translation:</p> <pre><code>poetry run task translate\n</code></pre> <p>This command will: - Translate all Markdown files (.md) found in <code>docs/pt</code>. - Create and save the translations in the <code>docs/en</code> folder, maintaining the same directory structure as the source folder.</p> <p>Note</p> <p>The command will ignore files that are already translated and have not been changed.</p> <p>Attention</p> <ul> <li>The command does not translate folder names currently. Only the content of the files will be translated.</li> <li>All links and internal references in the documentation will be maintained correctly, without unwanted changes.</li> </ul>"},{"location":"en/Contribua/#additional-functionality-change-detection","title":"Additional functionality: Change detection","text":"<p>The script checks if there have been any modifications to the original files before performing a new translation. This ensures that:</p> <ul> <li>Only files that have not been translated or that have been changed will have the translation updated.</li> <li>Already translated files will remain unchanged if there is no need for translation.</li> </ul> <p>About the translation</p> <p>The translation uses the Gemini 2.0 Flash model, which performs highly accurate and reliable translation. However, as automatic models are subject to error depending on the context, a final review of the translated content is always recommended.</p>"},{"location":"en/Contribua/#tips-for-contributing-to-the-translation","title":"Tips for contributing to the translation","text":"<ul> <li>Edit the original files (in <code>docs/pt</code>) whenever you make changes to the documentation.</li> <li>After making changes, run the <code>task translate</code> command again to update the translated content in English.</li> </ul> <p>With this, the translation of your documentation will always be synchronized with the original language.</p>"},{"location":"en/Contribua/#documentation","title":"Documentation","text":"<p>The project documentation is written in Markdown and is located in the docs folder, following the structure of existing folders, subfolders and files. where all standardization is recommended by mkdocs and mkdocs-material, so to view the documentation locally, run the following command:</p> <pre><code>poetry run task docs\n</code></pre> <p>Tip</p> <p>To contribute to the documentation, you can edit the Markdown files directly or create new files as needed, following the structure of existing folders, subfolders and files.</p> <p>Tip</p> <p>You can use any feature available in mkdocs for customizations, to learn more access the documentation below:</p> <p>Useful links:</p> <ul> <li>mkdocs-admonitions: documentation for admonitions (documentation annotations)</li> <li>mkdocs-emojis : documentation for emojis</li> <li>mermaid : documentation for mermaid (markdown flowchart)</li> </ul>"},{"location":"en/Contribua/#commits","title":"Commits","text":"<p>The project uses <code>commitizen</code> to standardize commit messages. To create a commit, run the following command:</p> <p>Observation</p> <p>You must be inside the poetry virtual environment, if not, run the following command:  <pre><code>poetry shell\n</code></pre></p> <pre><code>poetry run task commit\n</code></pre> <p>Now just fill in the requested information and the commit will be made in a standardized way. After the commit, you can push to the remote repository.</p>"},{"location":"en/Contribua/#i-didnt-find-what-i-need-here","title":"I didn't find what I need here","text":"<p>If you haven't found what you need, you can open an issue in the project reporting what you can't do or what needs to be better documented.</p>"},{"location":"en/Contribua/#continuous-improvement","title":"Continuous Improvement","text":"<p>This document can be improved by anyone who is interested in improving it. So, feel free to provide more tips to people who also want to contribute </p> <p>without altering the structure of the documentation. and without adding anything and not altering the links or references.</p>"},{"location":"en/Getting%20Started/","title":"Getting started","text":"<p>This comprehensive guide will walk you through setting up a network simulation environment using Netbox, Containerlab, and Netreplica.</p>"},{"location":"en/Getting%20Started/#prerequisites","title":"Prerequisites:","text":"<ul> <li>Basic knowledge in:<ul> <li>Linux and SSH (Recommended course: Introduction to Linux)</li> <li>Basic Docker (Recommended course: Docker for Beginners)</li> </ul> </li> </ul>"},{"location":"en/Getting%20Started/#steps","title":"Steps:","text":""},{"location":"en/Getting%20Started/#1-installing-netbox","title":"1. Installing Netbox:","text":"<p>Netbox is a centralized platform for network infrastructure management, providing detailed documentation of devices, IP addresses, and physical connections. It allows the creation of configuration templates using Jinja2, facilitating automation and standardization in the configuration of devices such as routers and switches. This capability is essential for maintaining organized network simulation environments ready to scale as needed.</p> <ul> <li>Official Documentation: NetboxLabs</li> <li>Installation Guide: NetBox Installation and Imports</li> <li>Summary:<ul> <li>Make sure you have Docker installed on your machine.</li> <li>Download the official Netbox repository to your machine.</li> <li>Configure Netbox by accessing the .env file.</li> <li>Run the compose file.</li> </ul> </li> </ul>"},{"location":"en/Getting%20Started/#2-installing-containerlab","title":"2. Installing Containerlab:","text":"<p>Containerlab is responsible for simplifying the creation and management of complex network topologies using Docker containers. It allows defining and interconnecting virtualized network devices efficiently, facilitating the configuration of simulation and network testing environments. This Docker-based approach simplifies the replication of real-world environments in virtual labs, providing flexibility and scalability in network infrastructure configuration.</p> <ul> <li>Official Documentation: Containerlab</li> <li>Summary:<ul> <li>Install Docker and Docker Compose.</li> <li>Download the Containerlab binary and add it to your PATH.</li> </ul> </li> </ul>"},{"location":"en/Getting%20Started/#3-installing-netreplica","title":"3. Installing Netreplica:","text":"<p>Netreplica synchronizes data from Netbox into simulation environments using Docker containers. It allows testing configurations without affecting the production environment, ensuring data and configuration consistency between different network scenarios.</p> <ul> <li>Official Documentation: Netreplica</li> <li>Installation Guide: NetReplica Installation via Docker</li> <li>Summary:<ul> <li>Use Docker Compose to start Netreplica in a Docker container.</li> <li>Configure Netreplica to synchronize with Netbox.</li> </ul> </li> </ul>"},{"location":"en/Getting%20Started/#4-configuring-and-running-netreplica-with-netbox","title":"4. Configuring and Running NetReplica with Netbox:","text":"<p>Now we will detail the configuration process to integrate Netreplica with Netbox. This step is crucial to ensure that Netbox data and configurations are replicated correctly in simulation or test environments using Netreplica.</p> <ul> <li>Official Documentation: Netreplica how to use</li> <li>Configuration Guide: NetReplica Configuration Guide</li> <li>Summary:<ul> <li>Create an API token in Netbox for Netreplica.</li> <li>Configure Netreplica to use the API token and Netbox URL.</li> <li>Start Netreplica and verify that it is synchronizing with Netbox.</li> </ul> </li> </ul>"},{"location":"en/Getting%20Started/#5-creating-and-configuring-templates-in-netbox","title":"5. Creating and Configuring Templates in Netbox:","text":"<p>Device configuration templates are essential to provide the necessary configurations to Netreplica, which will later be applied to network simulations.</p> <ul> <li>Official Documentation: Netbox Configuration Rendering</li> <li>Configuration Guide: Creating Configuration Templates</li> <li>Summary:<ul> <li>Create configuration templates for network devices, such as routers and switches.</li> <li>Use Jinja2 to create dynamic templates that adapt to your topologies.</li> </ul> </li> </ul>"},{"location":"en/Ferramentas/","title":"Tools","text":""},{"location":"en/Ferramentas/#introduction","title":"Introduction","text":"<p>Before you start using the monitoring tools, it is crucial to configure the communication base between your laboratories. For this, we use a dedicated Docker network called br-lab. The br-lab network facilitates the integration of analysis tools with the laboratories created in Containerlab, eliminating the need to repeatedly configure each tool for different laboratories.</p>"},{"location":"en/Ferramentas/#step-1-configuring-the-br-lab-docker-network","title":"Step 1: Configuring the br-lab Docker Network","text":"<p>Access the br-lab Network Configuration Guide to configure your Docker network. This network will be responsible for efficiently connecting your laboratories to the monitoring system, allowing multiple tools to function in an integrated manner.</p>"},{"location":"en/Ferramentas/#step-2-choosing-a-monitoring-tool","title":"Step 2: Choosing a Monitoring Tool","text":"<p>After configuring the br-lab network, you can select the tool that best suits your needs. Each of the tools listed below offers specific functionalities for different types of monitoring, whether it is network devices, traffic, or logs.</p>"},{"location":"en/Ferramentas/#tool-comparison","title":"Tool Comparison","text":"<p>The following table provides an overview of the tools we cover in our tutorials, highlighting their main features, type of monitoring, and pricing options:</p>"},{"location":"en/Ferramentas/#table-monitoring-tool-comparison","title":"Table: Monitoring Tool Comparison","text":"Tools Collection and Integration Technologies Cost Implementation Difficulty Integrations Strengths Community/Documentation Zabbix SNMP, ICMP, JMX, IPMI, API_rest, Agent, Free Easy Grafana, prometheus,elastic, kafka, Graylog, ..etc Advanced alerts Complete ELK Stack Syslog, IPFIX , Netflow, SNMP, ICMP Freemium Moderate Fleet, logstash, filebeat, grafana, .etc Centralized log analysis, Ready-made dashboards Complete Telegraf + InfluxDB + Grafana SNMP, IPFIX, SFLOW, Syslog, gMNIC, Netflow, GRPC, etc Freemium Moderate Prometheus, Loki, Modular and scalable stack Extensive LibreNMS SNMP, Syslog, API_Rest Free Easy Grafana, Graylog, Proxmox Autodiscovery Medium"},{"location":"en/Ferramentas/#step-3-implementation-and-testing","title":"Step 3: Implementation and Testing","text":"<p>After selecting the most suitable tool, follow the specific tutorials to configure and integrate the chosen solution with your network environment created in Containerlab. Each guide offers step-by-step instructions to ensure a smooth and functional integration of the monitoring tools with your laboratories.</p>"},{"location":"en/Ferramentas/#test-scenario-examples","title":"Test Scenario Examples:","text":"<ul> <li>Monitoring Network Devices with LibreNMS: Configure LibreNMS to monitor switches and routers within your laboratory.</li> <li>Log and Event Analysis with ELK Stack: Collect and visualize log data generated by network devices.</li> <li>Packet Capture with EDSHARK: Perform network diagnostics and analyze captured packets directly from routers.</li> </ul>"},{"location":"en/Ferramentas/#br-lab-network-configuration-and-fixed-addresses","title":"br-lab Network Configuration and Fixed Addresses","text":"<p>All tools are configured to be attached to the br-lab network, and to facilitate their use, regardless of the laboratory, they have fixed IPs. These IPs can be consulted in the list below, allowing you to connect directly to each tool without the need for additional configurations for each new laboratory.</p>"},{"location":"en/Ferramentas/#table-fixed-ips-of-the-tools","title":"Table: Fixed IPs of the Tools","text":"Service IP Stack librenms-db 172.10.10.100 librenms librenms-redis 172.10.10.101 librenms librenms-msmtpd 172.10.10.102 librenms librenms-librenms 172.10.10.103 librenms librenms-dispatcher 172.10.10.104 librenms librenms-syslogng 172.10.10.105 librenms librenms-snmptrapd 172.10.10.106 librenms elk-setup 172.10.10.107 ELK elk-elasticsearch 172.10.10.108 ELK elk-kibana 172.10.10.109 ELK elk-fleet-server 172.10.10.110 ELK grafana-grafana 172.10.10.111 Grafana grafana-influxdb 172.10.10.112 Grafana grafana-chronograf 172.10.10.113 Grafana grafana-telegraf 172.10.10.114 Grafana zabbix-server 172.10.10.115 Zabbix zabbix-frontend 172.10.10.116 Zabbix zabbix-agent 172.10.10.117 Zabbix zabbix-database 172.10.10.118 Zabbix <p>These fixed IPs ensure stable and facilitated communication between the tools and the laboratories configured in Containerlab. This allows you to efficiently integrate multiple monitoring tools without having to redefine network configurations for each new laboratory.</p> <p>This addition includes the Docker network configuration, the explanation about the fixed IPs, and how they facilitate the integration of tools in your laboratory environment.</p>"},{"location":"en/Ferramentas/#future-tools","title":"Future Tools","text":"<p>We are constantly testing and adding new tools to our repertoire. Some options we are considering exploring soon include:</p> <ul> <li>Prometheus: Monitoring and data visualization server.</li> <li>OpenElastic: A scalable and flexible solution for auditing logs and events, based on the Elastic Stack.</li> <li>OpenNMS: Robust tool for monitoring networks and systems, with a focus on large-scale networks.</li> <li>Akivorado: Data flow monitoring tool for networks.</li> </ul> <p>These tools can be integrated into your laboratory environment with Containerlab, allowing you to create a robust ecosystem for network management and analysis.</p>"},{"location":"en/Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/","title":"Getting Started: Preparing the Environment","text":""},{"location":"en/Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#1-introduction","title":"1. Introduction","text":"<p>In this guide, we will cover the initial steps to prepare the monitoring environment using the Docker br-lab network. This network was created to facilitate access, monitoring, and use of analysis tools in laboratories managed by Containerlab. Configuring the br-lab network is a necessary step for using most of the tools that will be shown in this guide. After configuring the monitoring tools on the br-lab network, they can be used in any laboratory, eliminating the need for reconfiguration with each new environment. This simplifies testing multiple configurations and allows the use of various analysis tools more efficiently.</p>"},{"location":"en/Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#advantages","title":"Advantages:","text":"<ul> <li>Single configuration: Monitoring tools only need to be configured once, regardless of the laboratory in use.</li> <li>Ease of testing: Enables the creation and testing of various laboratory configurations without the need for continuous adjustments to the tools.</li> <li>Flexible integration: Allows you to easily add new laboratories and devices to the network without impacting the already configured infrastructure.</li> </ul>"},{"location":"en/Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#examples-of-laboratories-using-the-br-lab-network","title":"Examples of Laboratories Using the br-lab Network","text":""},{"location":"en/Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#monitoring-network-diagram","title":"Monitoring Network Diagram","text":"<p>Below is a visual example that shows how the <code>br-lab</code> monitoring network is configured, connecting different laboratories and devices for a unified and efficient testing environment. </p>"},{"location":"en/Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#2-creating-the-docker-network","title":"2. Creating the Docker Network","text":""},{"location":"en/Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#command-to-create-the-network","title":"Command to Create the Network:","text":"<pre><code>docker network create \\\n  --driver=bridge \\\n  --opt com.docker.network.bridge.name=br-lab \\\n  --subnet=172.10.10.0/24 \\\n  br-lab\n</code></pre>"},{"location":"en/Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#parameter-explanation","title":"Parameter Explanation:","text":"<ul> <li><code>docker network create</code>: Starts the creation of a new Docker network.</li> <li><code>-driver=bridge</code>: Specifies the network driver (bridge).</li> <li><code>-opt com.docker.network.bridge.name=br-lab</code>: Defines the name of the bridge network interface on the host.</li> <li><code>-subnet=172.10.10.0/24</code>: Defines the subnet (up to 254 IPs available).</li> <li><code>br-lab</code>: Network name.</li> </ul>"},{"location":"en/Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#3-adding-containers-to-the-network","title":"3. Adding Containers to the Network","text":""},{"location":"en/Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#using-docker-run","title":"Using Docker Run:","text":"<p>Command to add a container to the network:</p> <pre><code>docker run -d \\\n  --name meu_container \\\n  --network br-lab \\\n  imagem_do_container\n</code></pre>"},{"location":"en/Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#parameter-explanation_1","title":"Parameter Explanation:","text":"<ul> <li><code>docker run -d</code>: Runs the container in the background.</li> <li><code>-name meu_container</code>: Container name.</li> <li><code>-network br-lab</code>: Connects the container to the <code>br-lab</code> network.</li> <li><code>imagem_do_container</code>: Specifies the container image to be used.</li> </ul>"},{"location":"en/Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#using-docker-compose","title":"Using Docker Compose:","text":"<p>If the network has already been created, use Docker Compose to configure containers with static IPs.</p> <pre><code>version: '3.8'\n\nnetworks:\n  br-lab:\n    external: true\n\nservices:\n  meu_container:\n    image: imagem_do_container\n    networks:\n      br-lab:\n        ipv4_address: 172.10.10.101 # optional for static ip\n</code></pre> <p>Attention</p> <p>When using static ips, be sure to use ips after <code>172.10.10.100</code> in order to avoid conflicts with existing containers.</p>"},{"location":"en/Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#configuration-explanation","title":"Configuration Explanation:","text":"<ul> <li><code>networks</code>: Defines the networks that the services will use.</li> <li><code>br-lab</code>: Indicates that the network has already been created externally (external: true).</li> <li><code>services</code>: Defines the containers to be executed.</li> <li><code>ipv4_address</code>: Assigns a static IP to the container (recommended to use addresses after <code>172.10.10.100</code>).</li> </ul>"},{"location":"en/Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#4-network-operation","title":"4. Network Operation","text":"<p>The <code>br-lab</code> network uses the <code>bridge</code> driver, which allows internal communication between containers, keeping them isolated from the host system. This offers:</p> <ul> <li>Isolation: Containers do not interfere with other host processes.</li> <li>Internal communication: Containers can communicate using IPs in the specified subnet.</li> </ul>"},{"location":"en/Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#5-connecting-routers-with-virtual-cables","title":"5. Connecting Routers with Virtual Cables","text":"<p>To connect routers in the <code>br-lab</code> network using virtual cables via Containerlab, you can configure the connections between interfaces.</p>"},{"location":"en/Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#connection-example","title":"Connection Example:","text":"<pre><code>br-lab:\n  kind: bridge\n\nlinks:\n  - endpoints: [\"route1:eth1\", \"br-lab:eth1\"]\n  - endpoints: [\"route2:eth1\", \"br-lab:eth2\"]\n  - endpoints: [\"route3:eth1\", \"br-lab:eth3\"]\n  - endpoints: [\"route4:eth1\", \"br-lab:eth4\"]\n</code></pre>"},{"location":"en/Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#connection-explanation","title":"Connection Explanation:","text":"<ul> <li>Each line defines a \u201cvirtual cable\u201d connecting two network interfaces (for example, <code>route1:eth1</code> is connected to <code>br-lab:eth1</code>).</li> <li>This allows communication between devices (routers and monitoring tools) through these interfaces.</li> </ul>"},{"location":"en/Ferramentas/Primeiros%20passos%20-%20preparando%20o%20ambiente/#6-conclusion","title":"6. Conclusion","text":"<p>With this guide, you have learned how to create and use the Docker <code>br-lab</code> network, how to add containers to the network, and how to connect routers virtually. This configuration is ideal for efficient monitoring in laboratory environments.</p>"},{"location":"en/Ferramentas/Edgeshark/","title":"Edgeshark Installation and Usage Guide","text":""},{"location":"en/Ferramentas/Edgeshark/#1-introduction","title":"1. Introduction","text":"<p>Edgeshark is an innovative solution designed to facilitate the capture and analysis of network traffic in containerized environments. It consists of two main containerized services, Ghostwire and Packetflix, which work together to monitor network traffic within Docker containers. In addition, it offers an optional plugin for Wireshark, called csharg external capture plugin, which allows remote live capture of network traffic.</p>"},{"location":"en/Ferramentas/Edgeshark/#2-installing-edgeshark","title":"2. Installing Edgeshark","text":"<p>Edgeshark offers multi-architecture Docker images for the <code>linux/amd64</code> and <code>linux/arm64</code> architectures.</p> <p>WARNING</p> <p>Make sure you have a Linux kernel of at least version 4.11 installed. However, we strongly recommend using version 5.6 or higher.</p> Using Docker Compose v2Using BashUsing Industrial Edge <ol> <li>Install Docker Compose v2:</li> </ol> <p>Make sure the Docker Compose v2 plugin is installed. Verify by running <code>docker compose version</code>, which should display the plugin version without errors. For Debian users, we recommend installing the <code>docker-ce</code> packages instead of <code>docker.io</code>, as they are updated more frequently.</p> <ol> <li>Deploying Edgeshark services:</li> </ol> <p>Copy and paste the command below into a terminal to deploy the services:</p> <pre><code>wget -q --no-cache -O - \\\nhttps://github.com/siemens/edgeshark/raw/main/deployments/wget/docker-compose-localhost.yaml \\\n| DOCKER_DEFAULT_PLATFORM= docker compose -f - up\n</code></pre> <ol> <li> <p>Access the interface:</p> <p>After deployment, visit http://localhost:5001 in your browser to explore the virtual network of your container host.</p> </li> </ol> <p>NOTE</p> <p>Using DOCKER_DEFAULT_PLATFORM= ensures correct deployment of multi-architecture images and avoids issues, especially with Apple's Rosetta, which may have difficulties with read-only image deployments.</p> <p>WARNING</p> <p>The following quick deployments will expose TCP port 5001 (or 5500) to clients external to your host. Make sure your network is properly protected.</p> <p>If your system does not support Docker Compose v2, you can use a Bash script as an alternative.</p> <ol> <li>Deployment via Bash:</li> </ol> <p>Execute the command below to deploy the services using a Bash script:</p> <pre><code>wget -q --no-cache -O - \\\\\n  &lt;https://github.com/siemens/edgeshark/raw/main/deployments/nocomposer/edgeshark.sh&gt; \\\\\n  | DOCKER_DEFAULT_PLATFORM= bash -s up\n</code></pre> <ol> <li> <p>Access the interface:</p> <p>Visit http://localhost:5001 in your browser to explore the virtual network of your container host.</p> </li> </ol> <p>WARNING</p> <p>This quick deployment will expose TCP port 5001 to clients external to your host. Make sure your network is properly protected.</p> <ol> <li> <p>Download the Edgeshark application:</p> <p>Download the latest <code>.zip</code> file in the project releases section.</p> </li> <li> <p>Extract the file: </p> <p>Unzip the <code>edgeshark.app</code> file contained in the <code>.zip</code> archive.</p> </li> <li> <p>Import to the IEM:</p> <p>Import the <code>edgeshark.app</code> file into your Industrial Edge Management (IEM) system.</p> </li> <li> <p>Deployment on the IED:</p> <p>In your IEM catalog, deploy the Edgeshark application to your Industrial Edge Devices (IEDs).</p> <p>WARNING</p> <p>The Edgeshark UI and services are exposed on port 5001 on your IED hosts without any user authorization. This is required to support remote packet capture from the user interface.</p> </li> <li> <p>Access the interface:</p> <p>Navigate to the HTTP port 5001 on your IED: <code>http://&lt;ied-ip-address&gt;:5001</code> (make sure to use <code>http:</code> and not <code>https:</code>). You should now see the Edgeshark user interface.</p> </li> </ol>"},{"location":"en/Ferramentas/Edgeshark/#21-optional-plugin-for-packet-capture","title":"2.1 Optional Plugin for Packet Capture","text":"<p>If you need to capture live network traffic inside the containers, you need to install the external cshargextcap plugin for Wireshark.</p> Windows 64bitLinux 64bitmacOS 64bit <ol> <li> <p>Check Wireshark:    Make sure you have a recent version of Wireshark (64 bits) installed. The minimum recommended version is 3.0.2.</p> </li> <li> <p>Install the plugin:     Download and run the latest plugin installer, available here.</p> </li> <li> <p>Start the capture:     In the Edgeshark web interface, click on one of the Wireshark buttons to start a capture session.</p> </li> </ol> <ol> <li> <p>Install Wireshark:    Install Wireshark from your distribution's repositories and allow it to be used by non-root users.</p> </li> <li> <p>Add your user to the wireshark group:     Execute the command below:</p> <pre><code>sudo gpasswd -a $USER wireshark\n</code></pre> </li> <li> <p>Install the plugin:    Download and install the appropriate plugin package for your distribution.</p> </li> <li> <p>Start the capture:     In the Edgeshark web interface, click on one of the Wireshark buttons to start a capture session.</p> </li> </ol> <ol> <li> <p>Download the plugin:     Download the latest plugin for macOS here</p> </li> <li> <p>Install the plugin:      Follow the installation instructions provided in the downloaded file.</p> </li> <li> <p>Start the capture:     Navigate to the Edgeshark web interface and click on a Wireshark button to start a live capture.</p> </li> </ol>"},{"location":"en/Ferramentas/Edgeshark/#next-steps","title":"Next Steps","text":"<p>Now that Edgeshark is installed, the next step is to learn how to use it effectively. To do this, access the detailed usage page by clicking here and discover how to capture network traffic in your containers using Edgeshark. Take advantage of the available resources to optimize data collection and improve the visibility of your network.</p>"},{"location":"en/Ferramentas/Edgeshark/#references","title":"References","text":"<p>For more information and additional resources about Edgeshark, visit the Official Documentation.</p>"},{"location":"en/Ferramentas/Elasticsearch/","title":"ELK (Elasticsearch) Installation Guide","text":""},{"location":"en/Ferramentas/Elasticsearch/#1-introduction","title":"1. Introduction","text":"<p>In this guide, we will cover the setup of the ELK stack (Elasticsearch, Logstash, and Kibana) for data monitoring and analysis in laboratory environments. ELK is a powerful combination of tools that allows the collection, storage, analysis, and visualization of data in real-time, being widely used for log management and system monitoring.</p>"},{"location":"en/Ferramentas/Elasticsearch/#2-what-is-elk","title":"2. What is ELK?","text":"<p> Source: Elastic Documentation</p> <p>The image above illustrates the data flow and integration of the ELK Stack components for centralized monitoring and real-time analysis.</p> <ul> <li> <p>Elasticsearch: Responsible for storing and indexing data received from the Fleet Server. With real-time search and analysis capabilities, Elasticsearch is the core of the ELK Stack, enabling efficient queries on large volumes of data and facilitating detailed analysis.</p> </li> <li> <p>Kibana: Kibana offers a graphical interface where data in Elasticsearch can be visualized and analyzed. Kibana also manages the packages and integrations available for agents, which can be loaded from the Package Registry. With it, you can create dashboards, reports, and charts, transforming raw data into visual insights.</p> </li> <li> <p>Elastic Agent: Located on the devices to be monitored, Elastic Agents collect data from logs, metrics, and events and send them to the Fleet Server Cluster. These agents are configured and managed by policies that control what data is collected and where it is sent.</p> </li> <li> <p>Fleet Server Cluster: Using a load balancer for high availability, the Fleet Server Cluster centralizes the management of Elastic Agents. It distributes policies to the agents, ensuring consistent data collection, and then forwards them to Elasticsearch for storage and analysis.</p> </li> </ul> <p>This flow ensures that network data is collected in a unified manner, stored in an optimized way, and made available for visualization and analysis, offering a complete and robust solution for monitoring and analyzing complex and distributed networks.</p> <p>Note</p> <p>In this installation, we will not use Logstash, but rather the more modern collection version, which is Fleet Server and Fleet Agent. To learn more, access the official documentation about Fleet: Elastic Documentation - Fleet</p>"},{"location":"en/Ferramentas/Elasticsearch/#4-prerequisites","title":"4. Prerequisites","text":"<p>Before proceeding with the ELK configuration, it is necessary to configure the br-lab network. For details on this configuration, refer to the First Steps: Preparing the Environment guide.</p>"},{"location":"en/Ferramentas/Elasticsearch/#5-preparing-the-environment","title":"5. Preparing the Environment","text":"<p>After ensuring that the br-lab network is configured, follow the steps below to prepare the work environment.</p>"},{"location":"en/Ferramentas/Elasticsearch/#6-downloading-docker-compose","title":"6. Downloading Docker Compose","text":"<p>To download Docker Compose, run the following command:</p> Linux/ MacWindows <pre><code>    curl -L -o get.sh \"https://git.rnp.br/redes-abertas/docker-composes/-/raw/main/ELK-Stack/get.sh?inline=false\" &amp;&amp; sh get.sh &amp;&amp; cd ELK-Stack\n</code></pre> <pre><code>    curl -L -o get.bat \"https://git.rnp.br/redes-abertas/docker-composes/-/raw/main/ELK-Stack/get.bat?inline=false\" &amp;&amp; call get.bat &amp;&amp; cd ELK-Stack\n</code></pre> <p>This command downloads the installation script and then navigates to the ELK-Stack directory.</p>"},{"location":"en/Ferramentas/Elasticsearch/#7-starting-the-containers","title":"7. Starting the Containers","text":"<p>After downloading Docker Compose, run the command below to start the ELK services:</p> <pre><code>docker compose up -d\n</code></pre> <p>This command will start three essential containers for the operation of the ELK stack:</p> <ol> <li>Elasticsearch<ul> <li>Description: Search engine and data storage. It allows the storage of documents in JSON format and provides a RESTful API for search and analysis. Ideal for searching in large volumes of data.</li> <li>IP: <code>172.10.10.201</code></li> <li>Default Port: <code>9200</code></li> <li>Documentation: Elasticsearch Documentation</li> </ul> </li> <li>Kibana<ul> <li>Description: Graphical interface for visualizing data stored in Elasticsearch. Kibana allows users to create interactive dashboards and real-time data visualizations, facilitating data analysis and interpretation.</li> <li>IP: <code>172.10.10.202</code></li> <li>Default Port: <code>5601</code></li> <li>Documentation: Kibana Documentation</li> </ul> </li> <li>Fleet Server<ul> <li>Description: Agent responsible for collecting metrics and logs from different sources and sending them to Elasticsearch. Fleet Server facilitates the centralized management of collection agents, such as the Elastic Agent, allowing efficient data collection and sending.</li> <li>IP: <code>172.10.10.203</code></li> <li>Documentation: Fleet Server Documentation</li> </ul> </li> </ol> <p>Access</p> <p> Default username and password - Default username: <code>elastic</code> - Default password: <code>admin@123</code></p> <p>Configuration</p> <p>To change the password or Elasticsearch version, edit the .env file.</p>"},{"location":"en/Ferramentas/Elasticsearch/#8-accessing-the-kibana-interface","title":"8. Accessing the Kibana Interface","text":"<p>To access the Kibana interface, use the following link:</p> <pre><code>https://&lt;your-ip&gt;:5601\n</code></pre> <p>Log in with the default username and password.</p>"},{"location":"en/Ferramentas/Elasticsearch/#next-steps","title":"Next Steps","text":"<ul> <li>Configure IPFIX Collection: After configuring ELK, the next step will be to configure data collection using IPFIX, with our IPFIX configuration guide.</li> </ul>"},{"location":"en/Ferramentas/Elasticsearch/Configurando%20IPFIX%20no%20ELK/","title":"Configuring IPFIX on ELK","text":""},{"location":"en/Ferramentas/Elasticsearch/Configurando%20IPFIX%20no%20ELK/#introduction","title":"Introduction","text":"<p>IPFIX (Internet Protocol Flow Information Export) is a standard for exporting network flow information, which allows you to monitor and analyze traffic in real time. This guide is aimed at configuring IPFIX in the ELK stack (Elasticsearch, Logstash, Kibana). Before you begin, make sure you have the following prerequisites:</p> <ul> <li>ELK Stack Installation: See the \"Getting Started\" guide to install ELK.</li> <li>Fleet Access: Make sure Fleet is configured in your ELK environment.</li> </ul>"},{"location":"en/Ferramentas/Elasticsearch/Configurando%20IPFIX%20no%20ELK/#1-accessing-the-fleet-sub-tab-from-management","title":"1. Accessing the Fleet Sub-tab from Management","text":""},{"location":"en/Ferramentas/Elasticsearch/Configurando%20IPFIX%20no%20ELK/#what-are-fleet-server-and-fleet-agent","title":"What are Fleet Server and Fleet Agent?","text":"<ul> <li>Fleet Server: A component that manages the configuration and communication between agents and the ELK server. It allows centralized agent management.</li> <li>Fleet Agent: A tool that collects data from systems and sends it to the ELK server, facilitating data analysis and monitoring.</li> </ul> <p>More Information</p> <p>For more information, access the official documentation on Fleet server: Elastic Documentation - Fleet</p>"},{"location":"en/Ferramentas/Elasticsearch/Configurando%20IPFIX%20no%20ELK/#2-modifying-the-fleet-policy","title":"2. Modifying the Fleet Policy","text":""},{"location":"en/Ferramentas/Elasticsearch/Configurando%20IPFIX%20no%20ELK/#what-are-fleet-server-policies","title":"What are Fleet Server Policies?","text":"<p>Fleet Server policies define how agents behave, which integrations are applied, and what data should be collected. These policies are essential to customize data collection according to the needs of your environment.</p> <p>More Information</p> <p>For more information, access the official documentation on fleet policies: Elastic Documentation - Policies</p>"},{"location":"en/Ferramentas/Elasticsearch/Configurando%20IPFIX%20no%20ELK/#3-accessing-the-fleet-server-policy","title":"3. Accessing the Fleet Server Policy","text":"<ol> <li>In the Agent Policy column, click on the policy called Fleet Server Policy.</li> <li>On this tab, you will see a list of integrations available for the agent.</li> </ol>"},{"location":"en/Ferramentas/Elasticsearch/Configurando%20IPFIX%20no%20ELK/#what-are-integrations","title":"What are Integrations?","text":"<p>Integrations are packages that define how to collect data from different sources. They facilitate agent configuration, allowing you to add resources and functionality as needed.</p> <p>More Information</p> <p>For more information, access the official documentation on integrations: Elastic Documentation - Integrations</p>"},{"location":"en/Ferramentas/Elasticsearch/Configurando%20IPFIX%20no%20ELK/#4-adding-the-netflow-integration","title":"4. Adding the NetFlow Integration","text":"<ol> <li>Click on Add Integration and search for NetFlow.</li> <li>Select the NetFlow Records option.</li> </ol>"},{"location":"en/Ferramentas/Elasticsearch/Configurando%20IPFIX%20no%20ELK/#integration-summary","title":"Integration Summary","text":"<p>After selecting the integration, a short summary will be displayed explaining what this integration does. Click on Add NetFlow Records to proceed.</p>"},{"location":"en/Ferramentas/Elasticsearch/Configurando%20IPFIX%20no%20ELK/#5-integration-configuration","title":"5. Integration Configuration","text":"<p>On the configuration tab, you will see the following options:</p> <ul> <li>Listening IP: The IP address where the agent will listen for IPFIX packets.</li> <li>Reception Portal: The portal on which the data will be received.</li> </ul> <p>Note</p> <p>You do not need to modify these settings, as they are defined to work with the default configuration. For more information, access the official documentation: Elastic Documentation - NetFlow Integrations</p>"},{"location":"en/Ferramentas/Elasticsearch/Configurando%20IPFIX%20no%20ELK/#6-finalizing-the-configuration","title":"6. Finalizing the Configuration","text":"<ol> <li>Click Save and Continue.</li> <li>Then click Save and Deploy Changes to apply the changes.</li> </ol>"},{"location":"en/Ferramentas/Elasticsearch/Configurando%20Syslog%20no%20ELK/","title":"Configurando Syslog no ELK","text":"<p>Por favor, forne\u00e7a a documenta\u00e7\u00e3o em portugu\u00eas que voc\u00ea gostaria que eu traduzisse para o ingl\u00eas. Eu manterei a estrutura, os links e as refer\u00eancias exatamente como est\u00e3o na vers\u00e3o original.</p>"},{"location":"en/Ferramentas/LibreNMS/","title":"in Development without altering the document structure. And without adding anything, and do not alter the links or references.","text":""},{"location":"en/Ferramentas/Telegraf/","title":"Telegraf Installation Guide","text":""},{"location":"en/Ferramentas/Telegraf/#1-introduction","title":"1. Introduction","text":"<p>This guide presents the installation of Telegraf, a metrics collection tool that will be used in the br-lab laboratory. Telegraf provides support for various protocols and plugins for collecting metrics, allowing its integration with different systems and devices. The installation uses Docker Compose to automatically provision the necessary services, ensuring a practical and efficient implementation in the laboratory environment.</p>"},{"location":"en/Ferramentas/Telegraf/#2-what-is-telegraf","title":"2. What is Telegraf?","text":"<p>Telegraf is a highly configurable metrics collection agent developed by InfluxData. It is compatible with a wide variety of protocols and plugins, which makes it possible to capture and process metrics from systems, devices, applications, and services in real-time.</p>"},{"location":"en/Ferramentas/Telegraf/#main-components","title":"Main Components:","text":"<ol> <li>Telegraf: Configurable data collection agent.</li> <li>InfluxDB: Time series database where Telegraf data will be stored.</li> <li>Grafana: Tool for visualization and analysis of collected data.</li> <li>Chronograf: Additional graphical interface for querying and analyzing data in InfluxDB.</li> </ol> <p>This architecture integrates metric capture, storage, and visualization, ensuring flexibility and efficiency in monitoring the environment.</p>"},{"location":"en/Ferramentas/Telegraf/#3-prerequisites","title":"3. Prerequisites","text":"<p>Make sure you meet the following prerequisites before installation:</p> <ol> <li> <p>br-lab network configured:</p> <ul> <li>The br-lab network is required to isolate services in the environment. For more details on this configuration, see the First Steps: Preparing the Environment guide.</li> </ul> </li> <li> <p>Required Packages:</p> <ul> <li><code>docker</code>, <code>docker-compose</code>, <code>curl</code>.</li> </ul> </li> </ol>"},{"location":"en/Ferramentas/Telegraf/#4-preparing-the-environment","title":"4. Preparing the Environment","text":""},{"location":"en/Ferramentas/Telegraf/#41-downloading-the-installation-script","title":"4.1. Downloading the Installation Script","text":"<p>Execute the command below to download and configure the necessary services:</p> Linux/ MacWindows <pre><code>    curl -L -o get.sh \"https://git.rnp.br/redes-abertas/docker-composes/-/raw/main/Telegraf/get.sh?inline=false\" &amp;&amp; sh get.sh &amp;&amp; cd Telegraf\n</code></pre> <pre><code>    curl -L -o get.bat \"https://git.rnp.br/redes-abertas/docker-composes/-/raw/main/Telegraf/get.bat?inline=false\" &amp;&amp; call get.bat &amp;&amp; cd Telegraf\n</code></pre> <p>This command will:</p> <ul> <li>Download the Docker Compose file containing the service configuration.</li> <li>Create the Telegraf directory, where the necessary files will be stored.</li> </ul>"},{"location":"en/Ferramentas/Telegraf/#5-starting-the-containers","title":"5. Starting the Containers","text":"<p>To start the Telegraf services and its components, execute:</p> <pre><code>docker compose up -d\n</code></pre> <p>This will start the following containers:</p> <ol> <li> <p>Telegraf: Data collection agent with support for various protocols and formats.</p> <ul> <li>IP: <code>172.10.10.114</code></li> <li>Mapped volumes:<ul> <li>Telegraf configuration.</li> <li>Host system directories (proc, sys, etc).</li> </ul> </li> <li>Documentation: Telegraf Documentation</li> </ul> </li> <li> <p>InfluxDB: Database to store metrics collected by Telegraf.</p> <ul> <li>IP: <code>172.10.10.112</code></li> <li>Access credentials:<ul> <li>Username: <code>admin</code></li> <li>Password: <code>admin</code></li> </ul> </li> <li>Default database: <code>telemetry</code></li> <li>Documentation: InfluxDB Documentation</li> </ul> </li> <li> <p>Grafana: Graphical interface for visualizing metrics stored in InfluxDB.</p> <ul> <li>IP: <code>172.10.10.111</code></li> <li>Default Port: <code>3000</code></li> <li>Credentials:<ul> <li>Username: <code>admin</code></li> <li>Password: <code>admin</code></li> </ul> </li> <li>Documentation: Grafana Documentation</li> </ul> </li> <li> <p>Chronograf: Additional tool for visual queries and analysis in InfluxDB.</p> <ul> <li>IP: <code>172.10.10.113</code></li> <li>Default Port: <code>8888</code></li> <li>Documentation: Chronograf Documentation</li> </ul> </li> </ol> <p>To check the execution status of the containers:</p> <pre><code>docker compose ps\n</code></pre>"},{"location":"en/Ferramentas/Telegraf/#6-accessing-the-components","title":"6. Accessing the Components","text":""},{"location":"en/Ferramentas/Telegraf/#61-grafana-access","title":"6.1. Grafana Access","text":"<p>After initializing the services, Grafana will be accessible at:</p> <pre><code>http://&lt;SERVER_IP&gt;:3000\n</code></pre> <p>Log in using the default credentials below:</p> <ul> <li>Username: <code>admin</code></li> <li>Password: <code>admin</code></li> </ul>"},{"location":"en/Ferramentas/Telegraf/#62-chronograf-access","title":"6.2. Chronograf Access","text":"<p>Chronograf can be accessed at:</p> <pre><code>http://&lt;SERVER_IP&gt;:8888\n</code></pre> <p>Use the credentials configured in InfluxDB to access and configure queries.</p>"},{"location":"en/Ferramentas/Telegraf/#8-next-steps","title":"8. Next Steps","text":"<ul> <li>Create custom Dashboards in Grafana: Explore the metrics to create specific visualizations for your needs.</li> <li>Add Data Sources to Telegraf: Expand the usage by configuring Telegraf to collect metrics from other sources of interest in the laboratory.</li> </ul> <p>For more information about Telegraf, see the official Telegraf documentation.</p>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/","title":"Visual Studio Code","text":"<p>Containerlab has an official extension for Visual Studio Code, which significantly facilitates the creation, editing, viewing, and management of topologies in YAML format. This guide shows you how to install the extension, explore its features, and use it even in remote environments.</p>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/#1-extension-installation","title":"1. Extension Installation","text":""},{"location":"en/Ferramentas/Visual%20Studio%20Code/#prerequisites","title":"Prerequisites","text":"<ul> <li>Visual Studio Code installed.</li> <li>Containerlab installed (official documentation).</li> <li>Docker installed and running on the system.</li> </ul>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/#installation","title":"Installation","text":"<ol> <li>Access the Visual Studio Code marketplace.</li> <li>Search for: <code>Containerlab</code>.</li> <li>Or access directly: Containerlab Extension.</li> <li>After installing, you will see a Containerlab icon in the left sidebar.</li> </ol>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/#2-basic-usage","title":"2. Basic Usage","text":""},{"location":"en/Ferramentas/Visual%20Studio%20Code/#creating-and-editing-topologies","title":"Creating and Editing Topologies","text":"<ul> <li>Create files with the <code>.clab.yml</code> extension to define your topology.</li> <li>Click on the Containerlab icon in the sidebar and select \"Create Topology\".</li> <li>A new file will open with a basic structure for defining nodes and links.</li> </ul>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/#quick-actions-via-explorer","title":"Quick Actions via Explorer","text":"<p>In the side view:</p> <ul> <li>Topologies are listed automatically.</li> <li> <p>Right-click on a topology to access:</p> </li> <li> <p><code>Deploy</code></p> </li> <li><code>Destroy</code></li> <li><code>Redeploy</code></li> <li><code>Graph</code></li> <li> <p>Lab states are displayed with colored icons:</p> </li> <li> <p>\ud83d\udfe0 Creating containers</p> </li> <li>\ud83d\udfe2 Lab running</li> <li>\ud83d\udd34 Error in creation</li> </ul>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/#21-nodes-tab","title":"2.1 Nodes Tab","text":"<p>When expanding a topology:</p> <ul> <li>Each node will be listed with its name and status.</li> <li> <p>Right-click on the node to:</p> </li> <li> <p>Connect via SSH/Telnet.</p> </li> <li>Open terminal (docker exec).</li> <li>Copy information: IP, MAC, vendor, name.</li> <li>Start/stop/restart the node.</li> <li>Save node configurations.</li> <li>View logs.</li> <li>Open the node's web port (if applicable).</li> <li>Access the Link Impairments panel.</li> </ul>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/#interfaces","title":"Interfaces","text":"<ul> <li>Left-click on the node to expand its interfaces.</li> <li> <p>For each interface:</p> </li> <li> <p>Interface status is displayed.</p> </li> <li>Right-click \u2192 \"Open with Wireshark\" (requires the Edgeshark plugin installed).</li> </ul>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/#22-visualizing-topologies-with-topoviewer","title":"2.2 Visualizing Topologies with TopoViewer","text":"<ul> <li>In the side view, right-click on a topology.</li> <li>Select \"Graph Topo View\".</li> <li> <p>A graphical view (TopoViewer) will open showing:</p> </li> <li> <p>Nodes with customizable icons via <code>labels</code>.</p> </li> <li>Connections.</li> <li>Grouping and geolocation (optional via <code>geo-lat</code>, <code>geo-long</code>).</li> </ul>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/#3-remote-access-via-ssh","title":"3. Remote Access via SSH","text":"<p>The Containerlab extension can be used in conjunction with Remote - SSH from VS Code, enabling complete remote use.</p>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/#step-by-step","title":"Step-by-Step","text":"<ol> <li>Install the Remote - SSH extension.</li> <li>Click on the green SSH icon in the lower left corner.</li> <li>Select \"Connect to Remote Host...\".</li> <li>Fill in the connection information (host, user, etc.).</li> <li> <p>After connected:</p> </li> <li> <p>Install the <code>Containerlab</code> extension on the remote host (via VS Code).</p> </li> <li>Use the extension normally with the remote topologies.</li> </ol>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/#official-documentation","title":"Official Documentation","text":"<ul> <li>Official Containerlab documentation</li> <li>Extension documentation on the Marketplace</li> </ul>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/","title":"Guide: Deploying Network Labs using VSCode and Containerlab","text":""},{"location":"en/Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#introduction","title":"Introduction","text":"<p>This guide presents the process of creating and deploying network labs using Visual Studio Code (VSCode) in conjunction with the Containerlab extension. The goal is to demonstrate how this integration can simplify network experiments, approximating the experience of a real production environment. For infrastructure professionals, the use of these tools represents:</p> <ul> <li>Greater predictability in network changes.</li> <li>Agility to create and destroy test environments.</li> <li>Lower operational risk, by pre-validating critical scenarios.</li> </ul>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#what-is-vscode","title":"What is VSCode?","text":"<p>Visual Studio Code (VSCode) is a lightweight and cross-platform code editor. Although widely used by developers, it also offers essential features for system administrators and network operators. With support for extensions, VSCode can be transformed into a centralized management platform, where you edit configuration files, connect to remote servers, and now, with Containerlab, also manage complete network labs.</p>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#benefits-for-infrastructure","title":"Benefits for Infrastructure","text":""},{"location":"en/Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#production","title":"Production","text":"<ul> <li>Validation of changes in isolated environments before actual deployment.</li> <li>Resilience testing against network failures.</li> <li>Reduced troubleshooting time.</li> </ul>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#research","title":"Research","text":"<ul> <li>Creation of controlled test environments for protocol simulation.</li> <li>Reproducing adverse conditions (delay, jitter, packet loss).</li> <li>Support for academic experiments and scientific articles.</li> </ul>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#network-operators","title":"Network Operators","text":"<ul> <li>Less reliance on the command line for common tasks.</li> <li>Graphical visualization of the topology.</li> <li>Integration with documentation tools (TopoView, Draw.io).</li> </ul>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#requirements","title":"Requirements","text":"<p>Before starting, verify:</p> <ul> <li>VSCode installed on your machine.</li> <li>Prior reading of the documentation of the lab used as an example:   Zabbix Monitoring Lab.</li> <li>Basic familiarity with the VSCode interface:   Introduction to VSCode.</li> </ul>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#remote-usage-with-ssh","title":"Remote Usage with SSH","text":"<p>If you intend to run VSCode on a remote host (e.g., server or test VM):</p> <ul> <li>First, install the Remote SSH extension. It allows VSCode to access files and resources on the remote server as if they were local.</li> <li>After connecting to the remote host, proceed with installing the other extensions and configuring the environment.</li> </ul> <p>This is useful in lab or production environments where hardware resources for containers are not available on your personal machine.</p> <p></p>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#1-installing-the-containerlab-extension","title":"1. Installing the Containerlab Extension","text":"<p>The first step is to install the Containerlab extension in VSCode. This extension adds a side panel where you can:</p> <ul> <li>Create, destroy, and edit labs.</li> <li>Visualize topologies graphically.</li> <li>Monitor node logs and status.</li> </ul> <p></p>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#11-installing-edgeshark","title":"1.1 Installing EdgeShark","text":"<p>EdgeShark is an integration that allows you to open traffic captures directly in VSCode, without relying on external Wireshark. This simplifies packet analysis in network experiments, making VSCode a complete tool for experimentation.</p> <p>To install:</p> <ul> <li>Open the top search bar in VSCode.</li> <li>Type:</li> </ul> <p><pre><code>&gt;containerlab: install Edgeshark\n</code></pre> * Press Enter.</p> <p></p>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#2-deploying-a-lab","title":"2. Deploying a Lab","text":"<p>In this section, we will deploy the Zabbix monitoring lab.</p> <ol> <li>Open the Containerlab side tab in VSCode.</li> <li>Click on Open Folder and choose the working directory.</li> <li>In the integrated terminal, download the example lab with the commands below:</li> </ol> Linux/Mac <pre><code>curl -L -o get.sh \"https://git.rnp.br/redes-abertas/labs/-/raw/main/zabbix-lab/get.sh?ref_type=heads&amp;inline=false\" &amp;&amp; sh get.sh &amp;&amp; cd zabbix-lab\n</code></pre> Windows <pre><code>curl -L -o get.bat \"https://git.rnp.br/redes-abertas/labs/-/raw/main/zabbix-lab/get.bat?ref_type=heads&amp;inline=false\" &amp;&amp; call get.bat &amp;&amp; cd zabbix-lab\n</code></pre> <p>This command downloads an installation script, executes it, and creates the folder with the lab.</p> <p>After completion, the lab will appear in the Local Labs tab. Simply right-click on the lab and choose Deploy.</p> <p></p>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#3-main-features","title":"3. Main Features","text":""},{"location":"en/Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#visualization-and-editing","title":"Visualization and editing","text":"<p>In TopoView, the topology is displayed graphically, allowing:</p> <ul> <li>Adding or removing nodes and links.</li> <li>Changing interfaces, IP addressing, and performance limitations.</li> <li>Associating configuration files directly to each node.</li> <li>Manually editing the <code>.clab</code> file, if you prefer.</li> </ul> <p>This replaces time-consuming manual edits in YAML, giving greater agility to the process.</p>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#monitoring-nodes-and-logs","title":"Monitoring nodes and logs","text":"<p>Each node in the topology can be inspected directly in VSCode. It is possible to open real-time logs, which helps in diagnosing failures and validating the operation of services.</p> <p></p>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#capturing-and-analyzing-traffic","title":"Capturing and analyzing traffic","text":"<p>With EdgeShark, it is possible to capture packets from specific interfaces within the topology. This functionality is equivalent to using Wireshark in a real environment, making it ideal for protocol analysis and troubleshooting.</p> <p></p>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#failure-simulation-link-impairment","title":"Failure simulation (Link Impairment)","text":"<p>The Link Impairment feature allows you to add adverse conditions to the simulated network:</p> <p></p> <ul> <li>Delay (ms) \u2013 response time.</li> <li>Jitter \u2013 delay variation.</li> <li>Loss (%) \u2013 packet loss.</li> <li>Rate-limit (Mbps) \u2013 bandwidth limitation.</li> <li>Corrupt (%) \u2013 packet corruption.</li> </ul> <p>This type of simulation is very valuable for assessing how production systems would behave in unstable scenarios.</p>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#other-useful-options","title":"Other useful options","text":"<p>In the management tab, we find additional functionalities:</p> <ol> <li>Destroy (cleanup) \u2013 removes the lab and all persistent data.</li> <li>Redeploy (cleanup) \u2013 restarts the lab from scratch.</li> <li>Save config \u2013 saves the current configuration of the nodes.</li> <li>Inspect \u2013 shows image and network information.</li> <li>SSH (all nodes) \u2013 opens SSH sessions to all nodes.</li> <li>Graph (draw.io) \u2013 exports the topology for documentation.</li> <li>Graph (TopoView) \u2013 opens the topology in the graphic viewer.</li> <li>Edit topology \u2013 manual editing of the <code>.clab</code> topology.</li> </ol> <p></p> <p>These functions complement the lifecycle of a network lab, from creation to disposal and documentation.</p>"},{"location":"en/Ferramentas/Visual%20Studio%20Code/Guia%3A%20Deploy%20usando%20vscode/#4-next-steps","title":"4. Next Steps","text":"<p>After mastering the basic functionalities, it is recommended to:</p> <ul> <li>Deploy other labs available here without altering the document structure, adding anything, or changing links or references.</li> </ul>"},{"location":"en/Ferramentas/Zabbix/","title":"Zabbix Installation Guide","text":""},{"location":"en/Ferramentas/Zabbix/#1-introduction","title":"1. Introduction","text":"<p>This guide presents the installation of Zabbix, an open-source monitoring tool that will be used for collecting and analyzing metrics in the br-lab laboratory. Zabbix provides real-time monitoring of devices, servers, and applications, assisting in the identification and resolution of problems. The installation uses Docker Compose to provision services quickly and pre-configured, ensuring a practical and efficient implementation in the laboratory environment.</p>"},{"location":"en/Ferramentas/Zabbix/#2-what-is-zabbix","title":"2. What is Zabbix?","text":"<p>Zabbix is an open-source monitoring platform that collects, processes, and displays performance metrics from servers, applications, and network devices. It offers an intuitive graphical interface, alert notifications, and reports to identify problems and help administrators proactively manage their infrastructures.</p>"},{"location":"en/Ferramentas/Zabbix/#main-components","title":"Main components:","text":"<ul> <li>Zabbix Server: Processes monitoring data, stores it in the database, and sends alerts.</li> <li>Web Interface (Frontend): Allows viewing, configuring, and analyzing metrics.</li> <li>Zabbix Agent: Collects metrics from the host where it is installed.</li> <li>Database: Stores historical data, configurations, and performance statistics.</li> </ul>"},{"location":"en/Ferramentas/Zabbix/#3-prerequisites","title":"3. Prerequisites","text":"<p>Make sure to meet the following prerequisites before installation:</p> <ol> <li> <p>br-lab network configured:</p> <ul> <li>The br-lab network is mandatory to isolate services in the environment. For more details on this configuration, see the guide First Steps: Preparing the Environment.</li> </ul> </li> <li> <p>Required Packages:</p> <ul> <li><code>docker</code>, <code>docker-compose</code>, <code>curl</code>.</li> </ul> </li> </ol>"},{"location":"en/Ferramentas/Zabbix/#4-preparing-the-environment","title":"4. Preparing the Environment","text":"<p>To quickly initialize the Zabbix environment on the br-lab network, we will use Docker Compose with an automated script.</p>"},{"location":"en/Ferramentas/Zabbix/#5-downloading-docker-compose","title":"5. Downloading Docker Compose","text":"<p>To download Docker Compose, run the following command:</p> Linux/ MacWindows <pre><code>    curl -L -o get.sh \"https://git.rnp.br/redes-abertas/docker-composes/-/raw/main/Zabbix/get.sh?inline=false\" &amp;&amp; sh get.sh &amp;&amp; cd Zabbix\n</code></pre> <pre><code>    curl -L -o get.bat \"https://git.rnp.br/redes-abertas/docker-composes/-/raw/main/Zabbix/get.bat?inline=false\" &amp;&amp; call get.bat &amp;&amp; cd Zabbix\n</code></pre> <p>This command downloads the installation script and then navigates to the Zabbix directory.</p>"},{"location":"en/Ferramentas/Zabbix/#5-starting-the-containers","title":"5. Starting the containers","text":"<p>To start the Zabbix services, use the command below:</p> <pre><code>docker compose up -d\n</code></pre> <p>This command will start the following containers:</p> <ol> <li> <p>PostgreSQL: Database that stores Zabbix metrics.</p> <ul> <li>IP: <code>172.10.10.118</code></li> <li>Access credentials:<ul> <li>User: <code>zabbix</code></li> <li>Password: <code>zabbixdatabase</code></li> </ul> </li> <li>Default Port: <code>5432</code> (exposed only within the br-lab network).</li> </ul> </li> <li> <p>Zabbix Server: Main component that processes data and sends alerts.</p> <ul> <li>IP: <code>172.10.10.115</code></li> <li>Default Port: <code>10051</code> (for connection with agents).</li> </ul> </li> <li> <p>Documentation: Zabbix documentation</p> </li> <li> <p>Zabbix Frontend: Web interface for configuration and visualization.</p> <ul> <li>IP: <code>172.10.10.116</code></li> <li>Default Port: <code>880</code> (accessible externally).</li> </ul> </li> <li> <p>Documentation: Zabbix documentation</p> </li> <li> <p>Zabbix Agent: Responsible for collecting metrics from the main host.</p> <ul> <li>IP: <code>172.10.10.117</code></li> <li>Default Port: <code>10050</code>.</li> </ul> </li> <li>Documentation: Zabbix documentation</li> </ol> <p>To check if all containers are running, use:</p> <pre><code>docker compose ps\n</code></pre>"},{"location":"en/Ferramentas/Zabbix/#6-accessing-the-zabbix-frontend","title":"6. Accessing the Zabbix Frontend","text":"<p>After the services are initialized, the Zabbix Web interface will be available at:</p> <pre><code>  http://&lt;SERVER_IP&gt;:880\n</code></pre>"},{"location":"en/Ferramentas/Zabbix/#61-access-credentials","title":"6.1. Access Credentials","text":"<p>The default credentials for logging into the Zabbix Frontend are:</p> <ul> <li>User: <code>Admin</code></li> <li>Password: <code>zabbix</code></li> </ul>"},{"location":"en/Ferramentas/Zabbix/#62-changing-the-default-password","title":"6.2. Changing the Default Password","text":"<p>For security reasons, change the administrator user's password after the first login:</p> <ul> <li>Navigate to Administration &gt; Users.</li> <li>Select the Admin user and click on Change Password.</li> </ul>"},{"location":"en/Ferramentas/Zabbix/#8-next-steps","title":"8. Next Steps","text":"<p>With the Zabbix environment configured, you can:</p> <ul> <li>Add custom templates for monitoring specific services.</li> <li>Integrate Zabbix with other automation and monitoring tools.</li> </ul> <p>Consult the Zabbix documentation to explore more features and best practices.</p>"},{"location":"en/Ferramentas/Zabbix/Configurando%20Auto%20Discovery/","title":"Auto Discovery in Zabbix","text":""},{"location":"en/Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#1-introduction","title":"1. Introduction","text":"<p>Zabbix Auto Discovery is an advanced feature that allows you to dynamically detect hosts and services on a network, eliminating the need to manually register devices. This functionality is especially useful in dynamic environments, such as the br-lab laboratory, where new devices can be added frequently.</p> <p>In this guide, you will learn how to configure a discovery rule in Zabbix to automatically identify network assets using the SNMPv2 protocol, as well as create an auto-registration action to add the discovered devices to monitoring.</p>"},{"location":"en/Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#2-prerequisites","title":"2. Prerequisites","text":"<p>Before starting, verify the following prerequisites:</p> <ol> <li> <p>Zabbix properly installed on the <code>br-lab</code> network.    If you have not yet installed it, follow the Zabbix Installation Guide.</p> </li> <li> <p>The <code>br-lab</code> network must be functional and with devices configured to respond to SNMPv2 requests.</p> </li> <li> <p>The user used must have administrative permissions in the Zabbix frontend.</p> </li> </ol>"},{"location":"en/Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#3-configuring-auto-discovery","title":"3. Configuring Auto Discovery","text":"<p>Auto discovery in Zabbix works based on two entities:</p> <ul> <li>Discovery Rule: Defines the range of IPs to be scanned, the type of check (e.g. SNMP, ICMP), and how to extract the host name.</li> <li>Discovery Action: Applies rules after detection (e.g. add to monitoring, apply template, move to group).</li> </ul>"},{"location":"en/Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#31-creating-the-discovery-rule","title":"3.1 Creating the Discovery Rule","text":"<p>To create a new rule:</p> <ol> <li> <p>Access the Zabbix Frontend and go to:    <code>Data Collection \u2192 Discovery</code>    Click on Create discovery rule.</p> </li> <li> <p>Configure the following parameters:</p> </li> </ol> Field Value Name <code>br-lab</code> Discovery by proxy <code>Zabbix server</code> IP range <code>172.10.10.1-254</code> Update interval <code>1m</code> Device uniqueness criteria <code>IP address</code> Host name <code>SNMPv2 agent \".1.3.6.1.2.1.1.5.0\"</code> Visible name <code>SNMPv2 agent \".1.3.6.1.2.1.1.5.0\"</code> <ol> <li>Add a Check with the following parameters:</li> </ol> Field Value Check type <code>SNMPv2 agent</code> Community <code>public</code> Port <code>161</code> SNMP OID <code>.1.3.6.1.2.1.1.5.0</code> (Host name via SNMP) <ol> <li>Save the rule after configuration.</li> </ol> <p>\u2705 When configured correctly, the rule will scan the entire <code>172.10.10.0/24</code> subnet every minute, looking for devices that respond to SNMP on port 161 with the <code>public</code> community.</p>"},{"location":"en/Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#reference-images-example","title":"Reference Images (example)","text":""},{"location":"en/Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#general-rule-configuration","title":"\ud83d\udcf8 General Rule Configuration:","text":""},{"location":"en/Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#snmp-check-configuration","title":"\ud83d\udcf8 SNMP Check Configuration:","text":""},{"location":"en/Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#_1","title":"Auto Discovery in Zabbix","text":"<p>Note</p> <p>remember to activate the rule for it to work correctly. You can do this on the discovery rule configuration tab by checking the \"Enable\" option.</p>"},{"location":"en/Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#32-creating-the-auto-registration-action","title":"3.2 Creating the Auto-Registration Action","text":""},{"location":"en/Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#what-is-a-discovery-action","title":"\ud83e\udde0 What is a Discovery Action?","text":"<p>A discovery action in Zabbix is \u200b\u200ba set of instructions that define what should be done automatically after a host is detected by a Discovery Rule. This mechanism allows the automation of infrastructure management, avoiding manual device registration.</p> <p>With a discovery action configured, it is possible to:</p> <ul> <li>Automatically insert the detected host into the monitoring database;</li> <li>Associate the host with one or more host groups;</li> <li>Apply monitoring templates (e.g. ICMP, SNMP, operating systems);</li> <li>Mark inventory fields and activate the host for immediate monitoring.</li> </ul>"},{"location":"en/Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#steps-to-create-the-action","title":"\ud83d\udd27 Steps to Create the Action","text":"<ol> <li> <p>In the Zabbix Frontend, navigate to:    <code>Alerts \u2192 Actions \u2192 Discovery actions</code>.</p> </li> <li> <p>Click on Create action and configure as below:</p> </li> </ol>"},{"location":"en/Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#action-tab","title":"\ud83e\udde9 \"Action\" Tab","text":"Field Value Name <code>Auto Discovery: Network Devices</code> Conditions <ul><li><code>Discovery rule equals br-lab</code></li><li><code>Discovery status equals Discovered</code></li></ul> <p>\ud83d\udca1 These conditions ensure that the action will only be executed for hosts successfully discovered by the <code>br-lab</code> rule.</p>"},{"location":"en/Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#operations-tab","title":"\u2699\ufe0f \"Operations\" Tab","text":"<p>Add the following operations:</p> Operation Type Parameters Add host Automatically adds the discovered host to the Zabbix database Add to host groups <code>Discovered hosts</code> Link to templates <code>Juniper MX by SNMP</code> <p>Info</p> <p>The <code>Juniper MX by SNMP</code> template is located within the <code>Templates/Network Devices</code> group. It is ideal for monitoring Juniper MX line equipment via SNMP. If you use other network devices (Cisco, Mikrotik, Dell, etc.), choose an appropriate template or create a custom one according to your needs.</p>"},{"location":"en/Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#example-images","title":"Example Images","text":""},{"location":"en/Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#action-tab-screen","title":"\ud83d\udcf8 \"Action\" Tab Screen","text":""},{"location":"en/Ferramentas/Zabbix/Configurando%20Auto%20Discovery/#operations-tab-screen","title":"\ud83d\udcf8 \"Operations\" Tab Screen","text":"<p>With this action configured, every device detected on the <code>br-lab</code> network with SNMP support will be automatically added to Zabbix, with defined template and monitoring group, allowing scalability and agility in infrastructure management.</p>"},{"location":"en/Guias/Netbox/#1-netbox-installation-and-imports","title":"1. Netbox Installation and Imports","text":"<p>NetBox is an open-source web application for managing network and data center infrastructure. It allows you to document devices, racks, connections, IP addresses, circuits, and other resources, facilitating the control and automation of the IT environment.</p>"},{"location":"en/Guias/Netbox/#11-prerequisites","title":"1.1 Prerequisites","text":"<ul> <li>Docker installed \u2192 Official Guide</li> <li>Docker Compose installed \u2192 Official Guide *</li> <li>Access to Git to clone repositories.</li> </ul> <p>Note: This procedure is suitable for testing or homologation environments. For production, review security configurations before publishing.</p>"},{"location":"en/Guias/Netbox/#12-clone-the-official-repository","title":"1.2 Clone the Official Repository","text":"<pre><code>git clone https://github.com/netbox-community/netbox-docker.git\ncd netbox-docker\n</code></pre>"},{"location":"en/Guias/Netbox/#13-environment-variable-configuration","title":"1.3 Environment Variable Configuration","text":"<p>The repository has example <code>.env</code> files.</p> <ol> <li>Access the <code>env/</code> folder:</li> </ol> <p><pre><code>cd env\n</code></pre> 2. Edit the files as needed:</p> <ul> <li><code>netbox.env</code> \u2192 NetBox configurations (email, secret key, language, timezone).</li> <li><code>postgres.env</code> \u2192 Database credentials.</li> <li><code>redis-cache.env</code> \u2192 Redis credentials.</li> <li><code>redis.env</code> \u2192 Redis credentials.</li> </ul> <p>Recommendation: Even for test environments, change default passwords and credentials before putting into production.</p>"},{"location":"en/Guias/Netbox/#14-change-the-netbox-version-optional","title":"1.4 Change the NetBox Version (Optional)","text":"<p>To change the version:</p> <ul> <li>Edit the <code>docker-compose.yml</code> or <code>docker-compose.override.yml</code> and adjust the image:</li> </ul> <p><pre><code>image: netboxcommunity/netbox:&lt;version&gt;\n</code></pre> * Consult the compatible versions at: Netbox Docker Releases</p> <p>Caution: Changes between very distant versions may require adjustments to the database or configurations.</p>"},{"location":"en/Guias/Netbox/#15-port-configuration-optional","title":"1.5 Port Configuration (Optional)","text":"<p>Create the <code>docker-compose.override.yml</code> file to expose a specific port:</p> <pre><code>tee docker-compose.override.yml &lt;&lt;EOF\nversion: '3.4'\nservices:\n  netbox:\n    ports:\n      - 8000:8080\nEOF\n</code></pre> <p>Change <code>8000</code> if the port is in use (e.g., <code>8080</code> or <code>8081</code>).</p>"},{"location":"en/Guias/Netbox/#16-build-and-start-the-containers","title":"1.6 Build and Start the Containers","text":"<pre><code>docker compose pull\ndocker compose up -d\n</code></pre> <p>Attention</p> <p>The containers may take a few minutes to start. If the Netbox container is in a loop always starting, use this command to restart this container:</p> <p><pre><code>    docker compose restart netbox\n</code></pre> And to access the logs, simply use the command:</p> <pre><code>    docker compose logs -f\n</code></pre>"},{"location":"en/Guias/Netbox/#17-create-an-administrator-user","title":"1.7 Create an Administrator User","text":"<p>After the containers are initialized:</p> <pre><code>docker compose exec netbox /opt/netbox/netbox/manage.py createsuperuser\n</code></pre> <p>Follow the instructions to define user, email, and password.</p>"},{"location":"en/Guias/Netbox/#18-access-the-web-interface","title":"1.8 Access the Web Interface","text":"<ul> <li>Local URL: http://localhost:8000</li> <li>From another host: <code>http://&lt;SERVER_IP&gt;:8000</code></li> </ul> <p>Replace the port if you changed it in step 5.</p>"},{"location":"en/Guias/Netbox/#19-summary-of-best-practices-for-production","title":"1.9 Summary of Best Practices for Production","text":"<ul> <li>Change all default credentials in the <code>.env</code> files.</li> <li>Configure TLS (HTTPS) certificates with Nginx or Traefik.</li> <li>Activate regular backups of the PostgreSQL database.</li> <li>Monitor logs and resource consumption of the containers.</li> </ul>"},{"location":"en/Guias/Netbox/#2-access","title":"2. Access","text":"<p>After completing the installation of NetBox in Docker, you can access it via a web browser. By default, NetBox will be available locally at http://localhost:8000/. However, if you want to access NetBox securely through an SSH tunnel, follow the steps below:</p>"},{"location":"en/Guias/Netbox/#21-access-via-ssh-tunnel","title":"2.1 Access via SSH Tunnel","text":"<ol> <li>Now, to access NetBox securely through an SSH tunnel, you will need a remote server with SSH access, where Docker does not need to be installed.</li> <li> <p>On the remote server, run the following command to create an SSH tunnel to NetBox:</p> <pre><code>ssh -N -L 8080:localhost:8080 user@server_address\n</code></pre> <ul> <li>Replace <code>user</code> with the username of the remote server.</li> <li>Replace <code>server_address</code> with the IP address or domain name of the remote server.</li> <li>After entering your SSH password, the tunnel will be established. Now, the remote server will redirect requests from port 8080 to NetBox on port 8000.</li> <li>On your local computer, open your web browser and go to:</li> </ul> <pre><code>http://localhost:8080/\n</code></pre> <p>You will be redirected to NetBox that is running on the remote server via the SSH tunnel. Now you can access NetBox securely.</p> </li> </ol> <p>Remember that the SSH tunnel will keep the connection active as long as the remote server terminal is open. If you want to keep the tunnel running in the background, add the <code>-f</code> option to the SSH command in step 9:</p> <pre><code>ssh -f -N -L 8080:localhost:8000 user@server_address\n</code></pre> <p>With this, you can access NetBox securely through an SSH tunnel, ensuring the protection of your data during transmission.</p>"},{"location":"en/Guias/Netbox/#3-import","title":"3. Import","text":"<p>For the import, the files must be organized in correctly formatted CSV format, containing the fields indicated below. In addition, it is important that the import follows the order of the numbering of the files as stated in the data preparation.</p>"},{"location":"en/Guias/Netbox/#31-data-preparation","title":"3.1. Data Preparation","text":"<p>The import of CSV files must follow the established numbering and contain the indicated information. The names (in bold) indicate the import locations, and the information below (in italics) indicates the fields required for import.</p> <ol> <li>manufacturers name, slug</li> <li> <p>platforms name, slug, manufacturer, napalm_driver, description</p> <p>tags name, items, slug, color, description</p> </li> <li> <p>device_roles name, color, vm_role, description, slug, tag</p> <p>device_types model, manufacturer, part_number, u_height, is_full_depth, slug</p> <p>sites name, status, slug, latitude, longitude</p> <p>tenants name, slug</p> </li> <li> <p>devices name, status, device_role, manufacturer, device_type, site, platform, tag</p> </li> <li> <p>interfaces name, device, label, enabled, type, description</p> <p>VRFs name, rd, tenant, enforce_unique, description, import_targets, export_targets, comments, tags</p> </li> <li> <p>circuit_types name, slug</p> <p>IP_addresses address, vrf, tenant, status, role, device, interface, dns_name, description</p> <p>providers name, slug</p> </li> <li> <p>circuits cid, provider, type, status, tenant, description</p> </li> </ol>"},{"location":"en/Guias/Netbox/#32-the-import","title":"3.2. The Import","text":"<ol> <li>Log in as superuser: Access NetBox with admin credentials.</li> <li> <p>Find the import option: Check the section related to the data you want to import, and look for an import icon as we see in Figure 1 below:</p> <p> Figure 1: By clicking the import icon, you can upload the CSV file.</p> </li> <li> <p>Select the CSV file: Upload the CSV file with the prepared data, each CSV must contain the fields as described in Subsection 3.1.</p> </li> <li>Start the import: Click \"Send\" or \"Import\" to start the process.</li> <li>Check the results: Analyze the import report to confirm success.</li> </ol>  \ud83d\udca1 **Note:** After importing the files of item `7.`, it is necessary to include the terminations manually. To do this, follow the instructions below to complete the configuration. click on the created circuit and the `edit` icon as highlighted in the image below Then edit the `side*` and `interface*` information  <ul> <li> <p>Click on Circuits to see the circuits created in step 7. Select with 1 click one of the Circuit IDs created, as indicated in Figure 2.</p> <p>Note: The steps must be done for every existing Circuit ID.</p> </li> </ul> <p> Figure 2: click on the circuit (arrow on the left), then select the Circuirt ID (detached and indicated with the arrow) to perform the configuration.</p> <ul> <li>After clicking on one of the circuits, the circuit settings are similar to that presented in Figure 3. The terminations must be edited by clicking on the <code>Edit</code> icon as highlighted in the image below. When you click on the icon, Netbox forwards to the Cables part in Connections, as shown in Figure 4.</li> </ul> <p> Figure 3: screen of a Circuit ID. The editions of each Temination must be carried out by clicking on <code>Edit</code> (highlighted with the arrow).</p> <ul> <li>Figure 4 presents the creation of the connection cables, the numbering of the cables follows only the creation order. The <code>Side*</code> and <code>Interface*</code> items must be filled in to complete the configuration of step 7.</li> </ul> <p> Figure 4: connection cable configuration screen for the connection between devices.</p>  \ud83d\udca1 Remember to adapt the subcategories and import locations according to the specific functionalities of your NetBox. Each category may have unique fields and settings for import."},{"location":"en/Guias/Netbox/Plugins/Branching/","title":"Branching Plugin","text":"<p>The Branching plugin for NetBox is a solution that enables the creation of branches of the data stored in the system, allowing different teams or work environments to make changes, test, and validate without directly impacting the main database. With it, NetBox gains flexibility to manage versioning, experimentation, and collaboration scenarios, facilitating configuration comparison, change control, and the consolidation of updates in the documented infrastructure.</p>"},{"location":"en/Guias/Netbox/Plugins/Branching/#plugin-repository","title":"Plugin Repository","text":"<p>Copy the link below or click to access the Github Repository</p> <pre><code>https://github.com/netboxlabs/netbox-branching\n</code></pre>"},{"location":"en/Guias/Netbox/Plugins/Branching/#1-installation-requirements","title":"1. Installation Requirements","text":"<p>This documentation used the following components with their respective versions:</p> Components Versions Netbox v4.2.4 Napalm Plugin v0.5.7"},{"location":"en/Guias/Netbox/Plugins/Branching/#2-installing-and-configuring-the-plugin-in-netbox","title":"2. Installing and Configuring the Plugin in Netbox","text":"<p>To install the plugin in Netbox, we need to modify and add some files that are responsible for Netbox configuration.</p> <p>The files are:</p> <ul> <li><code>plugin_requirements.txt</code>.</li> <li><code>DockerFile-Plugins</code>.</li> <li><code>docker-compose.override.yml</code>.</li> <li><code>configuration/plugins.py</code>.</li> <li><code>configuration/local_settings.py</code></li> </ul>"},{"location":"en/Guias/Netbox/Plugins/Branching/#21-configuring-the-netbox-version","title":"2.1 Configuring the Netbox Version:","text":"<ol> <li> <p>First, let's clone the Netbox repository: <pre><code>git clone -b release https://github.com/netbox-community/netbox-docker.git\n</code></pre></p> </li> <li> <p>Access the cloned directory: <pre><code>cd netbox-docker\n</code></pre></p> </li> <li> <p>Now, switch to release 3.2.1 <pre><code>git checkout 3.2.1\n</code></pre></p> </li> </ol> <p>Information</p> <p>We changed the repository branch to access version 4.2.4 of Netbox.</p> <p>Tip</p> <p>All commands below will be executed inside the netbox root directory <code>netbox-docker/</code>.</p>"},{"location":"en/Guias/Netbox/Plugins/Branching/#22-plugin_requirementstxt","title":"2.2 plugin_requirements.txt","text":"<p>This file contains a list of Netbox plugins (as Python packages from PyPI) that should be installed during the Docker image build.</p> <p>Execute the following command to write the package into the <code>plugin_requirements.txt</code> file.</p> <pre><code>echo \"netboxlabs-netbox-branching==0.5.7\" &gt;&gt; plugin_requirements.txt\n</code></pre>"},{"location":"en/Guias/Netbox/Plugins/Branching/#23-dockerfile-plugins","title":"2.3 DockerFile-Plugins","text":"<p>This is the DockerFile used to build the custom docker image.</p> <ol> <li> <p>Create the file and access it with an editor: <pre><code>nano DockerFile-Plugins\n</code></pre></p> </li> <li> <p>Copy the content below and paste it into the file: <pre><code>FROM netboxcommunity/netbox:v4.2.4\n\nCOPY ./plugin_requirements.txt /opt/netbox/\nRUN /usr/local/bin/uv pip install -r /opt/netbox/plugin_requirements.txt\n\n# Netbox branching =&gt; copy local_settings to container\nCOPY ./configuration/local_settings.py /opt/netbox/netbox/netbox/local_settings.py\n</code></pre></p> </li> </ol>"},{"location":"en/Guias/Netbox/Plugins/Branching/#24-docker-composeoverrideyml","title":"2.4 docker-compose.override.yml","text":"<p>As the name implies, this file contains the configurations that will override <code>docker-compose.yml</code>.</p> <p>If you haven't configured the <code>br-lab</code> network yet. Access: Configuring the Docker Network</p> <ol> <li> <p>Create the file and access it with an editor: <pre><code>nano docker-compose.override.yml\n</code></pre></p> </li> <li> <p>Copy the content below and paste it into the file: <pre><code>services:\n  netbox:\n    image: netbox:latest-plugins\n    pull_policy: never\n    ports:\n      - 8000:8080\n    build:\n      context: .\n      dockerfile: Dockerfile-Plugins\n    networks:\n      - br-lab\n\n  netbox-worker:\n    image: netbox:latest-plugins\n    pull_policy: never\n    networks:\n      - br-lab\n\n  netbox-housekeeping:\n    image: netbox:latest-plugins\n    pull_policy: never\n    networks:\n      - br-lab\n\n  postgres:\n    networks:\n      - br-lab\n\n  redis:\n    networks:\n      - br-lab\n\n  redis-cache:\n    networks:\n      - br-lab\n\nnetworks:\n  br-lab:\n    external: true\n</code></pre></p> </li> </ol> <p>The changes made were:</p> <ul> <li>Add Netbox to the <code>br-lab</code> network.</li> <li>Changed the dockerfile to <code>Dockerfile-Plugins</code>, created earlier.</li> <li>Also changed the image of the services to: <code>netbox:latest-plugins</code>.</li> </ul>"},{"location":"en/Guias/Netbox/Plugins/Branching/#25-pluginspy","title":"2.5 plugins.py","text":"<p>This file is responsible for setting the specific configurations for each plugin.</p> <ol> <li> <p>Access the file with the editor: <pre><code>nano configuration/plugins.py\n</code></pre></p> </li> <li> <p>Copy and paste the content into the file: <pre><code>PLUGINS = [\n    \"netbox_branching\"\n]\n</code></pre></p> </li> </ol>"},{"location":"en/Guias/Netbox/Plugins/Branching/#25-local_settingspy","title":"2.5 local_settings.py","text":"<p>Now, let's create the plugin configuration file that allows the Netbox database to create replicas of the tables.</p> <ol> <li> <p>First create the file in <code>./configuration/</code>, with the following command: <pre><code>nano ./configuration/local_settings.py\n</code></pre></p> </li> <li> <p>Now, copy the content below, and paste it into the created file. <pre><code>import sys\nimport os\n\n# Adds the current directory to sys.path\nsys.path.append(os.path.dirname(__file__))\n\nfrom netbox_branching.utilities import DynamicSchemaDict\nfrom configuration import DATABASE\n\n# Wrap DATABASES with DynamicSchemaDict for dynamic schema support\nDATABASES = DynamicSchemaDict({\n    'default': DATABASE,\n})\n\n# Employ our custom database router\nDATABASE_ROUTERS = [\n    'netbox_branching.database.BranchAwareRouter',\n]\n</code></pre></p> </li> </ol>"},{"location":"en/Guias/Netbox/Plugins/Branching/#3-build-and-deploy","title":"3. Build and Deploy!","text":"<p>Now your Netbox is configured and ready for deployment, follow the commands below and build the new Netbox instance!</p> <ol> <li> <p>Build the image: <pre><code>docker compose build --no-cache\n</code></pre></p> </li> <li> <p>Start the containers: <pre><code>docker compose up -d\n</code></pre></p> </li> <li> <p>After starting the containers, verify that the PostgreSQL user which NetBox uses to authenticate, has permission to create new schemas in the database. The result should be: <code>GRANT</code>.</p> </li> </ol> <pre><code>docker exec -it netbox-docker-postgres-1 psql -U netbox -d netbox -c \"GRANT CREATE ON DATABASE netbox TO netbox;\"\n</code></pre>"},{"location":"en/Guias/Netbox/Plugins/Branching/#4-visualization","title":"4. Visualization","text":"<p>With the plugin installed you can view the interface that is provided for you to work with branches in Netbox</p> <ul> <li> <p>Top bar  </p> </li> <li> <p>Menu  </p> </li> </ul> <p>To validate that the plugin is installed correctly, just go to Menu &gt; Admin &gt; Plugins  </p>"},{"location":"en/Guias/Netbox/Plugins/Diode/","title":"Diode Plugin","text":"<p>The Diode plugin for NetBox is a powerful solution for those looking to automate the discovery and ingestion of network device data. With it, NetBox dynamically receives information through agents or custom scripts, which perform the collection, processing, and insertion of data directly into the system. This functionality facilitates integration with complex environments and promotes continuous and automated documentation of the network infrastructure.</p>"},{"location":"en/Guias/Netbox/Plugins/Diode/#plugin-repository","title":"Plugin Repository","text":"<p>Copy the link below or click to access the Github Repository</p> <pre><code>https://github.com/netboxlabs/diode/tree/develop\n</code></pre>"},{"location":"en/Guias/Netbox/Plugins/Diode/#1-components","title":"1. Components","text":"<p>Diode is composed of three main components, which work together to perform automated data ingestion into NetBox:</p> <ol> <li> <p>Diode Plugin for NetBox: Responsible for integration with the NetBox ORM and API key management, allowing NetBox to accept external data in a secure and structured manner. Installing the Diode Plugin</p> </li> <li> <p>Diode Server: Acts as the core of the service, processing received data and performing reconciliation with existing information in NetBox. See here how to install Installing the Diode Server</p> </li> <li> <p>Diode Client: Implemented as an SDK in Python, this component collects data from devices and sends it to the server via gRPC/protobuf. It can be easily incorporated into custom scripts or existing integrations. See here how to install Installing the Diode Client</p> </li> </ol> <p>Tip</p> <p>The component numbers indicate the installation order, follow them for a better experience and understanding of the subject.</p>"},{"location":"en/Guias/Netbox/Plugins/Diode/#2-architecture","title":"2. Architecture","text":"<p>To facilitate understanding of how Diode works, the diagram below illustrates the architecture of its main components and how they communicate with each other:</p> <p>foto do diagrama</p>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/","title":"Installing the Diode Client","text":"<p>The Diode Client is responsible for sending the collected data to the Diode Server using gRPC/Protobuf, allowing for the subsequent ingestion of this information into NetBox.</p> <p>There are different ways to use the Client. This documentation will present the use of the Orb Agent, developed by NetBox Labs. This agent not only performs automated network and device discovery, but also offers observability features on the monitored equipment.</p> <p>Alternatively, as described in the official NetBox documentation, the Diode Client can also be used as a Python SDK, ideal for integrating custom scripts that collect and send data to the Diode Server.</p>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#plugin-repository","title":"Plugin Repository","text":"<p>Copy the link below or click to access the Github Repository</p> <pre><code>https://github.com/netboxlabs/orb-agent\n</code></pre>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#1-installation-requirements","title":"1. Installation Requirements","text":"<p>This documentation used the following components with their respective versions:</p> Components Versions Netbox v4.1.11 Orb Agent v1.2.0"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#2-files-required-for-installation","title":"2. Files Required for Installation","text":"<ol> <li>First, let's create a new folder to download the Diode Server files. <pre><code>mkdir orb-agent\ncd orb-agent\n</code></pre></li> </ol> <p>Now, let's create the necessary files for the Orb-Agent installation</p>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#21-docker-composeyml","title":"2.1. <code>docker-compose.yml</code>","text":"<ol> <li>First, let's create the file with the following command: <pre><code>nano docker-compose.yml\n</code></pre></li> <li>Now copy the content below and paste it into the file. <pre><code>services:\n  orb-agent:\n    image: docker.io/netboxlabs/orb-agent:${ORB_TAG:-latest}\n    command: run -c /opt/orb/agent.yaml\n    volumes: \n      - ./:/opt/orb/\n    networks:\n      - orb-net\nnetworks:\n  orb-net:\n    external: true\n    name: ${DOCKER_NETWORK}\n</code></pre></li> </ol> <p>The agent needs to be on the same network as the devices to be imported. Since we are in a docker environment, let's add it to the default laboratory network <code>br-lab</code>.</p>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#22-env","title":"2.2. <code>.env</code>","text":"<p>The file containing the variables responsible for configuring the Orb-Agent.</p> <ol> <li> <p>First, let's create the file with the following command: <pre><code>nano .env\n</code></pre></p> </li> <li> <p>To fill the <code>DOCKER_SUBNET</code> variable with the subnet of the <code>br-lab</code> network, use the command: <pre><code>docker network inspect br-lab | grep \"Subnet\"\n</code></pre></p> </li> <li> <p>Now copy the content below and paste it into the file. <pre><code>ORB_TAG=1.2.0\nDOCKER_NETWORK=br-lab # docker network\n\n# Docker network where the agent will collect IPs\nDOCKER_SUBNET=172.10.10.0/24\n\n# API Key for connection with Diode Server -&gt; diode-ingestion\nDIODE_API_KEY=507006398ea55f210835a66ee98b2a301d9abf6d\n\n# Diode Server URL\nDIODE_HOST=172.10.10.120:80 \n\n# Your choice\nAGENT_NAME=agent1 # Agent name\nSITE_NAME=RNP # Site name to be added/created in Netbox\nSCHEDULE='\"*/10 * * * *\"' # Time interval for re-collecting data\n</code></pre></p> </li> <li> <p>After defining the variables, use the commands below to allow and export the variables in your environment: <pre><code>set -o allexport\nsource .env\n</code></pre></p> </li> </ol>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#23-agentyaml","title":"2.3. <code>agent.yaml</code>","text":"<p>In the Orb-Agent, configurations are defined through the <code>agent.yaml</code> file. It is in this file that we configure the connection with the Diode Server, specify the location for importing variables or access credentials, and define the types of discovery that the agent should perform.</p>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#231-config-manager","title":"2.3.1. Config Manager","text":"<p>The <code>config_manager</code> section defines how the Orb-Agent should obtain its configuration information. The configuration manager is responsible for processing this data, retrieving the defined policies, and passing them on to the appropriate backend. See other methods in the documentation</p> <pre><code>orb:\n  config_manager:\n    active: local\n  ...\n</code></pre>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#232-secrets-manager","title":"2.3.2. Secrets Manager","text":"<p>The <code>secrets_manager</code> section defines how the Orb-Agent should obtain and inject secrets (such as passwords and tokens) into policies. This manager can connect to external secret repositories, such as HashiCorp Vault, to securely retrieve sensitive information, preventing it from being written directly in the configuration files. See other methods in the documentation</p> <pre><code>orb:\n  secrets_manager:\n    active: vault\n    sources:\n      vault:\n        address: \"https://vault.example.com:8200\"\n        namespace: \"my-namespace\"\n        timeout: 60\n        auth: \"token\"\n        auth_args:\n          token: \"${VAULT_TOKEN}\"\n        schedule: \"*/5 * * * *\"\n  ...\n</code></pre> <p>In our case we will not use this section</p>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#233-backends","title":"2.3.3. Backends","text":"<p>This section defines how the Orb-Agent backends should be activated. It has the following options:</p> <ul> <li>Device Discovery</li> <li>Network Discovery</li> <li>Worker</li> </ul> <pre><code>orb:\n  ...\n  backends:\n    network_discovery:\n    ...\n</code></pre>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#234-common","title":"2.3.4. Common","text":"<p>The special <code>common</code> subsection, within the backends section, defines settings that are shared among all backends. Currently, this section allows passing the Diode server connection settings to all backends in a centralized manner.</p> <pre><code>backends:\n  ...\n  common:\n    diode:\n      target: grpc://${DIODE_HOST}/diode\n      client_id: ${DIODE_CLIENT_ID}\n      client_secret: ${DIODE_CLIENT_SECRET}\n      agent_name: agent01\n</code></pre>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#235-policies","title":"2.3.5. Policies","text":"<p>The <code>policies</code> section defines which discovery policies should be assigned to each backend. Each policy describes specific settings for the discovery type, such as scheduling, default properties, and scope (targets).</p> <p>Each backend can execute multiple policies at the same time, as long as each has a unique name within that backend. These policies are grouped into subsections according to the responsible backend.</p> <pre><code>orb:\n ...\n policies:\n   device_discovery:\n     device_policy_1:\n       # See docs/backends/device_discovery.md\n   network_discovery:\n     network_policy_1:\n      # See docs/backends/network_discovery.md\n   worker:\n     worker_policy_1:\n      # See docs/backends/worker.md\n</code></pre> <p>Links:</p> <ul> <li> <p>Device Discovery</p> </li> <li> <p>Network Discovery</p> </li> <li> <p>Worker</p> </li> </ul>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#3-agenttemplateyaml","title":"3. <code>agent.template.yaml</code>","text":"<p>After understanding a bit of the Orb-Agent structure, let's move on to a practical example with a simple template that can be used to map the <code>br-lab</code> docker network and some devices in it. In this file we will use the backends: <code>network_discovery</code> and <code>device_discovery</code>.</p> <p>Tip</p> <p>Remember: the <code>Orb-Agent</code> uses the <code>agent.yaml</code> file as a configuration base. This file must be generated in your local environment and, when uploading the container, it needs to be copied into it.</p> <ol> <li> <p>Let's create the <code>agent.template.yaml</code> file. <pre><code>nano agent.template.yaml\n</code></pre></p> </li> <li> <p>Now, copy and paste the content into the created file: <pre><code>orb:\n  config_manager:\n    active: local\n  backends:\n      device_discovery:\n    network_discovery:\n    common:\n      diode:\n        target: grpc://${DIODE_HOST}/diode\n        api_key: ${DIODE_API_KEY}\n        agent_name: ${AGENT_NAME}\n  policies:\n    network_discovery:\n      policy_1:\n        scope:\n          targets:\n            - ${DOCKER_SUBNET}\n    device_discovery:\n      discovery_1:\n        config:\n          schedule: ${SCHEDULE}\n          defaults:\n            site: ${SITE_NAME}\n        scope:\n          - driver: junos\n            hostname: 172.10.10.101\n            username: admin\n            password: admin@123\n            optional_args:\n              insecure: True\n          - driver: junos\n            hostname: 172.10.10.102\n            username: admin\n            password: admin@123\n            optional_args:\n              insecure: True\n          - driver: junos\n            hostname: 172.10.10.103\n            username: admin\n            password: admin@123\n            optional_args:\n              insecure: True\n</code></pre></p> </li> <li> <p>Now let's generate the <code>agent.yaml</code> file according to the variables defined in <code>.env</code>. <pre><code>envsubst &lt; agent.template.yaml &gt; agent.yaml\n</code></pre></p> </li> <li> <p>Check if the file fills all variable spaces with their respective values. Your output should be something similar to: <pre><code>orb:\n  config_manager:\n    active: local\n  backends:\n    device_discovery:\n    network_discovery:\n    common:\n      diode:\n        target: grpc://172.10.10.120:80/diode\n        api_key: 507006398ea55f210835a66ee98b2a301d9abf6d\n        agent_name: agent1\n  policies:\n    network_discovery:\n      policy_1:\n        scope:\n          targets:\n            - 172.10.10.0/24\n    device_discovery:\n      discovery_1:\n        config:\n          schedule: \"*/10 * * * *\"\n          defaults:\n            site: RNP\n        scope:\n          - driver: junos\n            hostname: 172.10.10.101\n            username: admin\n            password: admin@123\n            optional_args:\n              insecure: True\n          - driver: junos\n            hostname: 172.10.10.102\n            username: admin\n            password: admin@123\n            optional_args:\n              insecure: True\n          - driver: junos\n            hostname: 172.10.10.103\n            username: admin\n            password: admin@123\n            optional_args:\n              insecure: True\n</code></pre></p> </li> </ol>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#4-deploy","title":"4. Deploy!","text":"<p>With the Orb-Agent compose configured and the <code>agent.yaml</code> file generated, it's now time to put it into execution.</p> <ul> <li> <p>Run the command below to start all services defined in docker-compose.yml: <pre><code>docker compose up # or to run in the background\ndocker compose up -d \n</code></pre></p> </li> <li> <p>This configuration should return the IPs of the <code>172.10.10.0/24</code> network and the data of the three devices defined every 10 minutes.</p> </li> </ul>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Client/#5-conclusion","title":"5. Conclusion","text":"<p>With the Orb-Agent properly configured and running, you have a powerful automation and active discovery tool in your network. It allows the continuous and structured collection of data about devices and infrastructure, sending this information directly to NetBox via Diode Server, securely and flexibly.</p> <p>Whether using custom policies or integrating with secrets and configuration managers, the Orb-Agent facilitates the scalability of network asset management and significantly contributes to keeping your environment updated, consistent, and documented.</p> <p>In the next steps, you will be able to expand the discoveries, refine specific policies for different backends, and take advantage of the potential of NetBox as the source of truth for your infrastructure.</p>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Plugin/","title":"Installing the Diode Plugin","text":"<p>The Diode Plugin is an essential component to enable automated data ingestion into NetBox. It provides direct integration with the NetBox ORM and manages API keys, allowing the Diode server to send structured data securely and validated. With this plugin, NetBox receives real-time inventory updates, facilitating the discovery, documentation, and continuous synchronization of the network infrastructure.</p>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Plugin/#plugin-repository","title":"Plugin Repository","text":"<p>Copy the link below or click to access the Github Repository</p> <pre><code>https://github.com/netboxlabs/diode-netbox-plugin\n</code></pre>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Plugin/#1-installation-requirements","title":"1. Installation Requirements","text":"<p>This documentation used the following components with their respective versions:</p> Components Versions Netbox v4.1.11 Diode Plugin v0.6.0"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Plugin/#2-installing-and-configuring-the-plugin-in-netbox","title":"2. Installing and Configuring the Plugin in Netbox","text":"<p>To install the plugin in Netbox, we need to change and add some files that are responsible for the Netbox configuration.</p> <p>The files are:</p> <ul> <li><code>plugin_requirements.txt</code>.</li> <li><code>DockerFile-Plugins</code>.</li> <li><code>docker-compose.override.yml</code>.</li> <li><code>configuration/plugins.py</code>.</li> </ul>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Plugin/#21-configuring-the-netbox-version","title":"2.1. Configuring the Netbox version:","text":"<ol> <li> <p>First, let's clone the Netbox repository: <pre><code>git clone -b release https://github.com/netbox-community/netbox-docker.git\n</code></pre></p> </li> <li> <p>Access the cloned directory: <pre><code>cd netbox-docker\n</code></pre></p> </li> <li> <p>Now, switch to release 3.0.0 <pre><code>git checkout 3.0.0\n</code></pre></p> </li> </ol> <p>Information</p> <p>We changed the repository branch to have access to Netbox version 4.1.11.</p> <p>Tip</p> <p>All commands below will be executed within the root directory of netbox <code>netbox-docker/</code>.</p>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Plugin/#22-plugin_requirementstxt","title":"2.2. plugin_requirements.txt","text":"<p>This file contains a list of Netbox plugins (as PyPI Python packages) to be installed during the Docker image build.</p> <p>Execute the following command to write the package inside the <code>plugin_requirements.txt</code> file.</p> <pre><code>echo \"netboxlabs-diode-netbox-plugin\" &gt; plugin_requirements.txt\n</code></pre>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Plugin/#23-dockerfile-plugins","title":"2.3. DockerFile-Plugins","text":"<p>This is the DockerFile used to build the customized docker image.</p> <ol> <li> <p>Create the file and access it with an editor: <pre><code>nano DockerFile-Plugins\n</code></pre></p> </li> <li> <p>Copy the content below and paste it into the file: <pre><code>FROM netboxcommunity/netbox:v4.1\n\nCOPY ./plugin_requirements.txt /opt/netbox/\nRUN pip install -r /opt/netbox/plugin_requirements.txt\n</code></pre></p> </li> </ol>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Plugin/#24-docker-composeoverrideyml","title":"2.4. docker-compose.override.yml","text":"<p>As the name implies, this file contains the settings that will override <code>docker-compose.yml</code>.</p> <p>If you have not yet configured the <code>br-lab</code> network, access: Configuring the Docker Network</p> <ol> <li> <p>Create the file and access it with an editor: <pre><code>nano docker-compose.override.yml\n</code></pre></p> </li> <li> <p>Copy the content below and paste it into the file: <pre><code>services:\n  netbox:\n    image: netbox:latest-plugins\n    pull_policy: never\n    ports:\n      - 8000:8080\n    build:\n      context: .\n      dockerfile: Dockerfile-Plugins\n    networks:\n      br-lab:\n        ipv4_address: 172.10.10.5\n\n  netbox-worker:\n    image: netbox:latest-plugins\n    pull_policy: never\n    networks:\n      - br-lab\n\n  netbox-housekeeping:\n    image: netbox:latest-plugins\n    pull_policy: never\n    networks:\n      - br-lab\n\n  postgres:\n    networks:\n      - br-lab\n\n  redis:\n    networks:\n      - br-lab\n\n  redis-cache:\n    networks:\n      - br-lab\n\nnetworks:\n  br-lab:\n    external: true\n</code></pre></p> </li> </ol> <p>The changes made were:</p> <ul> <li>adding Netbox to the <code>br-lab</code> network.</li> <li>changing the dockerfile to <code>Dockerfile-Plugins</code>, created previously.</li> <li>Also changed the image of the services to: <code>netbox:latest-plugins</code>.</li> </ul>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Plugin/#25-pluginspy","title":"2.5. plugins.py","text":"<p>This file is responsible for setting the specific configurations for each plugin.</p> <ol> <li> <p>Access the file with the editor: <pre><code>nano configuration/plugins.py\n</code></pre></p> </li> <li> <p>Copy and paste the content into the file: <pre><code>PLUGINS = [\n    \"netbox_diode_plugin\",\n]\n\nPLUGINS_CONFIG = {\n    \"netbox_diode_plugin\": {\n        # Auto-provision users for Diode plugin\n        \"auto_provision_users\": True,\n\n        # Diode gRPC target for communication with Diode server\n        \"diode_target_override\": \"grpc://172.10.10.120:80/diode\",\n\n        # User allowed for Diode to NetBox communication\n        \"diode_to_netbox_username\": \"diode-to-netbox\",\n\n        # User allowed for NetBox to Diode communication\n        \"netbox_to_diode_username\": \"netbox-to-diode\",\n\n        # User allowed for data ingestion\n        \"diode_username\": \"diode-ingestion\",\n    },\n}\n</code></pre></p> </li> </ol> <p>Tip</p> <p>We suggest leaving the <code>auto_provision_users</code> configuration as <code>True</code> to automate the creation of user, groups, and API keys that are responsible for integration with the Diode Server.</p>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Plugin/#3-build-and-deploy","title":"3. Build and Deploy!","text":"<p>Now your Netbox is configured and ready for deployment, follow the commands below and build the new Netbox instance!</p> <ol> <li> <p>Build the image: <pre><code>docker compose build --no-cache\n</code></pre></p> </li> <li> <p>Start the containers: <pre><code>docker compose up -d\n</code></pre></p> </li> </ol>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Plugin/#4-next-steps","title":"4. Next Steps","text":"<p>With the Diode plugin installed, your NetBox environment is now ready to receive data from the Diode server, allowing automated ingestion of network information.</p> <p>The next step is to configure the Diode Server, which is responsible for processing and forwarding this data to NetBox.</p> <p>Next: Installing the Diode Server</p>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Server/","title":"Installing the Diode Server","text":"<p>The Diode Server is the central component of the Diode architecture. It is responsible for receiving, processing, and reconciling data sent by clients (scripts or agents) and integrating it into NetBox. Utilizing modern protocols such as gRPC and efficient formats such as Protobuf, the Diode Server validates the received information and executes the automated update of the inventory in NetBox via the API exposed by the plugin.</p> <p>This server acts as an intelligent intermediary, ensuring that the entered data is correct, complete, and synchronized with existing records.</p>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Server/#plugin-repository","title":"Plugin Repository","text":"<p>Copy the link below or click to access the Github Repository</p> <pre><code>https://github.com/netboxlabs/diode-netbox-plugin\n</code></pre>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Server/#1-installation-requirements","title":"1. Installation Requirements","text":"<p>This documentation used the following components with their respective versions:</p> Components Versions Netbox v4.1.11 Diode Server v0.6.0"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Server/#2-downloading-the-installation-files","title":"2. Downloading the Installation Files","text":"<ol> <li> <p>First, let's create a new folder to download the Diode Server files. <pre><code>mkdir diode-server\ncd diode-server\n</code></pre></p> </li> <li> <p>Now, download the necessary files for installation <pre><code>curl -o docker-compose.yaml https://raw.githubusercontent.com/netboxlabs/diode/refs/tags/diode-reconciler/v0.6.0/diode-server/docker/docker-compose.yaml\ncurl -o .env https://raw.githubusercontent.com/netboxlabs/diode/refs/tags/diode-reconciler/v0.6.0/diode-server/docker/sample.env\n</code></pre></p> </li> </ol>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Server/#3-configuring-the-diode-server","title":"3. Configuring the Diode Server","text":"<p>Let's change the <code>.env</code> variables file and create a new <code>docker-compose.override.yml</code> file to override the docker-compose configurations.</p>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Server/#env","title":"<code>.env</code>","text":"<p>Here we need to change some variables to connect the Diode server to our environment:</p> <pre><code># Default, no need to change\nREDIS_PASSWORD=@FmnLoA*VnebyVnZoL.!-.6z\nREDIS_HOST=diode-redis\nREDIS_PORT=6378\nRECONCILER_GRPC_HOST=diode-reconciler\nRECONCILER_GRPC_PORT=8081\nLOGGING_LEVEL=DEBUG\nMIGRATION_ENABLED=true\nMIGRATION_ENABLED=true\nDIODE_TAG=0.6.0\n\n# If you are not using Graphite, you can leave the default port 8080\nDIODE_NGINX_PORT=81\n\n# Diode Plugin API URL in Netbox\nNETBOX_DIODE_PLUGIN_API_BASE_URL=http://172.10.10.5:8080/api/plugins/diode\n\nNETBOX_DIODE_PLUGIN_SKIP_TLS_VERIFY=true # If using Https, can leave as false\n\n# API Key generated in the Diode plugin installation -&gt; diode-to-netbox\nDIODE_TO_NETBOX_API_KEY=\n\n# API Key generated in the Diode plugin installation -&gt; netbox-to-diode\nNETBOX_TO_DIODE_API_KEY=\n\n# API Key generated in the Diode plugin installation -&gt; diode-ingestion\nDIODE_API_KEY=\n\n# API Key to authorize RPC calls between the Ingester and the Reconciler.\n# Example shell command to generate: openssl rand -base64 40 | head -c 40\nINGESTER_TO_RECONCILER_API_KEY=sXjJZe6BBzVuovrVyyH4Q3vbceqvDwh2kC3DRpML\n</code></pre> <p>Tip</p> <p>The API keys <code>DIODE_TO_NETBOX_API_KEY</code>, <code>NETBOX_TO_DIODE_API_KEY</code> and <code>DIODE_API_KEY</code> can be viewed in Netbox under: Side Menu &gt; Diode &gt; Configurations</p>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Server/#docker-composeoverrideyml","title":"<code>docker-compose.override.yml</code>","text":"<p>This file is responsible for changing the <code>docker-compose</code> settings by overwriting its configurations.</p> <ol> <li>First, let's create the file with the following command: <pre><code>nano docker-compose.override.yml\n</code></pre></li> <li>Now copy the content below and paste it into the file. <pre><code>services:\n  ingress-nginx:\n    networks:\n      br-lab:\n        ipv4_address: 172.10.10.120\n  diode-ingester:\n    networks:\n      - br-lab\n  diode-reconciler:\n    networks:\n      - br-lab\n  diode-redis:\n    networks:\n      - br-lab\nnetworks:\n  br-lab:\n    external: true\n</code></pre></li> </ol>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Server/#4-deploy","title":"4. Deploy!","text":"<p>With the Diode server properly configured, it's now time to put it into operation.</p> <ul> <li> <p>Run the command below to start all services defined in docker-compose.yml: <pre><code>docker compose up -d\n</code></pre></p> </li> <li> <p>Check if all services have the UP status <pre><code>docker compose ps\n</code></pre> <pre><code>NAME                       IMAGE                                STATUS\ndiode-diode-ingester-1     netboxlabs/diode-ingester:0.6.0      Up\ndiode-diode-reconciler-1   netboxlabs/diode-reconciler:0.6.0    Up\ndiode-diode-redis-1        redis/redis-stack-server:latest      Up\ndiode-ingress-nginx-1      nginx:latest                         Up\n</code></pre></p> </li> </ul>"},{"location":"en/Guias/Netbox/Plugins/Diode/Instalando%20o%20Diode%20Server/#5-next-steps","title":"5. Next Steps","text":"<p>With the Diode server running, we are almost finishing the automation of network device discovery and import into NetBox.</p> <p>The next step is to configure the Diode Client, the component responsible for collecting information directly from the devices and sending it to the Diode server for processing.</p> <p>Next: Installing the Diode Client</p>"},{"location":"en/Guias/Netbox/Plugins/Napalm/","title":"Napalm Plugin","text":"<p>The Napalm plugin for NetBox allows you to integrate real-time data collection functionalities directly from network devices configured in the system. With it, you can obtain up-to-date information such as operational status, neighbors (LLDP/CDP), and equipment configurations, enriching the visualization and management of assets in NetBox. This integration makes the tool more dynamic, bringing the documentation closer to the current reality of the network.</p>"},{"location":"en/Guias/Netbox/Plugins/Napalm/#plugin-repository","title":"Plugin Repository","text":"<p>Copy the link below or click to access the Github Repository</p> <pre><code>https://github.com/netbox-community/netbox-napalm-plugin\n</code></pre>"},{"location":"en/Guias/Netbox/Plugins/Napalm/#1-installation-requirements","title":"1. Installation Requirements","text":"<p>This documentation used the following components with their respective versions:</p> Components Versions Netbox v4.1.11 Napalm Plugin v0.3.1 <p>The following functionalities were tested in the documentation:</p> Functionalities Working Status Page \u2705 LLDP Neighbors Page \u2705 Config Page \u2705"},{"location":"en/Guias/Netbox/Plugins/Napalm/#2-installing-and-configuring-the-plugin-in-netbox","title":"2. Installing and Configuring the Plugin in Netbox","text":"<p>To install the plugin in Netbox, we need to modify and add some files that are responsible for the Netbox configuration.</p> <p>The files are:</p> <ul> <li><code>plugin_requirements.txt</code>.</li> <li><code>DockerFile-Plugins</code>.</li> <li><code>docker-compose.override.yml</code>.</li> <li><code>configuration/plugins.py</code>.</li> </ul>"},{"location":"en/Guias/Netbox/Plugins/Napalm/#21-configuring-the-netbox-version","title":"2.1 Configuring the Netbox version:","text":"<ol> <li> <p>First, let's clone the Netbox repository: <pre><code>git clone -b release https://github.com/netbox-community/netbox-docker.git\n</code></pre></p> </li> <li> <p>Access the cloned directory: <pre><code>cd netbox-docker\n</code></pre></p> </li> <li> <p>Now, switch to release 3.0.0 <pre><code>git checkout 3.0.0\n</code></pre></p> </li> </ol> <p>Information</p> <p>We changed the repository branch to have access to Netbox version 4.1.11.</p> <p>Tip</p> <p>All commands below will be executed inside the root directory of netbox <code>netbox-docker/</code>.</p>"},{"location":"en/Guias/Netbox/Plugins/Napalm/#22-plugin_requirementstxt","title":"2.2 plugin_requirements.txt","text":"<p>This file contains a list of Netbox plugins (as Python packages from PyPI) that should be installed during the Docker image build.</p> <p>Execute the following command to write the package inside the <code>plugin_requirements.txt</code> file.</p> <pre><code>echo \"netbox-napalm-plugin\" &gt; plugin_requirements.txt\n</code></pre>"},{"location":"en/Guias/Netbox/Plugins/Napalm/#23-dockerfile-plugins","title":"2.3 DockerFile-Plugins","text":"<p>This is the DockerFile used to build the customized docker image.</p> <ol> <li> <p>Create the file and access it with an editor: <pre><code>nano DockerFile-Plugins\n</code></pre></p> </li> <li> <p>Copy the content below and paste it into the file: <pre><code>FROM netboxcommunity/netbox:v4.1\n\nCOPY ./plugin_requirements.txt /opt/netbox/\nRUN pip install -r /opt/netbox/plugin_requirements.txt\n</code></pre></p> </li> </ol>"},{"location":"en/Guias/Netbox/Plugins/Napalm/#24-docker-composeoverrideyml","title":"2.4 docker-compose.override.yml","text":"<p>As the name implies, this file contains the settings that will override <code>docker-compose.yml</code>.</p> <p>If you have not yet configured the <code>br-lab</code> network, access: Configuring the Docker Network</p> <ol> <li> <p>Create the file and access it with an editor: <pre><code>nano docker-compose.override.yml\n</code></pre></p> </li> <li> <p>Copy the content below and paste it into the file: <pre><code>services:\n  netbox:\n    image: netbox:latest-plugins\n    pull_policy: never\n    ports:\n      - 8000:8080\n    build:\n      context: .\n      dockerfile: Dockerfile-Plugins\n    networks:\n      - br-lab\n\n  netbox-worker:\n    image: netbox:latest-plugins\n    pull_policy: never\n    networks:\n      - br-lab\n\n  netbox-housekeeping:\n    image: netbox:latest-plugins\n    pull_policy: never\n    networks:\n      - br-lab\n\n  postgres:\n    networks:\n      - br-lab\n\n  redis:\n    networks:\n      - br-lab\n\n  redis-cache:\n    networks:\n      - br-lab\n\nnetworks:\n  br-lab:\n    external: true\n</code></pre></p> </li> </ol> <p>The changes made were:</p> <ul> <li>Adding Netbox to the <code>br-lab</code> network.</li> <li>Changing the dockerfile to <code>Dockerfile-Plugins</code>, created previously.</li> <li>Also changed the image of the services to: <code>netbox:latest-plugins</code>.</li> </ul>"},{"location":"en/Guias/Netbox/Plugins/Napalm/#25-pluginspy","title":"2.5 plugins.py","text":"<p>This file is responsible for setting the specific configurations for each plugin.</p> <ol> <li> <p>Access the file with the editor: <pre><code>nano configuration/plugins.py\n</code></pre></p> </li> <li> <p>Copy and paste the content into the file: <pre><code>PLUGINS = [\n    \"netbox_napalm_plugin\"\n]\n\nPLUGINS_CONFIG = {\n    \"netbox_napalm_plugin\": {\n        \"NAPALM_USERNAME\": \"admin\", # User for accessing the equipment\n        \"NAPALM_PASSWORD\": \"admin@123\", # Password for accessing the equipment\n    },\n}\n</code></pre></p> </li> </ol>"},{"location":"en/Guias/Netbox/Plugins/Napalm/#3-build-and-deploy","title":"3. Build and Deploy!","text":"<p>Now your Netbox is configured and ready for deployment, follow the commands below and build the new Netbox instance!</p> <ol> <li> <p>Build the image: <pre><code>docker compose build --no-cache\n</code></pre></p> </li> <li> <p>Bring up the containers: <pre><code>docker compose up -d\n</code></pre></p> </li> </ol> <p>After the containers come up, execute the commands below to copy the static files requested by the Napalm plugin.</p> <ol> <li> <p>First, change the permissions of the files using the command below: <pre><code>docker compose exec -it --user root netbox chmod -R a+w /opt/netbox/netbox/static\n</code></pre></p> </li> <li> <p>Then, execute the command to copy the static files: <pre><code>docker compose exec netbox python3 manage.py collectstatic --noinput\n</code></pre></p> </li> </ol>"},{"location":"en/Guias/Netbox/Plugins/Napalm/#4-configuring-napalm","title":"4. Configuring Napalm","text":"<p>Now, with Netbox already configured and working, let's configure and better understand how Napalm works.</p> <p>Important points, to activate the Napalm plugin we need the following requirements:</p> <ul> <li>Napalm Platform Configs</li> <li>Device<ul> <li>Device Role</li> <li>Device Type</li> <li>Status: Active</li> <li>Platform</li> <li>Primary IPv4</li> <li>Interfaces (To display the LLDP Neighbors tab)</li> </ul> </li> </ul>"},{"location":"en/Guias/Netbox/Plugins/Napalm/#41-napalm-platform-configs","title":"4.1 Napalm Platform Configs","text":"<p>Access your Netbox and follow the instructions below.</p> <ol> <li>In the side menu, go to Plugin \u2192 Napalm.</li> <li>Click the Add button.</li> <li><code>Platform</code>: Select a platform (e.g., junos)</li> <li><code>NAPALM driver</code>: Here is the name of the driver used by Napalm to collect data from devices. To see the available drivers, go to Supported Devices. In this case, we will use junos.</li> <li><code>NAPALM arguments</code>(Optional): Arguments passed when initializing the NAPALM driver. Arguments at: Optional Arguments. In our case, we will not fill it in.</li> <li>Click Create.</li> </ol> <p>Ready! now we have the Platform Config created for accessing our devices!</p>"},{"location":"en/Guias/Netbox/Plugins/Napalm/#42-configuring-a-device","title":"4.2 Configuring a Device","text":"<p>To test the Napalm plugin, we need devices to query, for that, we will use the Discovery laboratory More information. Therefore, add at least one device to Netbox.</p>"},{"location":"en/Guias/Netbox/Plugins/Napalm/#421-adding-the-routers","title":"4.2.1 Adding the Routers","text":"<ol> <li> <p>Clone the lab repository: <pre><code>git clone https://git.rnp.br/redes-abertas/labs/-/tree/main/discovery-lab\n</code></pre></p> </li> <li> <p>Enter the repository: <pre><code>cd discovery-lab/\n</code></pre></p> </li> <li> <p>Start the topology with the command: <pre><code>sudo clab deploy -t clab/discovery-lab.clab.yaml\n</code></pre></p> </li> </ol> <p>Debug</p> <p>The devices may take about 10 minutes to become fully operational. If an error occurs, check the command output for possible error messages. Use <code>docker logs &lt;container_name&gt;</code> to debug.</p>"},{"location":"en/Guias/Netbox/Plugins/Napalm/#422-adding-the-router-to-netbox","title":"4.2.2 Adding the router to Netbox.","text":"<p>Create Site</p> <ol> <li>Go to Sites \u2192 click Add.</li> <li>Fill in the fields:</li> <li>Name: <code>RNP</code></li> <li>Click on Create.</li> </ol> <p>Create the Manufacturer</p> <ol> <li>Go to Devices \u2192 Manufacturers \u2192 Add.</li> <li>Fill in:</li> <li>Name: <code>Juniper</code></li> <li>Slug: <code>juniper</code> (or automatically generated)</li> <li>Click on Create.</li> </ol> <p>Create the Device Type</p> <ol> <li>Go to Devices \u2192 Device Types \u2192 Add.</li> <li>Fill in:</li> <li>Manufacturer: <code>Juniper</code></li> <li>Model: <code>VMX</code></li> <li>Click on Create.</li> </ol> <p>Create the Device</p> <ol> <li>Go to Devices \u2192 click Add.</li> <li>Fill in:</li> <li>Name: <code>JPA</code></li> <li>Device Role: <code>Router</code> (create if necessary)</li> <li>Device Type: <code>VMX</code></li> <li>Site: <code>RNP</code></li> <li>Status: <code>Active</code></li> <li>Click on Create.</li> </ol> <p>Create Interface</p> <ol> <li>Access the <code>JPA</code> device.</li> <li>Go to the Interfaces tab \u2192 click Add Interface.</li> <li>Fill in:</li> <li>Name: <code>ge-0/0/2</code></li> <li>Type: <code>Virtual</code></li> <li>Click on Create.</li> </ol> <p>Create IP Address</p> <ol> <li>Go to IPAM \u2192 IP Addresses \u2192 Add.</li> <li>Fill in:</li> <li>Address: <code>172.10.10.101/32</code></li> <li>Status: <code>Active</code></li> <li>Interface Assignment:<ul> <li>Device: <code>JPA</code></li> <li>Interface: <code>ge-0/0/2</code></li> </ul> </li> <li>Click on Create.</li> </ol> <p>Adding Primary IPv4 on the Device</p> <ol> <li>Go to Devices</li> <li>Click on JPA and then Edit</li> <li>In Management \u2192 Primary IPv4: Select <code>172.10.10.101/32 (ge-0/0/2)</code></li> </ol>"},{"location":"en/Guias/Netbox/Plugins/Napalm/#5-viewing-the-plugin","title":"5. Viewing the Plugin","text":"<p>After registration, on the device tab, access JPA.</p> <p>Now you should be seeing the additional tabs of the Napalm plugin.</p> <ul> <li>Status</li> <li>LLDP Neighbors</li> <li>Config</li> </ul>"},{"location":"en/Guias/Netbox/Plugins/Napalm/#51-status","title":"5.1 Status","text":"<p>The Status tab, enabled through the integration of NetBox with the NAPALM plugin, displays real-time operational information of the network device. This functionality allows the administrator to quickly monitor the current state of the equipment without leaving the NetBox interface.</p> <p> Key Information Presented:</p> <ul> <li> <p>Device Facts: Basic and static data of the device, such as:</p> <ul> <li> <p><code>Hostname</code>: Device identification on the network (e.g., JPA)</p> </li> <li> <p><code>Vendor / Model</code>: Equipment manufacturer and model (e.g., Juniper VMX)</p> </li> <li> <p><code>Serial Number</code>: Hardware serial number</p> </li> <li> <p><code>OS Version</code>: Operating system version (e.g., 22.2R1.9)</p> </li> <li> <p><code>Uptime</code>: Time since the last boot, with recorded date and time</p> </li> </ul> </li> <li> <p>Environment: Environmental and performance metrics that help in preventive maintenance and operation:</p> <ul> <li> <p><code>CPU Usage</code>: Current usage of the CPU(s), presented per core</p> </li> <li> <p><code>Memory</code>: Amount of memory available and used</p> </li> <li> <p><code>Temperature, Fans, Power (PSUs)</code>: Status of sensors and power supplies (if the equipment provides this data)</p> </li> </ul> </li> </ul> <p></p> <p> Purpose:</p> <p>This tab is especially useful for quick diagnostics, audits, and monitoring device health, eliminating the need for manual login via SSH or console. The information is updated dynamically through the NAPALM API, as long as it is correctly configured in NetBox.</p>"},{"location":"en/Guias/Netbox/Plugins/Napalm/#52-lldp-neighbors","title":"5.2 LLDP Neighbors","text":"<p>This functionality displays the layer 2 neighbors detected through the LLDP (Link Layer Discovery Protocol) protocol. This functionality allows you to automatically identify devices connected directly to the monitored equipment.</p> <p> Important Behavior:</p> <ul> <li> <p>The visualization of neighbors is limited to the interfaces previously registered in NetBox.</p> </li> <li> <p>If an interface exists on the actual device but has not been created in NetBox, the neighbors discovered by it will not be displayed.</p> </li> </ul> <p></p> <p> Purpose:</p> <p>This tab is useful for validating physical connections between devices, checking the network topology in real time, and detecting cabling or port configuration errors, in an automated manner and integrated into the NetBox interface.</p>"},{"location":"en/Guias/Netbox/Plugins/Napalm/#53-config","title":"5.3 Config","text":"<p>The Config tab allows direct viewing of the network device's configurations, extracted remotely via the API. It presents different versions of the configuration file, useful for comparison, auditing, and troubleshooting.</p> <p> Types of Configurations Displayed:</p> <ul> <li> <p><code>Startup Config</code>: The configuration that will be loaded when the device is restarted. Represents the persistent state.</p> </li> <li> <p><code>Running Config</code>: The configuration currently running on the device. May include unsaved changes.</p> </li> <li> <p><code>Candidate Config</code> (when supported by the operating system): Configuration being edited that has not yet been applied. Present on equipment that works with configuration staging (e.g., Juniper).</p> </li> </ul> <p></p> <p> Purpose:</p> <p>This tab is essential for managing and tracking changes in the configuration of devices, as well as providing a practical and secure way to validate whether persistent configurations are in accordance with those in execution \u2014 all within the NetBox interface. without changing the structure of the documentation. or add anything, and do not change the links or references.</p>"},{"location":"en/Guias/Netbox/Render_Templates/","title":"Render Templates","text":"<p>Render Templates in NetBox are a powerful tool that allows you to dynamically generate network configurations customized for each device. These templates use the Jinja2 markup language to process variables and render configuration files based on the information stored in the NetBox database.</p>"},{"location":"en/Guias/Netbox/Render_Templates/#1-adding-templates","title":"1. Adding Templates","text":""},{"location":"en/Guias/Netbox/Render_Templates/#11-remote-templates","title":"1.1 Remote Templates","text":"<p>Remote templates are available online in a Git repository. To add our template repository, follow the steps below:</p>"},{"location":"en/Guias/Netbox/Render_Templates/#adding-the-repository","title":"Adding the Repository","text":"<ol> <li>Access NetBox and go to Customization &gt; Data Sources &gt; Add.</li> <li>Define a name of your choice and select the type as Git.</li> <li>In the URL, add the following link to use the template:</li> </ol> <pre><code>https://git.rnp.br/redes-abertas/config-templates-data-source.git\n</code></pre> <p>Attention</p> <p>If the repository is private, add your authentication method in the backend parameters.</p> <ol> <li>Click Create.</li> <li>Click on the data source that was created, and then click Sync to analyze the repository.</li> </ol> <p>If the synchronization is successful, a \"Completed\" message will appear in the Status section.</p> <ol> <li>Now you can view the templates in the Provisioning &gt; Configuration Templates tab.</li> </ol>"},{"location":"en/Guias/Netbox/Render_Templates/#12-local-templates","title":"1.2 Local Templates","text":"<p>To add local templates, follow these steps:</p> <ol> <li>Access NetBox and go to Provisioning &gt; Configuration Templates &gt; Add.</li> <li>Add a name, a description, and in Data, enter the Jinja2 code of the template you want to add. Fill in the other attributes as needed.</li> </ol> <p>Here is an example of a generic Jinja2 template:</p> <pre><code>Device Information:\n------------------------------------------\nDevice Name: {{ device.name }}\nDevice Type: {{ device.device_type.name if device.device_type else 'N/A' }}\nSite: {{ device.site.name if device.site else 'N/A' }}\nStatus: {{ device.status if device.status else 'N/A' }}\nSerial Number: {{ device.serial if device.serial else 'N/A' }}\n{% if device.primary_ip %}\nPrimary IP: {{ device.primary_ip.address if device.primary_ip.address else 'N/A' }}\n{% endif %}\nPlatform: {{ device.platform if device.platform else 'N/A' }}\nRack: {{ device.rack.name if device.rack else 'N/A' }}\nAsset Tag: {{ device.asset_tag if device.asset_tag else 'N/A' }}\n{% if device.comments %}\nComments: {{ device.comments }}\n{% endif %}\n\nInterfaces Information:\n----------------------------------------------\n{% for interface in device.interfaces.all() %}\nInterface Name: {{ interface.name if interface.name else 'N/A' }}\nType: {{ interface.type if interface.type else 'N/A' }}\nMAC Address: {{ interface.mac_address if interface.mac_address else 'N/A' }}\n{% if interface.ip_addresses %}\nIP Addresses: {% for ip in interface.ip_addresses.all() %}\n              {{ ip.address }}\n              {% endfor %}\n{% endif %}\nOperational Status: {{ interface.enabled if interface.enabled else 'N/A' }}\nAdmin Status: {{ interface.enabled if interface.enabled is defined else 'N/A' }}\n{% if interface.untagged_vlan %}\nVLANs: {% for vlan in interface.untagged_vlan.all() %}\n       {{ vlan.vid }}\n       {% endfor %}\n{% endif %}\n----------------------------------------------\n{% endfor %}\n</code></pre> <ol> <li>After entering all the information, click Create.</li> </ol>"},{"location":"en/Guias/Netbox/Render_Templates/#2-associating-templates-to-devices","title":"2. Associating Templates to Devices","text":"<p>To associate a template with a specific device:</p> <ol> <li>Select the device in Devices &gt; Devices.</li> <li>Click Edit or the pencil icon in the right corner.</li> <li>Look for the Management &gt; Configuration Template section.</li> </ol> <p>In this tab, you will see all available configurations.</p> <p>Note</p> <p>Pay attention to the device system, as configuration templates are created differently for different systems.</p> <ol> <li>After selecting the desired template, click Save.</li> <li>To view the template, access the device and click Render Config. This will render the specific configuration for the device dynamically.</li> </ol>"},{"location":"en/Guias/Netbox/Render_Templates/#next-steps","title":"Next Steps","text":"<p>If you want to create other templates and learn more about how the template base works, click here.</p>"},{"location":"en/Guias/Netbox/Render_Templates/Criando%20um%20Template/","title":"Configuration Template Creation","text":""},{"location":"en/Guias/Netbox/Render_Templates/Criando%20um%20Template/#how-does-render-template-work-in-netbox","title":"How Does Render Template Work in NetBox?","text":"<p>\"Render Template\" in NetBox is a powerful feature that allows network administrators to automate the generation of network device configurations based on predefined configuration templates. It simplifies the process of device deployment and maintenance, making it more efficient and less prone to human error. Here's how it works:</p> <ol> <li>Configuration Template Creation: First, administrators create configuration templates using the Jinja2 templating language. These templates serve as structures for the desired device configurations.</li> <li>Incorporating Variables: Configuration templates can incorporate J2 variables, which are placeholders for dynamic information. These variables are replaced with device-specific data when the template is rendered.</li> <li>Association to Devices: Each configuration template is associated with a specific device type. This allows NetBox to know which configuration templates to use for each device based on its type.</li> <li>Automated Rendering: When an administrator creates or updates a device in NetBox, the \"Render Template\" comes into action. NetBox identifies the device type and the corresponding configuration template.</li> <li>Populating with Real Data: The J2 variables in the configuration template are populated with real device data, such as its name, location, IP address, and more.</li> <li>Configuration Generation: NetBox automatically generates a complete configuration for the device, applying the values of the J2 variables to the configuration template. This creates a custom, ready-to-use configuration.</li> <li>Configuration Application: The generated configuration can be deployed to the device via traditional methods, such as SSH/SCP file transfer, or integrated with configuration management tools for further automation.</li> </ol> <p>In summary, \"Render Template\" in NetBox simplifies the process of configuring network devices by allowing the creation of flexible templates and automating the generation of configurations based on device information. This saves time, reduces errors, and facilitates network infrastructure maintenance.</p> <ul> <li>{{ }} - J2 Variables: Expressions within double curly braces, like <code>{{ device.name }}</code>, are J2 variables. They are replaced with the actual values of the devices during template rendering. For example, <code>{{ device.name }}</code> will be replaced by the specific device's name.</li> <li>Control Blocks: Control blocks, such as <code>{% if condition %} ... {% endif %}</code>, allow conditional logic and loops. They are used to check if a condition is true (<code>if</code>) or to iterate over a list of items (<code>for</code>). This is useful for handling cases where information may or may not be available.</li> <li>Python Underneath: J2 templates use the Jinja2 templating language, which is based on Python. Therefore, you can use Python syntax to create custom logic within your templates. This includes using conditionals, loops, and custom functions.</li> </ul> <p>Now that we have explained how it works, here are the available variables for devices registered in NetBox.</p>"},{"location":"en/Guias/Netbox/Render_Templates/Criando%20um%20Template/#variables-and-usage","title":"Variables and Usage","text":"Name Command Description Example Return Device Name {{ http://device.name/ }} Device Name Device Name Device Type {{ device.device_type.name if device.device_type else 'N/A' }} Device Type Device Type (or 'N/A' if no type) Site {{ http://device.site.name/ if device.site else 'N/A' }} Site Name Site Name (or 'N/A' if no site) Status {{ device.status if device.status else 'N/A' }} Device Status Device Status (or 'N/A' if no status) Serial Number {{ device.serial if device.serial else 'N/A' }} Device Serial Number Device Serial Number (or 'N/A' if no serial number) Primary IP {{ device.primary_ip.address if device.primary_ip.address else 'N/A' }} Device Primary IP Address Device Primary IP Address (or 'N/A' if no primary IP) Platform {{ device.platform if device.platform else 'N/A' }} Device Platform Device Platform (or 'N/A' if no platform) Rack {{ http://device.rack.name/ if device.rack else 'N/A' }} Rack Name Rack Name (or 'N/A' if no rack) Asset Tag {{ device.asset_tag if device.asset_tag else 'N/A' }} Device Asset Tag Device Asset Tag (or 'N/A' if no asset tag) Comments {{ device.comments }} Device Comments Device Comments (or blank) Interface Name {{ http://interface.name/ if http://interface.name/ else 'N/A' }} Interface Name Interface Name (or 'N/A' if no name) Type {{ interface.type if interface.type else 'N/A' }} Interface Type Interface Type (or 'N/A' if no type) MAC Address {{ interface.mac_address if interface.mac_address else 'N/A' }} Interface MAC Address Interface MAC Address (or 'N/A' if no MAC address) IP Addresses {{ ip.address }} Interface IP Addresses (multiple may be present) List of Interface IP Addresses Operational Status {{ interface.enabled if interface.enabled else 'N/A' }} Interface Operational Status Interface Operational Status (or 'N/A' if no operational status) Admin Status {{ interface.enabled if interface.enabled is defined else 'N/A' }} Interface Administrative Status Interface Administrative Status (or 'N/A' if no administrative status) VLANs {% for vlan in interface.untagged_vlan.all() %}{{ vlan.vid }} Interface VLANs List of Interface VLANs (if any)"},{"location":"en/Guias/Netbox/Render_Templates/Criando%20um%20Template/#example","title":"Example","text":"<p>This rendering template is designed to generate interface configurations in the appropriate format for a Juniper router. It iterates through all the device's interfaces in NetBox that have associated IP addresses and generates configurations for those interfaces.</p> <p>Here's how the template works:</p> <pre><code>{%- for interface in device.interfaces.all() -%}\n    {%- if interface.ip_addresses.all() %}\n    {{ interface.name.split('.')[0].split(':')[0] }} {\n        unit 0 {\n            family inet {\n                {%- for ip in interface.ip_addresses.all() %}\n                address {{ ip }};\n                {%- endfor %}\n            }\n        }\n    }\n    {%- endif %}\n{%- endfor %}\n</code></pre> <p>The output generated after rendering this template will be similar to the following:</p> <pre><code>ge-0/0/0 {\n    unit 0 {\n        family inet {\n            address 192.168.1.1/24;\n            address 10.0.0.1/30;\n        }\n    }\n}\nge-0/0/1 {\n    unit 0 {\n        family inet {\n            address 172.16.0.1/24;\n        }\n    }\n}\n</code></pre> <p>In this example:</p> <ul> <li>The loop <code>{%- for interface in device.interfaces.all() -%}</code> iterates through all the device's interfaces in NetBox.</li> <li>The condition <code>{%- if interface.ip_addresses.all() %}</code> checks if the interface has IP addresses associated with it.</li> <li><code>{{ interface.name.split('.')[0].split(':')[0] }}</code> is used to extract the interface name in the desired format. For example, if the interface name is \"ge-0/0/0.0:1\", it will be converted to \"ge-0/0/0\".</li> <li>The template then generates the configurations for each interface, including the IP address (obtained from the loop <code>{%- for ip in interface.ip_addresses.all() %}</code>).</li> </ul> <p>The resulting output is a series of interface configurations formatted correctly for a Juniper device. Each interface has its own configuration, including its name and IP address, if applicable.</p>"},{"location":"en/Guias/Netreplica/","title":"NetReplica - Configuration and Execution Guide in Container","text":"<p>This guide describes the necessary steps to configure and run NetReplica in a Docker container, using Docker Compose. NetReplica is a tool dedicated to automating network labs through software.</p>"},{"location":"en/Guias/Netreplica/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker installed on your machine: Installation Instructions</li> <li>Docker Compose installed on your machine: Installation Instructions</li> </ul>"},{"location":"en/Guias/Netreplica/#step-1-environment-preparation","title":"Step 1: Environment Preparation","text":"<ol> <li>Open a terminal and clone the NetReplica repository using the following command:</li> </ol> <pre><code>git clone https://git.rnp.br/redes-abertas/netreplica-docker.git\n</code></pre> <ol> <li>Navigate to the cloned NetReplica directory:</li> </ol> <pre><code>cd netreplica-docker\n</code></pre>"},{"location":"en/Guias/Netreplica/#step-2-container-initialization","title":"Step 2: Container Initialization","text":"<ol> <li>To build the Docker image and start the NetReplica container, run:</li> </ol> <pre><code>docker compose up -d\n</code></pre> <p>This command will create and start the container in the background.</p>"},{"location":"en/Guias/Netreplica/#step-3-using-netreplica","title":"Step 3: Using NetReplica","text":"<p>After the container initialization, you can interact with NetReplica using the commands below.</p>"},{"location":"en/Guias/Netreplica/#executing-netreplica","title":"Executing NetReplica","text":"<ol> <li> <p>Place any necessary configuration files (<code>.conf</code> files) in the <code>conf</code> folder that is within the <code>nrx</code> directory where the repository was cloned.</p> </li> <li> <p>To run NetReplica with the <code>.conf</code> file, use the following command:</p> </li> </ol> <pre><code>docker exec -it nrx nrx -c conf/&lt;arquivo.conf&gt;\n</code></pre> <ul> <li>Replace <code>&lt;arquivo.conf&gt;</code> with the name of the configuration file you want to use.</li> <li>The output directory for the execution results is already specified within the <code>.conf</code> file, so it is not necessary to specify it in the command.</li> </ul>"},{"location":"en/Guias/Netreplica/#alias-for-agility","title":"Alias for Agility","text":"<p>To further optimize the use of NetReplica, you can create an alias in your shell to simplify the execution command:</p> <ol> <li>Open a terminal and edit the shell profile file corresponding to your system (for example, <code>~/.bashrc</code> for Bash or <code>~/.zshrc</code> for Zsh).</li> <li>Add the following line to the end of the file:</li> </ol> <pre><code>alias nrx='docker exec -it nrx nrx'\n</code></pre> <ol> <li>Save the file and close it.</li> <li>To activate the new alias without restarting the terminal, run the command:</li> </ol> <pre><code>source ~/.bashrc   # or source ~/.zshrc, depending on your shell\n</code></pre> <p>Now, you can use the simplified command <code>nrx</code> to run NetReplica more quickly. For example:</p> <pre><code>nrx -c conf/&lt;arquivo.conf&gt;\n</code></pre> <p>Now to test if NetReplica is working, execute the following command:</p> <pre><code>nrx -c conf/teste.conf\n</code></pre> <p>this command will perform a query on the demonstration netbox generating a result equal to the one shown below:</p> <pre><code>--&gt; nrx -c conf/teste.conf\nReading platform map from: templates/platform_map.yaml\nConnecting to NetBox at: https://demo.netbox.dev\nFetching devices from sites: ['DM-Akron']\nCreated clab topology: conf/lab/lab.clab.yaml\nTo deploy this topology, run: sudo -E clab dep -t conf/lab/lab.clab.yaml\n</code></pre>"},{"location":"en/Guias/Netreplica/#monitoring-the-execution","title":"Monitoring the Execution","text":"<ul> <li>During execution, NetReplica will use the settings in the <code>.conf</code> file to access NetBox, start network replication and analysis. Monitor the terminal output to track progress and view any relevant messages.</li> <li>After completion of the execution, the replication and analysis results will be available in the output directory specified within the <code>.conf</code> file.</li> </ul>"},{"location":"en/Guias/Netreplica/#stopping-the-container","title":"Stopping the Container","text":"<p>To stop the NetReplica container and release resources, run:</p> <pre><code>docker compose down\n</code></pre>"},{"location":"en/Guias/Netreplica/#next-steps-conf-file-configuration","title":"Next Steps: <code>.conf</code> File Configuration","text":"<p>Now that you know how to configure and run NetReplica, the next step is to understand how to correctly configure the <code>.conf</code> file to meet the needs of your network environment.</p> <p>next steps <code>.conf</code> File Configuration</p>"},{"location":"en/Guias/Netreplica/NetReplica%20Criando%20Templates/#clab-template-structure","title":"CLAB Template Structure","text":"<p>CLAB templates follow a specific structure, which allows NetReplica to interpret and apply the configurations correctly. Here is an example of a CLAB template for a ceos device:</p> <pre><code>  {{ name }}:\n    kind: ceos\n    image: ceos:latest\n    {% if configuration_file is defined %}\n    startup-config: {{ configuration_file }}\n    {% endif %}\n    {% if interface_map is defined %}\n    binds:\n        - {{ interface_map }}:/mnt/flash/EosIntfMapping.json:ro\n    {% endif %}\n    {% include 'clab/labels.j2' %}\n</code></pre> <p>In this example:</p> <ul> <li><code>{{ name }}</code> is a variable that will be replaced by the device name.</li> <li><code>kind</code> defines the type of device, in this case, \"ceos\".</li> <li><code>image</code> specifies the device image.</li> <li><code>startup-config</code> allows you to define an initial configuration file.</li> <li><code>binds</code> allows you to map volumes, such as interface mapping.</li> <li><code>include</code> is used to include additional labels from the CLAB template.</li> </ul>"},{"location":"en/Guias/Netreplica/NetReplica%20Criando%20Templates/#creating-clab-templates","title":"Creating CLAB Templates","text":"<p>To create your own CLAB templates, follow the example structure and format provided. You can create <code>.j2</code> files, remembering that the filename should be the platform name for each device type, and customize the configurations as needed. Save your templates in the <code>templates/clab/kinds/</code> directory of your NetReplica environment.</p> <p>By creating and using CLAB templates, you have the flexibility to define how devices will be provisioned and configured within the CLAB environment, allowing for precise replication of your network.</p> <p>Example of the junos template junos.j2</p> <pre><code>{{ name }}:\n            kind: crpd\n            image: crpd:23.1R1.8\n            {% if configuration_file is defined %}\n            startup-config: {{ configuration_file }}\n            {% endif %}\n            {% if interface_map is defined %}\n            binds:\n                - {{ interface_map }}:/mnt/flash/EosIntfMapping.json:ro\n            {% endif %}\n            {% include 'clab/labels.j2' %}\n</code></pre>"},{"location":"en/Guias/Netreplica/NetReplica%20Criando%20Templates/#step-2-running-netreplica-with-the-configuration-file","title":"Step 2: Running NetReplica with the Configuration File","text":"<p>Once you have created and configured the <code>.conf</code> file with the desired options, you are ready to run NetReplica and start replicating and analyzing networks based on the NetBox information. Follow the steps below to run NetReplica:</p> <ol> <li>Configuration File Location: Make sure the <code>.conf</code> file is in the correct location. If you are using NetReplica via Docker, remember that the <code>.conf</code> file must be inside the \"conf\" directory that is created after running the compose.</li> <li>Starting NetReplica: Open a terminal or command prompt and navigate to the directory where NetReplica is installed. If you are using NetReplica via Docker, make sure you are in the directory where the <code>docker-compose.yml</code> file is located.</li> <li> <p>Running NetReplica: Execute the command to start NetReplica, passing the path to the <code>.conf</code> file as an argument. For example, if the <code>.conf</code> file is in the current directory and is named <code>netreplica.conf</code>, the command might be:</p> <pre><code>nrx -c &lt;file&gt;.conf\n</code></pre> </li> </ol> <p>If you are using NetReplica via Docker, the command to run might be:</p> <pre><code>```bash\ndocker exec -it nrx ./nrx -c conf/&lt;file&gt;.conf\n```\n</code></pre> <ol> <li>Monitoring Execution: During execution, NetReplica will use the settings from the <code>.conf</code> file to access NetBox and start the network replication and analysis. Monitor the terminal output to see the progress and any relevant messages.</li> <li>Execution Results: After the execution is complete, the replication and analysis results will be available in the output directory specified in the <code>.conf</code> file (usually the <code>OUTPUT_DIR</code> directory). You will be able to find the exported files, such as images, device configurations, and other data, according to the defined settings.</li> </ol> <p>Remember that NetReplica is a powerful tool for replicating and analyzing networks based on NetBox information. By running NetReplica with the correctly configured configuration file, you will be exploring the integration capabilities between these two tools to gain valuable insights into your network.</p>"},{"location":"en/Guias/Netreplica/NetReplica%20Criando%20Templates/#sources","title":"Sources","text":"<ol> <li>NetReplica (NRX) GitHub Repository. Available at: https://github.com/netreplica/nrx</li> <li>NetReplica Templates GitHub Repository. Available at: https://github.com/netreplica/templates</li> <li>ContainerLab Manual - Kinds. Available at: https://containerlab.dev/manual/kinds/</li> </ol>"},{"location":"en/Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/","title":"NetReplica Guide: Configuration and Execution with NetBox","text":"<p>This guide describes the necessary configurations to integrate NetReplica with NetBox. NetReplica is a tool used to replicate and analyze networks, while NetBox is a network asset management platform.</p>"},{"location":"en/Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#step-1-direct-execution-with-nrx","title":"Step 1: Direct Execution with NRX","text":"<p>Note</p> <p>Before proceeding, ensure that NetReplica and NetBox are installed. You can find more information here: Netreplica Installation</p> <p><code>nrx</code> is the NetReplica command-line interface that allows you to configure and execute tasks directly without the need to create a configuration file. Below are the main commands you can use:</p>"},{"location":"en/Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#basic-commands","title":"Basic Commands","text":"<p>1 Command to Export a Topology:</p> <pre><code>nrx -c conf/&lt;Topology_Name&gt;.conf\n</code></pre> <p>This command uses the <code>.conf</code> configuration file to export the specified topology.</p> <p>2 Export from a NetBox API URL:</p> <pre><code>nrx -a http://&lt;netbox_ip&gt;:&lt;port&gt; -t '&lt;tags&gt;' -s '&lt;site&gt;' -o clab\n</code></pre> <p>This command allows exporting using parameters directly on the command line, such as the NetBox API URL, tags, site, and output format.</p> <p>3 Using Authentication Tokens:</p> <p>To pass the authentication token without using a configuration file:</p> <pre><code>export NB_API_TOKEN='your_token_here'\nnrx -a http://&lt;netbox_ip&gt;:&lt;port&gt; -t '&lt;tags&gt;' -s '&lt;site&gt;' -o clab\n</code></pre> <p>4 Specify the Output Directory:</p> <pre><code>nrx -c conf/&lt;Topology_Name&gt;.conf -D /path/to/output\n</code></pre> <p>This command allows you to define a specific directory for the output of the exported files.</p> <p>5 Ignore TLS Certificate:</p> <pre><code>nrx -c conf/&lt;Topology_Name&gt;.conf --insecure\n</code></pre> <p>This command disables TLS certificate verification.</p>"},{"location":"en/Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#common-nrx-arguments","title":"Common <code>nrx</code> Arguments","text":"<ul> <li><code>-c, --config CONFIG</code>: Defines the configuration file to be used.</li> <li><code>-a, --api API</code>: Defines the NetBox API URL.</li> <li><code>-s, --site SITE</code>: Specifies the NetBox site to be exported.</li> <li><code>-t, --tags TAGS</code>: Defines the NetBox tags to be exported.</li> <li><code>-o, --output OUTPUT</code>: Defines the output format (e.g., 'clab', 'cyjs').</li> <li><code>-D, --dir DIR</code>: Defines the output directory.</li> <li><code>--insecure</code>: Disables TLS certificate verification.</li> </ul>"},{"location":"en/Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#step-2-conf-file-configuration","title":"Step 2: <code>.conf</code> File Configuration","text":"<p>The <code>.conf</code> configuration file provides a structured way to define the variables required for topology export. It is particularly useful when you want to reuse the same settings or when there are many options to define.</p> <p>Of course, here is the configuration file with a detailed explanation for each field:</p>"},{"location":"en/Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#summarized-configuration-file","title":"Summarized Configuration File","text":"<pre><code>NB_API_URL           = 'http://localhost:8000'    # NetBox API URL or NB_API_URL env var\nNB_API_TOKEN         = ''                         # API Token or NB_API_TOKEN env var\nTLS_VALIDATE         = false                      # TLS certificate validation\nAPI_TIMEOUT          = 10                         # API timeout (s)\n\nTOPOLOGY_NAME        = 'lab'         # Topology name\nOUTPUT_FORMAT        = 'clab'        # Output format: gml | cyjs | clab\nOUTPUT_DIR           = 'conf/lab'    # Output directory (default: ./&lt;topology&gt;)\nTEMPLATES_PATH       = ['templates']\nPLATFORM_MAP         = 'templates/platform_map.yaml'   # Platform mapping file\nEXPORT_CONFIGS       = true           # Export configs if available\n\nEXPORT_DEVICE_ROLES  = []             # Device roles to export\nEXPORT_SITES         = ['DM-Akron']   # Sites to export\nEXPORT_TAGS          = []             # Tags to export\n</code></pre>"},{"location":"en/Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#netbox-api-configurations","title":"NetBox API Configurations","text":""},{"location":"en/Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#1-nb_api_url","title":"1. NB_API_URL","text":"<ul> <li>Description: NetBox API URL.</li> <li>Usage: Defines the address of the NetBox instance to be queried by NetReplica.</li> <li>Example: <code>'http://localhost:8000'</code>.</li> </ul>"},{"location":"en/Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#2-nb_api_token","title":"2. NB_API_TOKEN","text":"<ul> <li>Description: NetBox API authentication token.</li> <li>Usage: Required to authenticate requests to the API.</li> <li>Example: <code>''</code> (should be filled with the actual token).</li> </ul>"},{"location":"en/Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#3-tls_validate","title":"3. TLS_VALIDATE","text":"<ul> <li>Description: Controls TLS certificate validation.</li> <li>Usage: <code>true</code> enables validation (recommended in production); <code>false</code> disables (useful in testing).</li> <li>Example: <code>false</code>.</li> </ul>"},{"location":"en/Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#4-api_timeout","title":"4. API_TIMEOUT","text":"<ul> <li>Description: Timeout for API requests, in seconds.</li> <li>Usage: Defines how long NetReplica waits for a response before considering the request failed.</li> <li>Example: <code>10</code>.</li> </ul>"},{"location":"en/Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#export-configurations","title":"Export Configurations","text":""},{"location":"en/Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#5-topology_name","title":"5. TOPOLOGY_NAME","text":"<ul> <li>Description: Name of the exported topology.</li> <li>Usage: Identifies the exported files and groups the topology.</li> <li>Example: <code>'lab'</code>.</li> </ul>"},{"location":"en/Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#6-output_format","title":"6. OUTPUT_FORMAT","text":"<ul> <li>Description: Format of the exported data.</li> <li>Usage: Can be <code>'gml'</code>, <code>'cyjs'</code>, or <code>'clab'</code>.</li> <li>Example: <code>'clab'</code>.</li> </ul>"},{"location":"en/Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#7-output_dir","title":"7. OUTPUT_DIR","text":"<ul> <li>Description: Destination directory for exported files.</li> <li>Usage: Overrides the default export directory.</li> <li>Example: <code>'conf/lab'</code>.</li> </ul>"},{"location":"en/Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#8-templates_path","title":"8. TEMPLATES_PATH","text":"<ul> <li>Description: List of template directories used in the export.</li> <li>Usage: Allows locating custom templates.</li> <li>Example: <code>['templates']</code>.</li> </ul>"},{"location":"en/Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#9-platform_map","title":"9. PLATFORM_MAP","text":"<ul> <li>Description: Platform mapping file.</li> <li>Usage: Defines how each device platform will be represented in the exported files.</li> <li>Example: <code>'templates/platform_map.yaml'</code>.</li> </ul>"},{"location":"en/Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#10-export_configs","title":"10. EXPORT_CONFIGS","text":"<ul> <li>Description: Defines whether device configurations should be exported.</li> <li>Usage: <code>true</code> includes the configs, <code>false</code> ignores them.</li> <li>Example: <code>true</code>.</li> </ul>"},{"location":"en/Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#device-filter-configurations","title":"Device Filter Configurations","text":""},{"location":"en/Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#11-export_device_roles","title":"11. EXPORT_DEVICE_ROLES","text":"<ul> <li>Description: List of device roles to be exported.</li> <li>Usage: Filters which devices will be included.</li> <li>Example: <code>[]</code> (exports all if empty).</li> </ul>"},{"location":"en/Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#12-export_sites","title":"12. EXPORT_SITES","text":"<ul> <li>Description: List of NetBox sites to be exported.</li> <li>Usage: Filters devices by site.</li> <li>Example: <code>['DM-Akron']</code>.</li> </ul>"},{"location":"en/Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#13-export_tags","title":"13. EXPORT_TAGS","text":"<ul> <li>Description: List of tags used as a filter for export.</li> <li>Usage: Only devices with these tags will be exported.</li> <li>Example: <code>[]</code> (exports all if empty).</li> </ul> <p>This configuration file allows for detailed customization of how NetReplica interacts with NetBox and exports data, helping to meet specific visualization and export needs.</p>"},{"location":"en/Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#next-steps","title":"Next Steps","text":"<p>Now to delve deeper, you can check out the next guide that shows how to create and configure new Templates and add new images to netreplica. check it out here NetReplica Creating Templates.</p>"},{"location":"en/Guias/Netreplica/NetReplica%20Guia%20Configura%C3%A7%C3%A3o%20e%20Execu%C3%A7%C3%A3o%20com%20NetBox/#references","title":"References","text":"<ul> <li>NetReplica GitHub Repository</li> </ul>"},{"location":"en/Laborat%C3%B3rios/","title":"Containerlab","text":"<p>Containerlab is a powerful tool for creating and managing virtualized network labs. With it, you can simulate complex network topologies using Docker containers. Below, you will find information about the prerequisites, recommended tools, and how to document your labs.</p>"},{"location":"en/Laborat%C3%B3rios/#prerequisites","title":"Prerequisites","text":"<p>Before you start using Containerlab, make sure you have the following prerequisites installed:</p>"},{"location":"en/Laborat%C3%B3rios/#docker","title":"Docker","text":"<ul> <li>Docker is used by Containerlab to create and run the containers that make up the virtualized network.</li> <li>Link: Official Docker Documentation.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/#containerlab_1","title":"Containerlab","text":"<ul> <li>Install Containerlab according to the instructions provided in the official documentation.</li> <li>Link: Official Containerlab Documentation.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/#available-labs","title":"Available Labs","text":"<p>Here is an example of a configured lab to simulate OSPF using Junos:</p>"},{"location":"en/Laborat%C3%B3rios/#ospf-routing-junos","title":"OSPF Routing (Junos)","text":"<ul> <li>OSPF simulation with Junos, one of the most used routing technologies.</li> <li>Link: OSPF Routing (Junos) Lab.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/#discovery-junos","title":"Discovery (Junos)","text":"<ul> <li>Router import with scripts, using Zabbix and Netbox.</li> <li>Link: Discovery (Junos) Lab.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/#elk-monitoring-junos","title":"ELK Monitoring (Junos)","text":"<ul> <li>Export IPFIX flows to Elasticsearch with Elastic Agent.</li> <li>Real-time flow visualization with dashboards in Kibana.</li> <li>Link: ELK Monitoring (Junos).</li> </ul>"},{"location":"en/Laborat%C3%B3rios/#telegraf-monitoring-junos","title":"Telegraf Monitoring (Junos)","text":"<ul> <li>Export traffic flows via Telegraf/IPFIX to InfluxDB.</li> <li>Ready-made dashboards in Grafana for traffic analysis by interface and protocol.</li> <li>Link: Telegraf Monitoring (Junos).</li> </ul>"},{"location":"en/Laborat%C3%B3rios/#zabbix-monitoring-junos","title":"Zabbix Monitoring (Junos)","text":"<ul> <li>Monitoring routers via SNMP with centralized collection by the Zabbix Server.</li> <li>Allows real-time visualization of metrics and alerts in the Zabbix frontend.</li> <li>Link: Zabbix Monitoring (Junos).</li> </ul>"},{"location":"en/Laborat%C3%B3rios/#recommended-analysis-tools","title":"Recommended Analysis Tools","text":"<p>In addition to Containerlab, you can use the following analysis tools to monitor and debug your virtualized network:</p>"},{"location":"en/Laborat%C3%B3rios/#librenms","title":"LibreNMS","text":"<ul> <li>A web-based network monitoring platform that provides insights into network performance and health. Ideal for continuous real-time network monitoring.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/#wireshark","title":"Wireshark","text":"<ul> <li>Packet capture and analysis tool that allows you to examine network traffic in detail. Essential for debugging and analyzing network protocols.</li> </ul> <p>In addition to these tools mentioned there are others that can be configured according to your needs, to learn more go to: Analysis Tools.</p>"},{"location":"en/Laborat%C3%B3rios/#documenting-your-labs","title":"Documenting Your Labs","text":"<p>To ensure your labs are well documented and easy to understand, see the section on Lab Documentation. There, you will find best practices and examples for creating clear and useful documentation for your simulated environments.</p> <ul> <li>Link: Lab Documentation.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Contribua/","title":"Documenting Labs","text":"<p>Contributing to the documentation of labs in Containerlab is a straightforward process, but it's important to follow a few steps to ensure all links and functionalities work correctly. This page provides the necessary instructions for documenting a lab, as well as setting up the essential scripts for the proper functioning of the deployment process.</p>"},{"location":"en/Laborat%C3%B3rios/Contribua/#1-creating-lab-documentation","title":"1. Creating Lab Documentation","text":""},{"location":"en/Laborat%C3%B3rios/Contribua/#creating-images-to-represent-labs","title":"Creating Images to Represent Labs","text":"<p>In the documentation, it's important for labs to have images representing the lab's network topology. To do this, follow the Guide to Creating Images to Represent Labs.</p>"},{"location":"en/Laborat%C3%B3rios/Contribua/#steps-to-document-a-lab","title":"Steps to Document a Lab","text":"<p>Here are the main steps for documenting your lab:</p> <ol> <li>Create Lab Description and Objective:<ul> <li>Describe what the lab does and which protocol or functionality is being demonstrated.</li> </ul> </li> <li>Document the Lab Topology:<ul> <li>Use the created images to illustrate the lab's network topology. If necessary, insert additional diagrams explaining how the devices are interconnected.</li> </ul> </li> <li>Include Usage Examples:<ul> <li>Provide examples of commands and actions that users can execute within the lab to test the functionality.</li> </ul> </li> <li>List Requirements:<ul> <li>Clearly define hardware and software requirements, such as the Docker version, Containerlab version, and network configurations.</li> </ul> </li> <li>Deployment Instructions:<ul> <li>Document the lab's deployment, whether it's the ready-made or customized version. Be sure to follow the deployment guides with appropriate links.</li> </ul> </li> <li>Access and Credentials:<ul> <li>Create a table detailing the IPs of each device in the lab and their respective access credentials.</li> </ul> </li> </ol> <p>Tip</p> <p>To follow a consistent documentation pattern, you can use the template that is already structured with tips. It will serve as a basis for you to adapt the content of your lab, ensuring that all sections are correctly addressed.</p> <p>To use the documentation template, simply go to docs/pt/Laborat\u00f3rios/Contribua/Template lab.md, create a copy in the laboratorios folder, name it after your lab, and fill in the information.</p>"},{"location":"en/Laborat%C3%B3rios/Contribua/#2-scripts-for-quick-download","title":"2. Scripts for Quick Download","text":"<p>To ensure that the lab's download and deployment process works correctly, it's necessary to include two essential scripts within the lab's folder in GitLab. These scripts will allow the lab to be downloaded and configured automatically with a simple command.</p>"},{"location":"en/Laborat%C3%B3rios/Contribua/#21-getsh-script","title":"2.1 <code>get.sh</code> Script","text":"<p>The <code>get.sh</code> script is used on Linux/Mac systems to automatically download and unpack the lab. It checks if the <code>tar</code> command is installed and, if not, installs the necessary package before downloading the file.</p>"},{"location":"en/Laborat%C3%B3rios/Contribua/#how-it-works","title":"How it Works:","text":"<ol> <li>Dependency Verification: The script checks if the <code>tar</code> package is installed. If not, it tries to install it using the system's package manager (<code>apt-get</code>, <code>dnf</code>, <code>yum</code>, or <code>pacman</code>).</li> <li>Download and Unpacking: The script downloads the <code>.tar</code> file containing the lab and unpacks it in the destination directory.</li> </ol>"},{"location":"en/Laborat%C3%B3rios/Contribua/#getsh-script","title":"<code>get.sh</code> Script:","text":"<pre><code>#!/bin/bash\n\n# Function to check if a command is installed\ncheck_command() {\n    command -v \"$1\" &gt;/dev/null 2&gt;&amp;1\n}\n\n# Function to install packages\ninstall_package() {\n    if [ -x \"$(command -v apt-get)\" ]; then\n        sudo apt-get update\n        sudo apt-get install -y \"$1\"\n    elif [ -x \"$(command -v dnf)\" ]; then\n        sudo dnf install -y \"$1\"\n    elif [ -x \"$(command -v yum)\" ]; then\n        sudo yum install -y \"$1\"\n    elif [ -x \"$(command -v pacman)\" ]; then\n        sudo pacman -Sy --noconfirm \"$1\"\n    else\n        echo \"Error: Unsupported package manager. Install '$1' manually.\"\n        exit 1\n    fi\n}\n\nif ! check_command tar; then\n    echo \"The 'tar' package is not installed. Installing...\"\n    install_package tar\nfi\n\n# URL of the tar file\nURL=\"&lt;https://git.rnp.br/redes-abertas/lab/-/archive/main/labs-main.tar?path=&lt;lab-name&gt;&gt;\"\n\n# Name of the file to save\nFILENAME=\"lab-main.tar\"\n\n# Directory where to unpack the files\nDEST_DIR=\"./\"\n\n# Download the file\necho \"Downloading $FILENAME...\"\ncurl -L -o $FILENAME \"$URL\"\n\n# Verify if the download was successful\nif [ $? -ne 0 ]; then\n    echo \"Error downloading the file.\"\n    exit 1\nfi\n\n# Unpack the file\necho \"Unpacking $FILENAME...\"\ntar -xf $FILENAME -C $DEST_DIR --strip-components=1\n\n# Verify if the unpacking was successful\nif [ $? -ne 0 ]; then\n    echo \"Error unpacking the file.\"\n    exit 1\nfi\n\n# Remove the tar file after unpacking\nrm $FILENAME\n\necho \"Download and unpacking completed successfully.\"\n</code></pre>"},{"location":"en/Laborat%C3%B3rios/Contribua/#variables-to-modify","title":"Variables to Modify:","text":"<ul> <li><code>URL</code>: Change the URL to correspond to the repository and the path to the lab within GitLab.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Contribua/#22-getbat-script","title":"2.2 <code>get.bat</code> Script","text":"<p>The <code>get.bat</code> script is used on Windows systems to download and unpack the lab in a similar way to <code>get.sh</code>, but with commands compatible with the Windows environment.</p>"},{"location":"en/Laborat%C3%B3rios/Contribua/#getbat-script","title":"<code>get.bat</code> Script:","text":"<pre><code>@echo off\nsetlocal\n\nREM URL of the tar file\nset \"URL=https://git.rnp.br/redes-abertas/docker-composes/-/archive/main/docker-composes-main.tar?path=&lt;lab-name&gt;\"\n\nREM Name of the file to save\nset \"FILENAME=lab-main.tar\"\n\nREM Directory where to unpack the files\nset \"DEST_DIR=.\"\n\necho Downloading %FILENAME%...\ncurl -L -o %FILENAME% %URL%\n\nREM Verify if the download was successful\nif not exist %FILENAME% (\n    echo Error downloading the file.\n    exit /b 1\n)\n\necho Unpacking %FILENAME%...\ntar -xf %FILENAME% -C %DEST_DIR% --strip-components=1\n\nREM Verify if the unpacking was successful\nif %errorlevel% neq 0 (\n    echo Error unpacking the file.\n    exit /b 1\n)\n\nREM Remove the tar file after unpacking\ndel %FILENAME%\n\necho Download and unpacking completed successfully.\n\nendlocal\npause\n</code></pre>"},{"location":"en/Laborat%C3%B3rios/Contribua/#variables-to-modify_1","title":"Variables to Modify:","text":"<ul> <li><code>URL</code>: Change the URL to the specific path of your lab in the GitLab repository.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Contribua/#3-ensuring-the-scripts-are-correct","title":"3. Ensuring the Scripts are Correct","text":"<p>To ensure that the quick download process works correctly, both scripts (get.sh and get.bat) must be included in the lab's folder within the lab repository. This ensures that, when using the download links, users can download and unpack the lab efficiently, without any problems.</p> <p>Tip</p> <p>When including the scripts in GitLab, verify that the URLs are configured correctly with the names corresponding to the repository folder and the lab's name.</p> <p>With these steps, you can effectively contribute to the lab documentation and ensure that all download links and scripts are working correctly without altering the documentation structure, adding anything new, or changing any links or references.</p>"},{"location":"en/Laborat%C3%B3rios/Contribua/Guia%20Criando%20Imagens%20para%20Representar%20Laborat%C3%B3rios/","title":"Guide: Creating Images to Represent Labs","text":"<p>This guide teaches how to create images representing network topologies for labs, using the Draw.io template provided in the repository. The images must follow the project's visual identity and be saved in SVG format within the correct folder.</p>"},{"location":"en/Laborat%C3%B3rios/Contribua/Guia%20Criando%20Imagens%20para%20Representar%20Laborat%C3%B3rios/#1-opening-the-template","title":"1. Opening the Template","text":"<p>In the root of the repository <code>docs/Templates</code>, you will find a Draw.io template, which you can see below. Open the file, and you will see that it already contains all the components needed to create network topologies, including:</p> <p></p> <ul> <li>Application Cards: Represent assets or protocols such as Grafana and OpenConfig.</li> <li>Network Components: Icons of routers, switches, and servers.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Contribua/Guia%20Criando%20Imagens%20para%20Representar%20Laborat%C3%B3rios/#2-assembling-the-topology","title":"2. Assembling the Topology","text":"<ol> <li>Add Network Components: Copy and paste the icons of routers, switches, and servers from the component area of the template.</li> <li>Add Application Cards: Position the cards that represent the assets/protocols in the topology.</li> <li>Connect the Components: Use lines (for interconnections) and arrows (to point to the IPs) to connect the components and create the network structure.</li> </ol>"},{"location":"en/Laborat%C3%B3rios/Contribua/Guia%20Criando%20Imagens%20para%20Representar%20Laborat%C3%B3rios/#style-specifications-for-the-topology","title":"Style Specifications for the Topology","text":"Element Specification Title Font Font: Times New Roman, Size: 28px Subtitle Font Font: Times New Roman, Size: 25px Connection Lines Thickness: 11px, Type: Straight lines (for interconnections) Arrows for IPs Thickness: 11px, Type: Arrows (to point to the IPs) Interface Boxes Font Size: 11px <p>With these specifications, you ensure that the topologies follow the project's visual standard and are consistent with the rest of the documentation.</p>"},{"location":"en/Laborat%C3%B3rios/Contribua/Guia%20Criando%20Imagens%20para%20Representar%20Laborat%C3%B3rios/#3-adding-interfaces-and-ips","title":"3. Adding Interfaces and IPs","text":"<ol> <li>Create the Text Box for Interfaces: For each connection, draw a square representing the interface.</li> <li>Add IP Property:<ul> <li>Select the square.</li> <li>Right-click and choose Add/Edit Data.</li> <li>Click on Add Property, name it ip, and add the IP address of the interface.</li> </ul> </li> </ol> <p>When the mouse hovers over the square, the IP will be displayed as a tooltip.</p>"},{"location":"en/Laborat%C3%B3rios/Contribua/Guia%20Criando%20Imagens%20para%20Representar%20Laborat%C3%B3rios/#4-saving-the-image","title":"4. Saving the Image","text":"<p>After finalizing the topology, save the image in SVG format:</p> <ol> <li>Save as SVG: In Draw.io, go to File &gt; Export As &gt; svg.</li> <li>Destination Folder: Save the image in the <code>docs/img/labs_imgs/</code> folder.</li> </ol> <p>Attention</p> <p>Make sure to select Light as the Appearance: option when exporting.</p>"},{"location":"en/Laborat%C3%B3rios/Contribua/Guia%20Criando%20Imagens%20para%20Representar%20Laborat%C3%B3rios/#5-updating-the-documentation","title":"5. Updating the Documentation","text":"<p>After saving the image, update the documentation's Markdown file, including the topology image:</p> <p>```markdown </p>"},{"location":"en/Laborat%C3%B3rios/Contribua/Template%20lab/","title":"Template Lab (Lab Name)","text":"<p>This template serves as an example for creating lab implementation guides in Containerlab. It is structured to serve as a model for all project labs, with information that should be followed consistently in each documentation. Each lab may have its specificities, but the general structure and the following sections remain the same for all labs.</p>"},{"location":"en/Laborat%C3%B3rios/Contribua/Template%20lab/#1-description","title":"1. Description","text":""},{"location":"en/Laborat%C3%B3rios/Contribua/Template%20lab/#lab-objective","title":"Lab Objective","text":"<p>Clearly describe the objective of the lab, explaining what will be demonstrated or tested. Be brief, but include the main functionalities that the user will explore.</p> <p>This part should contain an image showing the lab topology. Lab Topology</p> <p>Example: The \"ospf-lab\" demonstrates the configuration and testing of OSPF (Open Shortest Path First) routing in a network composed of multiple routers. The main focus is to verify the establishment of OSPF adjacency and routing between the network devices.</p> <p>Tip</p> <p>Keep the description clear and concise, highlighting what is essential for the user to quickly understand what the lab will provide.</p> <p>Lab Topology Here, include the diagram or a detailed textual description of the topology, mentioning the devices and how they are interconnected.</p> <p>Of course! Below is a general template for the \"Application Example\" section, with a descriptive guide for the user to understand what to include in this part of the guide, followed by a practical example that can be adapted in any similar laboratory:</p>"},{"location":"en/Laborat%C3%B3rios/Contribua/Template%20lab/#application-example","title":"Application Example","text":"<p>Description: Use this section to present practical and objective scenarios in which the laboratory can be applied. The focus should be on possible uses, such as training, performance testing, configuration validation, or protocol study. Avoid technical details of the implementation and focus on what the laboratory can be used for in real or academic environments.</p> <p>Application Example:</p> <p>This lab is ideal for real network simulation scenarios, especially in the context of dynamic routing and monitoring. It can be applied in:</p> <ul> <li>Technical training: Training professionals in routing protocols (such as OSPF) and monitoring with SNMP, using tools such as Zabbix.</li> <li>Monitored environment testing: Evaluating how routers behave under continuous monitoring and automatic device discovery.</li> <li>Teaching in network courses: Supporting environment for practical computer network classes, focusing on point-to-point topologies and integration with network management systems.</li> <li>Tool integration validation: Used to validate communication between routers and monitoring platforms in virtualized environments.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Contribua/Template%20lab/#3-requirements","title":"3. Requirements","text":"<p>This topic should list the minimum hardware and software requirements needed to run the lab. Be sure to include essential tools such as Containerlab and Docker, as well as the <code>br-lab</code> network.</p>"},{"location":"en/Laborat%C3%B3rios/Contribua/Template%20lab/#example-requirements-table","title":"Example Requirements Table:","text":"Requirement Details CPUs [x] CPUs (specify) RAM Memory [x] GB Disk Space [x] GB Containerlab [Containerlab Version] Created Network [ br-lab] <p>Tip</p> <p>Check if the Docker and Containerlab versions are compatible to avoid errors during deployment.</p>"},{"location":"en/Laborat%C3%B3rios/Contribua/Template%20lab/#4-deploying-the-lab","title":"4. Deploying the Lab","text":"<p>This topic describes the lab deployment process, with detailed instructions for the user to download and start the environment.</p>"},{"location":"en/Laborat%C3%B3rios/Contribua/Template%20lab/#41-ready-deployment","title":"4.1 Ready Deployment","text":"<p>This method allows the user to download a pre-assembled version of the lab, with the topology and configurations already defined. Simply download the repository and proceed to the start of execution.</p> <p>Tip</p> <p>Ready deployment is useful for those who want to quickly start with a configured environment but does not allow modifications to the initial topology.</p>"},{"location":"en/Laborat%C3%B3rios/Contribua/Template%20lab/#downloading-the-lab","title":"Downloading the Lab","text":"<p>To download the lab, execute the command corresponding to your operating system.</p> Linux/MacWindows <pre><code>curl -L -o get.sh \"&lt;https://git.rnp.br/redes-abertas/labs/-/raw/main/&gt;&lt;lab-name&gt;/get.sh?inline=false\" &amp;&amp; sh get.sh &amp;&amp; cd &lt;lab-name&gt;\n</code></pre> <pre><code>curl -L -o get.bat \"&lt;https://git.rnp.br/redes-abertas/labs/-/raw/main/&gt;&lt;lab-name&gt;/get.bat?inline=false\" &amp;&amp; call get.bat &amp;&amp; cd &lt;lab-name&gt;\n</code></pre> <p>This command will download the installation script and direct you to the lab directory.</p> <p>Tip</p> <p>Before running the scripts, verify that the execution permissions are correct (use <code>chmod +x get.sh</code> on Linux/Mac).</p>"},{"location":"en/Laborat%C3%B3rios/Contribua/Template%20lab/#42-custom-deployment-under-development","title":"4.2 Custom Deployment (Under Development)","text":"<p>If you want a customized version of the lab, you can start the modification using tools like NetBox and NetReplica. This step is under development, but we will have more information soon.</p> <p>Tip</p> <p>Advanced customization can be useful to adjust the topology to your specific needs, such as including more devices or testing different scenarios.</p>"},{"location":"en/Laborat%C3%B3rios/Contribua/Template%20lab/#5-starting-the-lab","title":"5. Starting the Lab","text":"<p>After downloading or customizing, follow the steps below to start the lab.</p>"},{"location":"en/Laborat%C3%B3rios/Contribua/Template%20lab/#51-deploying-the-lab","title":"5.1 Deploying the Lab","text":"<p>Run the command below inside the directory where the lab was downloaded or customized:</p> <pre><code>sudo containerlab deploy\n</code></pre> <p>This command will start the topology defined in the lab and create all the necessary containers.</p> <p>Tip</p> <p>If an error occurs, check the command output for possible error messages. Use <code>docker logs &lt;container_name&gt;</code> to debug.</p>"},{"location":"en/Laborat%C3%B3rios/Contribua/Template%20lab/#6-access","title":"6. Access","text":"<p>After the lab is started, you can access the devices and services configured in the network.</p>"},{"location":"en/Laborat%C3%B3rios/Contribua/Template%20lab/#61-table-of-ips-and-service-ports","title":"6.1 Table of IPs and Service Ports","text":"<p>Here is an example table of devices, IPs, and service ports available in the lab.</p> Device Access IP Port Service Router 1 192.168.1.1 22 SSH Router 2 192.168.1.2 22 SSH Monitoring Server 192.168.1.3 8080 Web (Graphite) DB Server 192.168.1.4 3306 MySQL"},{"location":"en/Laborat%C3%B3rios/Contribua/Template%20lab/#62-access-passwords","title":"6.2 Access Passwords","text":"<p>Here is an example table with the access passwords for the services configured in the lab.</p> Service User Password Router 1 (SSH) admin admin@123 Router 2 (SSH) admin admin@123 Graphite (Web) admin admin@123 MySQL Database root mysql@123 <p>Attention</p> <p>Before accessing, access the log of a device to verify that it has been started and configured correctly.</p>"},{"location":"en/Laborat%C3%B3rios/Contribua/Template%20lab/#7-next-steps","title":"7.  Next Steps","text":"<p>this part is intended for what to do after starting the laboratory. you can add other guides here such as using some tool or operation of the laboratory</p>"},{"location":"en/Laborat%C3%B3rios/Contribua/Template%20lab/#conclusion-delete-later","title":"Conclusion (Delete Later)","text":"<p>This template is designed to serve as the standard structure for documentation of all project labs. It should be followed consistently to ensure clarity and standardization in the creation of new labs. The described sections are essential and applicable to any lab within Containerlab, with the aim of providing a smooth experience for both developers and users, without changing the structure of the documentation and without adding anything and not changing the links or references.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/","title":"Juniper Vjuniper Discovery","text":""},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#introduction","title":"Introduction","text":"<p>This lab simulates a network with 3 routers configured with OSPF and SNMP, integrating Zabbix and Netbox for automated device import and management.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#1-description","title":"1. Description","text":""},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#11-lab-objective","title":"1.1 Lab Objective","text":"<p>The objective of this lab is to import network devices and their configurations into Netbox from Zabbix, as well as demonstrate the basic operation of OSPF routing between three routers connected in a ring and monitored via SNMP.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#12-lab-topology","title":"1.2 Lab Topology","text":"<p>Below is the topology in image format, representing the routers, servers, and their connections.</p> <p></p> <p>The routers are configured with the following technologies:</p> <ul> <li>OSPF (Open Shortest Path First): Used for dynamic routing in the network, allowing routers to exchange information about routes and topology updates.</li> <li>SNMP (Simple Network Management Protocol): Used for network monitoring and management, allowing access to telemetry information from devices.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#2-applications","title":"2. Applications","text":""},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#examples-of-applications","title":"Examples of Applications","text":"<p>This lab is focused on practical experimentation with automatic device discovery in IP networks, integrating monitoring (Zabbix) and documentation (Netbox) tools. It is ideal for studies and training involving inventory automation, topology discovery, and network data integration.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#possible-applications","title":"Possible Applications:","text":"<ul> <li> <p>Network discovery automation: Demonstrates how to automatically identify active devices in a network using Zabbix and how to import this data into Netbox, reducing manual effort in asset mapping.</p> </li> <li> <p>NetDevOps and inventory management training: Excellent for training professionals in modern network operations practices, focusing on tool integration via API and automation of infrastructure documentation.</p> </li> <li> <p>Centralized device repository creation: Enables building a reliable database about the network in real-time, based on information discovered via SNMP and documented in Netbox.</p> </li> <li> <p>Zabbix + Netbox integration study via API: Allows exploring the use of RESTful APIs to synchronize information between monitoring and network asset management tools.</p> </li> <li> <p>SNMP discovery and centralized management teaching: Provides a practical experience for students and professionals to understand how network data collection (interfaces, IPs, manufacturers, etc.) occurs and how this data is processed by management tools.</p> </li> </ul>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#3-requirements","title":"3. Requirements","text":""},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#31-prerequisites","title":"3.1 Prerequisites","text":"<p>To start the lab, the following components must be installed and configured:</p> <ul> <li>Netbox</li> <li>Containerlab</li> <li>Docker</li> <li>Python</li> </ul> <p>If your environment is not configured, follow the steps in Configuration Guide</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#32-computational-requirements-table","title":"3.2 Computational Requirements Table","text":"Requirement Details CPUs 4 vCPUs (recommended minimum) RAM Memory 12 GB Disk Space 10 GB Containerlab 0.64.0 Created Network br-lab <p>Tip</p> <p>Check if the Docker and Containerlab versions are compatible to avoid errors during deployment.</p> <p>Attention</p> <p>Verify that your processor has hardware virtualization support and that this functionality is enabled in the BIOS/UEFI. - On Intel processors, this technology is called VT-x (Intel Virtualization Technology). - On AMD processors, it is known as AMD-V (AMD Virtualization).</p> <p>Without this functionality enabled, images such as vJunos-router will not function correctly.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#4-installation","title":"4. Installation","text":""},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#41-configuring-the-docker-network","title":"4.1 Configuring the Docker Network","text":"<p>Before starting the containers, create the bridge network that will interconnect the devices:</p> <pre><code>docker network create \\\n  --driver=bridge \\\n  --opt com.docker.network.bridge.name=br-lab \\\n  --subnet=172.10.10.0/24 \\\n  br-lab\n</code></pre>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#42-cloning-the-lab-repository","title":"4.2 Cloning the Lab Repository","text":"<p>Execute the script below to download and configure the lab automatically:</p> Linux/MacWindows <pre><code>curl -L -o get.sh \"https://git.rnp.br/redes-abertas/labs/-/raw/main/discovery-lab/get.sh?ref_type=heads&amp;inline=false\" &amp;&amp; sh get.sh &amp;&amp; cd discovery-lab\n</code></pre> <pre><code>curl -L -o get.bat \"https://git.rnp.br/redes-abertas/labs/-/raw/main/discovery-lab/get.bat?ref_type=heads&amp;inline=false\" &amp;&amp; call get.bat &amp;&amp; cd discovery-lab\n</code></pre> <p>Tip</p> <p>On Linux/Mac, use <code>chmod +x get.sh</code> before running the script if it does not have execute permission.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#5-environment-deployment","title":"5. Environment Deployment","text":""},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#51-starting-the-routers-with-containerlab","title":"5.1 Starting the Routers with Containerlab","text":"<p>Start the topology with the command:</p> <pre><code>sudo clab deploy -t clab/discovery-lab.clab.yaml\n</code></pre> <p>Debug</p> <p>Devices may take about 10 minutes to become fully operational. If an error occurs, check the command output for possible error messages. Use <code>docker logs &lt;container_name&gt;</code> to debug.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#52-starting-zabbix","title":"5.2 Starting Zabbix","text":"<p>Tip</p> <p>If you already have a configured Zabbix environment, just skip this step.</p> <p>To start the container with Zabbix:</p> <p><pre><code>docker compose -f zabbix-docker/docker-compose.yml up -d\n</code></pre> The Zabbix web interface will be available on port 81.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#6-integration-with-zabbix-and-netbox","title":"6. Integration with Zabbix and Netbox","text":"<p>In this step, you need to create an API token in both Zabbix and Netbox to add the token to the .env file.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#61-importing-routers-to-zabbix","title":"6.1 Importing Routers to Zabbix","text":"<ol> <li>Access the scripts folder: <pre><code>cd scripts/\n</code></pre></li> <li>Create and activate the Python virtual environment: <pre><code>python3 -m venv venv\nsource venv/bin/activate\n</code></pre></li> <li>Install the Python dependencies: <pre><code>pip install -r requirements.txt\n</code></pre></li> <li>Configure the environment with your credentials: <pre><code>mv .env.example .env\nnano .env\n</code></pre> Example .env: <pre><code> # Zabbix\nZABBIX_TOKEN=zabbix_token                     # API Token\nZABBIX_URL=http://yourdomain/api_jsonrpc.php  # API Access URL\nZABBIX_USER=Admin                             # Default User\nZABBIX_PASSWORD=zabbix                        # Default Password\nZABBIX_GROUP=Juniper                          # Group to add the routers to\nZABBIX_TEMPLATE=\"Juniper by SNMP\"             # Monitoring template for Juniper routers\n\n# Netbox\nNETBOX_URL=http://yourdomain/api              # API Access URL\nNETBOX_TOKEN=netbox_token                     # API Token\n\n# Devices\nDEVICE_USERNAME=admin                         # Default access username for routers\nDEVICE_PASSWORD=admin@123                     # Default access password for routers\n</code></pre></li> <li>Now to import the routers into Zabbix, run the command: <pre><code>python3 import_zabbix.py\n</code></pre></li> </ol>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#62-generating-api-tokens","title":"6.2 Generating API Tokens","text":"<p>Creating an API Token in Zabbix.</p> <ol> <li>Access the Zabbix interface.</li> <li>Go to Users &gt; API Tokens.</li> <li>Click Create, fill in the fields, and copy the generated token.</li> <li>Update the <code>ZABBIX_TOKEN</code> field in <code>.env</code>.</li> </ol> <p>Creating an API Token in Netbox.</p> <ol> <li>Access the Netbox interface.</li> <li>Navigate to Admin &gt; API Tokens.</li> <li>Click Add, associate it with a user, and copy the token.</li> <li>Update the <code>NETBOX_TOKEN</code> field in <code>.env</code>.</li> </ol>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#63-importing-routers-to-netbox","title":"6.3 Importing Routers to Netbox","text":"<p>Now with the environment fully configured, you can import the routers into Netbox with the command: <pre><code>python3 import_netbox.py\n</code></pre></p> <p>With the script successful, you can view the routers within Netbox with their respective information!</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#7-access","title":"7. Access","text":"<p>After the lab is started, you can access the devices and services configured on the network.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#71-table-of-ips-and-service-ports","title":"7.1 Table of IPs and Service Ports","text":"<p>Here is the table of devices, IPs, and service ports available in the lab.</p> Device Access IP Port Service GO 172.10.10.12 22 SSH MS 172.10.10.17 22 SSH MT 172.10.10.18 22 SSH Monitoring Server 172.20.20.1 8080 Web (Graphite) Zabbix Server 172.10.10.115 81 Zabbix"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#72-access-passwords","title":"7.2 Access Passwords","text":"<p>Here is the table with the access passwords for the services configured in the lab.</p> Service User Password AC (SSH) admin admin@123 MS (SSH) admin admin@123 MT (SSH) admin admin@123 Graphite (Web) admin admin@123 Zabbix Server(Web) Admin zabbix <p>Attention</p> <p>Before accessing, check the log of a device to verify that it has been started and configured correctly.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#8-next-steps","title":"8. Next Steps","text":"<p>With the lab completed, you can follow some steps below as extra.</p> <ul> <li>Monitor the routers via SNMP in the Zabbix interface.</li> <li>Explore Netbox to view and manage the network inventory.</li> <li>Modify the topology as needed (in future custom versions).</li> <li>Consult the OSPF guide to validate dynamic communication between routers.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta/#9-conclusion","title":"9. Conclusion","text":"<p>\u2705 Done! Your environment is now configured, monitored, and documented in Netbox. Feel free to customize or expand the topology according to the objectives of your study or project. without changing the structure of the documentation, and without adding anything or changing the links or references.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/","title":"Juniper vJuniper Discovery","text":""},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#introduction","title":"Introduction","text":"<p>This lab simulates a network with 3 routers configured with OSPF and SNMP, integrating the Diode components (plugin, server, and agent) and Netbox for automated device import and management.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#1-description","title":"1. Description","text":""},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#11-lab-objective","title":"1.1 Lab Objective","text":"<p>The objective of this lab is to demonstrate, in a practical way, the process of automated import of network devices and their respective configurations into Netbox, using the diode-plugin, diode-server, and orb-agent.</p> <p></p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#12-lab-topology","title":"1.2 Lab Topology","text":"<p>Below is the topology in image format, representing the routers, servers, and their connections.</p> <p></p> <p>The routers are configured with the following technologies:</p> <ul> <li>OSPF (Open Shortest Path First): Used for dynamic routing in the network, allowing routers to exchange information about routes and topology updates.</li> <li>SNMP (Simple Network Management Protocol): Used for network monitoring and management, allowing access to telemetry information from devices.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#2-applications","title":"2. Applications","text":""},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#application-examples","title":"Application Examples","text":"<p>This lab is focused on practical experimentation with discovery and automatic import of devices in IP networks, integrating Diode and Netbox.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#possible-applications","title":"Possible Applications:","text":"<ul> <li>Network discovery automation: Automatic identification of devices and registration in Netbox.</li> <li>Training in NetDevOps and inventory management: Training in the integration of network documentation tools via API.</li> <li>Creation of a centralized device repository: Building a reliable database of network data in real time.</li> <li>Study of Diode + Netbox integration via API: Demonstrates how the agent collects, the server processes, and the plugin registers in the inventory.</li> <li>Teaching SNMP discovery and centralized management: Practice in collecting and integrating network data.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#3-requirements","title":"3. Requirements","text":""},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#31-prerequisites","title":"3.1 Prerequisites","text":"<p>To start the lab, it is necessary to install and configure the following components:</p> <ul> <li>Netbox</li> <li>Diode Plugin</li> <li>Diode Server</li> <li>Orb Agent</li> <li>Containerlab</li> <li>Docker</li> </ul> <p>If your environment is not configured, follow the steps in Configuration Guide</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#32-computational-requirements-table","title":"3.2 Computational Requirements Table","text":"Requirement Details CPUs 4 vCPUs (minimum recommended) RAM Memory 12 GB Disk Space 10 GB Containerlab 0.64.0 Created Network br-lab <p>Tip</p> <p>Check if the Docker and Containerlab versions are compatible to avoid errors during deployment.</p> <p>Attention</p> <p>Verify that your processor has hardware virtualization support and that this feature is enabled in the BIOS/UEFI. - In Intel processors, this technology is called VT-x (Intel Virtualization Technology). - In AMD processors, it is known as AMD-V (AMD Virtualization).</p> <p>Without this feature enabled, images like vJunos-router will not work correctly.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#4-installation","title":"4. Installation","text":""},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#41-configuring-the-docker-network","title":"4.1 Configuring the Docker Network","text":"<p>Before starting the containers, create the bridge network that will interconnect the devices:</p> <pre><code>docker network create \\\n  --driver=bridge \\\n  --opt com.docker.network.bridge.name=br-lab \\\n  --subnet=172.10.10.0/24 \\\n  br-lab\n</code></pre>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#42-cloning-the-lab-repository","title":"4.2 Cloning the Lab Repository","text":"<p>Execute the script below to download and configure the lab automatically:</p> Linux/MacWindows <pre><code>curl -L -o get.sh \"https://git.rnp.br/redes-abertas/labs/-/raw/main/discovery-lab-diode/get.sh?ref_type=heads&amp;inline=false\" &amp;&amp; sh get.sh &amp;&amp; cd discovery-lab\n</code></pre> <pre><code>curl -L -o get.bat \"https://git.rnp.br/redes-abertas/labs/-/raw/main/discovery-lab-diode/get.bat?ref_type=heads&amp;inline=false\" &amp;&amp; call get.bat &amp;&amp; cd discovery-lab\n</code></pre> <p>Tip</p> <p>In Linux/Mac, use <code>chmod +x get.sh</code> before running the script if it does not have execution permission.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#5-environment-deployment","title":"5. Environment Deployment","text":""},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#51-spinning-up-the-routers-with-containerlab","title":"5.1 Spinning up the Routers with Containerlab","text":"<p>Start the topology with the command:</p> <pre><code>sudo clab deploy -t clab/discovery-lab.clab.yaml\n</code></pre> <p>Debug</p> <p>The devices may take about 10 minutes to be fully operational. If an error occurs, check the command output for possible error messages. Use <code>docker logs &lt;container_name&gt;</code> to debug.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#52-launching-the-diode-server","title":"5.2 Launching the Diode Server","text":"<p>Tip</p> <p>If you already have the Diode server configured, simply skip this step.</p> <ol> <li> <p>Let's create a new folder to store the diode-server files: <pre><code>mkdir diode-server\ncd diode-server\n</code></pre></p> </li> <li> <p>Now, let's download the quick start script: <pre><code>curl -sSfLo quickstart.sh https://raw.githubusercontent.com/netboxlabs/diode/release/diode-server/docker/scripts/quickstart.sh\nchmod +x quickstart.sh\n</code></pre></p> </li> <li> <p>Then, simply run the script passing the URL of your Netbox: <pre><code>./quickstart.sh https://&lt;netbox-server&gt;\n</code></pre></p> </li> <li> <p>Finally, just start the containers: <pre><code>docker compose up -d\n</code></pre></p> </li> <li> <p>To extract the credentials required for plugin installation, execute the command below: <pre><code>echo $(jq -r '.[] | select(.client_id == \"netbox-to-diode\") | .client_secret' ./oauth2/client/client-credentials.json)\n</code></pre></p> </li> </ol> <p>Tip</p> <p>Store the token, you will need to add it in the following configuration.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#53-installing-the-plugin-in-netbox","title":"5.3 Installing the Plugin in Netbox","text":"<p>In this step, we will install the Diode plugin, responsible for establishing the connection between the Diode server and Netbox.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#531-configuring-the-netbox-version","title":"5.3.1 Configuring the Netbox version:","text":"<ol> <li>First, let's clone the Netbox Docker repository: <pre><code>git clone -b release https://github.com/netbox-community/netbox-docker.git\n</code></pre></li> <li>Now, let's go to Release 3.2.1: <pre><code>cd netbox-docker/\ngit checkout 3.2.1\n</code></pre></li> </ol> <p>Information</p> <p>We changed the repository branch to have access to Netbox version 4.2.4.</p> <p>Tip</p> <p>All commands below will be executed within the Netbox root directory <code>netbox-docker/</code>.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#532-plugin_requirementstxt","title":"5.3.2 plugin_requirements.txt","text":"<p>This file contains a list of Netbox plugins (as PyPO Python packages) that should be installed during the Docker image build.</p> <p>Execute the following command to write the package inside the <code>plugin_requirements.txt</code> file.</p> <pre><code>echo \"netboxlabs-diode-netbox-plugin\" &gt;&gt; plugin_requirements.txt\n</code></pre>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#533-dockerfile-plugins","title":"5.3.3 DockerFile-Plugins","text":"<p>This is the DockerFile used to build the customized Docker image.</p> <ol> <li> <p>Create the file and access it with an editor: <pre><code>nano DockerFile-Plugins\n</code></pre></p> </li> <li> <p>Copy the content below and paste it into the file: <pre><code>FROM netboxcommunity/netbox:v4.2.4\n\nCOPY ./plugin_requirements.txt /opt/netbox/\nRUN /usr/local/bin/uv pip install -r /opt/netbox/plugin_requirements.txt\n</code></pre></p> </li> </ol>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#534-docker-composeoverrideyml","title":"5.3.4. docker-compose.override.yml","text":"<p>As the name implies, this file contains the configurations that will override <code>docker-compose.yml</code>.</p> <p>If you have not yet configured the <code>br-lab</code> network. Access: Configuring the Docker Network</p> <ol> <li> <p>Create the file and access it with an editor: <pre><code>nano docker-compose.override.yml\n</code></pre></p> </li> <li> <p>Copy the content below and paste it into the file: <pre><code>services:\n  netbox:\n    image: netbox:latest-plugins\n    pull_policy: never\n    ports:\n      - 8000:8080\n    build:\n      context: .\n      dockerfile: Dockerfile-Plugins\n    networks:\n      - br-lab\n\n  netbox-worker:\n    image: netbox:latest-plugins\n    pull_policy: never\n    networks:\n      - br-lab\n\n  netbox-housekeeping:\n    image: netbox:latest-plugins\n    pull_policy: never\n    networks:\n      - br-lab\n\n  postgres:\n    networks:\n      - br-lab\n\n  redis:\n    networks:\n      - br-lab\n\n  redis-cache:\n    networks:\n      - br-lab\n\nnetworks:\n  br-lab:\n    external: true\n</code></pre></p> </li> </ol> <p>The changes made were:</p> <ul> <li>Adding Netbox to the <code>br-lab</code> network.</li> <li>Changing the dockerfile to <code>Dockerfile-Plugins</code>, created previously.</li> <li>Also changed the image of the services to: <code>netbox:latest-plugins</code>.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#535-pluginspy","title":"5.3.5. plugins.py","text":"<p>This file is responsible for setting the specific configurations for each plugin.</p> <ol> <li> <p>Access the file with the editor: <pre><code>nano configuration/plugins.py\n</code></pre></p> </li> <li> <p>Copy and paste the content into the file: <pre><code>PLUGINS = [\n    \"netbox_diode_plugin\",\n]\n\nPLUGINS_CONFIG = {\n    \"netbox_diode_plugin\": {\n        # Diode gRPC target for communication with Diode server\n        \"diode_target_override\": \"grpc://localhost:8080/diode\",\n\n        # Username associated with changes applied via plugin\n        \"diode_username\": \"diode\",\n\n        # netbox-to-diode client_secret created during diode bootstrap.\n        \"netbox_to_diode_client_secret\": \"...\"\n    },\n}\n</code></pre></p> </li> </ol> <p>Tip</p> <p>The token stored during the diode-server installation must be passed in the option: <code>netbox_to_diode_client_secret</code>.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#536-build-and-deploy","title":"5.3.6 Build and Deploy!","text":"<p>Now your Netbox is configured and ready for deployment, follow the commands below and build the new Netbox instance!</p> <ol> <li> <p>Build the image: <pre><code>docker compose build --no-cache\n</code></pre></p> </li> <li> <p>Start the containers: <pre><code>docker compose up -d\n</code></pre></p> </li> <li> <p>Create the necessary migrations with the command below: <pre><code>docker compose exec -it netbox ./manage.py migrate netbox_diode_plugin\n</code></pre></p> </li> </ol>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#537-generating-credentials-for-the-agent","title":"5.3.7. Generating credentials for the agent","text":"<p>We need to create credentials for the Diode agent to communicate and pass the collected data from the devices to the Diode server.</p> <ol> <li>Access your Netbox and go to the side menu.</li> <li>Go to <code>Diode</code> &gt; <code>Client Credentials</code>.</li> <li>Click the <code>Add Credential</code> button at the top.</li> <li>Enter a name for your credential.</li> <li>Store the <code>Client Id</code> and <code>Client Secret</code>.</li> </ol>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#6-orb-agent","title":"6. Orb-Agent","text":"<p>The orb-agent is a diode component responsible for collecting data from devices.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#61-configuring-the-agent","title":"6.1 Configuring the agent","text":"<ol> <li> <p>Access the <code>orb-agent</code> folder: <pre><code>cd ./orb-agent\n</code></pre></p> </li> <li> <p>In the <code>.env</code> file, configure the variables according to your environment. <pre><code>DOCKER_NETWORK=br-lab           # Container Network\nDOCKER_SUBNET=172.10.10.0/24    # Devices Network\nDIODE_CLIENT_ID=                # Diode Client Id\nDIODE_CLIENT_SECRET=            # Diode Client Secret\nDIODE_HOST=&lt;your-ip&gt;:8080       # Diode Server Url\nAGENT_NAME=agent1               # Agent Name\nSITE_NAME=RNP                   # Netbox Site Name\nDEVICE_USERNAME=admin           # Device username\nJUNIPER_PASSWORD=admin@123      # Device Password\nJUNIPER_COMMUNITY=\"public\"      # Device Community\n</code></pre></p> </li> </ol> <p>Here are the <code>Client Id</code> and <code>Client Secret</code> generated in the Diode plugin in Netbox.</p> <ol> <li>Now, let's apply the variables to the Juniper import template with the command: <pre><code>set -o allexport &amp;&amp; source .env &amp;&amp; envsubst &lt; ./juniper/agent.device.template.yaml &gt; agent.yaml\n</code></pre></li> </ol>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#62-starting-data-collection","title":"6.2 Starting data collection","text":"<p>Finally, just bring up the container to start importing devices into Netbox!</p> <pre><code>docker compose up\n</code></pre> <p>\u2705 Follow in real time on Netbox the devices being collected by the agent.</p> <p>\u23f1\ufe0f In addition, you can configure a collection interval so that the agent performs the import automatically and periodically, without the need for manual intervention.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#7-access","title":"7. Access","text":"<p>After the lab is started, you can access the devices and services configured on the network.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#71-table-of-ips-and-service-ports","title":"7.1 Table of IPs and Service Ports","text":"<p>Here is the table of devices, IPs, and service ports available in the lab.</p> Device Access IP Port Service GO 172.10.10.12 22 SSH MS 172.10.10.17 22 SSH MT 172.10.10.18 22 SSH Monitoring Server 172.20.20.1 8081 Web (Graphite) Netbox localhost 8000 Zabbix"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#72-access-passwords","title":"7.2 Access Passwords","text":"<p>Here is the table with the access passwords for the services configured in the lab.</p> Service User Password AC (SSH) admin admin@123 MS (SSH) admin admin@123 MT (SSH) admin admin@123 Graphite (Web) admin admin@123 Netbox (Web) Admin Admin <p>Attention</p> <p>Before accessing, check the log of a device to verify that it has been started and configured correctly.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#8-next-steps","title":"8. Next Steps","text":"<p>With the lab completed, you can follow some steps below as extra.</p> <ul> <li>Explore other types of import, such as Network and SNMP discovery.</li> <li>Explore Netbox to view and manage the network inventory.</li> <li>Modify the topology as needed (in future custom versions).</li> <li>Consult the settings imported by the agent.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Descoberta-Diode/#9-conclusion","title":"9. Conclusion","text":"<p>\u2705 Ready! Now you know how to use the Diode components to import your own network into Netbox, so you can also generate your own Digital Twin through Netreplica!</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/","title":"Juniper vJunos ELK Monitoring","text":"<p>This lab simulates, via Containerlab, the interconnection between three routers representing the GO-MS-MT connection in the RNP backbone, with dynamic routing via OSPF, flow export via IPFIX, and analysis/visualization via Elastic Stack (Elasticsearch, Kibana, Fleet Server, and Elastic Agent).</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#1-description","title":"1. Description","text":""},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#11-lab-objective","title":"1.1 Lab Objective","text":"<p>The main objective of the <code>elk-lab</code> is to simulate the sending and analysis of IPFIX traffic flows in a topology of three interconnected routers (GO, MS, and MT), using OSPF for dynamic routing and Elastic Stack tools for real-time observability and traffic analysis.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#12-lab-topology","title":"1.2 Lab Topology","text":"<p>Topology Description</p> <ul> <li>Three routers (GO, MS, MT) interconnected in a linear topology with point-to-point /31 links.</li> <li>Dynamic routing via OSPF.</li> <li>IPFIX flow export to the Fleet Server.</li> <li>Elastic Agent installed to receive flows and send them to Elasticsearch.</li> <li>Data visualization and analysis via Kibana.</li> <li><code>br-lab</code> external network connects the network elements to the ELK stack.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#2-applications","title":"2. Applications","text":""},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#application-examples","title":"Application Examples","text":"<p>The <code>elk-lab</code> can be applied to different educational and research contexts, allowing the simulation of real-world traffic export and analysis scenarios with Elastic Stack.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#possible-applications","title":"Possible Applications:","text":"<ul> <li>Teaching IPFIX in real environments: Practical application of flow export to analysis tools.</li> <li>Elastic Stack training for networks: Demonstrates IPFIX integration with Elastic Agent and the use of dashboards in Kibana.</li> <li>Network traffic and forensic analysis: Support for studies on traffic patterns, anomalies, and threats.</li> <li>Integration with Elasticsearch-based SIEMs: Evaluation of data pipelines for use with network security.</li> <li>Traffic flow visualization: Composition of dynamic real-time dashboards.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#3-requirements","title":"3. Requirements","text":"<p>Below are the minimum hardware and software requirements to run the lab. Make sure to include the essential tools like Containerlab and Docker, as well as the previously created <code>br-lab</code> network. To learn more about these items, access:</p> <ul> <li>Creating the br-lab Network</li> <li>Docker Installation</li> <li>Containerlab Installation</li> </ul> <p>And have the ELK stack previously installed. To learn more about installing Zabbix, access: ELK Installation</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#minimum-requirements-table","title":"Minimum Requirements Table:","text":"Requirement Details CPUs 6 vCPUs RAM Memory 16 GB Disk Space 15 GB (recommended) Containerlab 0.45.0 or higher Docker Engine 23.0.3 or higher Images <code>vr-vjunos:23.2R1.14</code> Docker Network <code>br-lab</code> <p>Attention</p> <p>Check if your processor has hardware virtualization support and if this feature is enabled in the BIOS/UEFI. - In Intel processors, this technology is called VT-x (Intel Virtualization Technology). - In AMD processors, it is known as AMD-V (AMD Virtualization).</p> <p>Without this feature enabled, images like vJunos-router will not work correctly.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#4-lab-deployment","title":"4. Lab Deployment","text":"<p>This method allows the user to download a pre-assembled version of the lab, with the topology and settings already defined. Simply download the repository and proceed to start the execution.</p> <p>Tip</p> <p>Ready-made deployment is useful for those who want to get started quickly with a configured environment.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#downloading-the-lab","title":"Downloading the Lab","text":"<p>Execute the script below to download the lab files:</p> Linux/MacWindows <pre><code>curl -L -o get.sh \"https://git.rnp.br/redes-abertas/labs/-/raw/main/elk-lab/get.sh?ref_type=heads&amp;inline=false\" &amp;&amp; sh get.sh &amp;&amp; cd elk-lab\n</code></pre> <pre><code>curl -L -o get.bat \"https://git.rnp.br/redes-abertas/labs/-/raw/main/elk-lab/get.bat?ref_type=heads&amp;inline=false\" &amp;&amp; call get.bat &amp;&amp; cd elk-lab\n</code></pre>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#5-starting-the-lab","title":"5. Starting the Lab","text":"<p>After downloading or customizing, follow the steps below to start the lab. Run the command below inside the downloaded directory.</p> <pre><code>sudo containerlab deploy\n</code></pre> <p>This command will start the topology defined in the lab and create all the necessary containers.</p> <p>Debugging</p> <p>Use <code>docker logs -f &lt;container_name&gt;</code> to check the status of services if something is not working.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#6-accessing-the-devices","title":"6. Accessing the Devices","text":""},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#61-ips-and-ports","title":"6.1 IPs and Ports","text":"Device Access IP Port(s) Service Router GO 172.10.10.6 22 SSH Router MS 172.10.10.7 22 SSH Router MT 172.10.10.8 22 SSH Fleet Server 172.10.10.110 8220 Data Ingestion Elasticsearch 172.10.10.108 9200 Database Kibana 172.10.10.109 5601 Web Interface"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#62-access-credentials","title":"6.2 Access Credentials","text":"Service User Password SSH Routers <code>admin</code> <code>admin@123</code> Kibana <code>elastic</code> <code>admin@123</code>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-ELK/#7-flow-collection-and-export","title":"7. Flow Collection and Export","text":"<p>To configure data collection using IPFIX, use our IPFIX configuration guide. without changing the documentation structure, adding anything, or altering links or references.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/","title":"Juniper Vjunos Telegraf Monitoring","text":"<p>This lab simulates, via Containerlab, the interconnection between three routers representing the GO\u2013MS\u2013MT connection in the RNP backbone, with dynamic routing via OSPF, flow export via IPFIX, and monitoring via SNMP/Telemetry using Telegraf, InfluxDB, Chronograf, and Grafana.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#1-description","title":"1. Description","text":""},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#11-lab-objective","title":"1.1 Lab Objective","text":"<p>The <code>telegraf-lab</code> laboratory aims to simulate traffic monitoring of a topology with three interconnected routers (GO, MS, and MT), using dynamic routing protocols (OSPF), flow export (IPFIX), and monitoring with SNMP. The collection and visualization of network metrics are performed with modern observability tools: Telegraf, InfluxDB, Chronograf, and Grafana.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#12-lab-topology","title":"1.2 Lab Topology","text":"<p>Topology Description</p> <ul> <li>Three routers (GO, MS, MT) interconnected in a linear topology with point-to-point /31 links.</li> <li>Dynamic routing via OSPF between the routers.</li> <li>Collection of traffic metrics via IPFIX and SNMP.</li> <li>Observability with the TICK stack (Telegraf, InfluxDB, Chronograf) and Grafana.</li> <li>External network <code>br-lab</code> connects the nodes to the monitoring infrastructure.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#2-applications","title":"2. Applications","text":""},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#examples-of-applications","title":"Examples of Applications","text":"<p>This lab can be explored in various academic and applied research scenarios, serving as a basis for experimentation in monitoring and visualizing traffic in networks with multiple routers.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#possible-applications","title":"Possible Applications:","text":"<ul> <li>Training network and NOC teams: Simulates real operations with OSPF, IPFIX, and SNMP, facilitating the analysis of traffic behavior.</li> <li>Traffic analysis with IPFIX: Allows exporting flows and studying traffic patterns between domains.</li> <li>Visualization of metrics with Grafana: Supports studies of performance, bottlenecks, and peak network utilization.</li> <li>Distributed monitoring with Telegraf: Evaluates the simultaneous collection of data from multiple routers with different protocols.</li> <li>Teaching routing and telemetry protocols: Ideal environment for practical advanced networking classes.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#3-requirements","title":"3. Requirements","text":"<p>Below are listed the minimum hardware and software requirements to run the lab. Be sure to include essential tools such as Containerlab and Docker, in addition to the previously created <code>br-lab</code> network. To learn more about these items, access:</p> <ul> <li>br-lab Network Creation</li> <li>Docker Installation</li> <li>Containerlab Installation</li> </ul> <p>And have the telegraf stack previously installed, to learn more about installing zabbix access: Telegraf Installation</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#minimum-requirements-table","title":"Minimum Requirements Table:","text":"Requirement Details CPUs 6 vCPUs RAM 12 GB Disk Space 10 GB (recommended) Containerlab 0.45.0 or higher Docker Engine 23.0.3 or higher Images <code>vr-vjunos:23.2R1.14</code> Docker Network <code>br-lab</code> <p>Attention</p> <p>Check if your processor has hardware virtualization support and if this feature is enabled in the BIOS/UEFI. - In Intel processors, this technology is called VT-x (Intel Virtualization Technology). - In AMD processors, it is known as AMD-V (AMD Virtualization).</p> <p>Without this feature enabled, images like vJunos-router will not work correctly.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#4-deploying-the-lab","title":"4. Deploying the Lab","text":"<p>You can deploy using a ready-made script or manually configure the lab files.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#41-ready-deployment","title":"4.1 Ready Deployment","text":"<p>This method allows the user to download a pre-assembled version of the laboratory, with the topology and configurations already defined. Just download the repository and proceed to the start of execution.</p> <p>Tip</p> <p>Ready deployment is useful for those who want to get started quickly with a configured environment.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#downloading-the-lab","title":"Downloading the Lab","text":"<p>Execute the script below to download and configure the lab automatically:</p> Linux/MacWindows <pre><code>curl -L -o get.sh \"https://git.rnp.br/redes-abertas/labs/-/raw/main/telegraf-lab/get.sh?ref_type=heads&amp;inline=false\" &amp;&amp; sh get.sh &amp;&amp; cd telegraf-lab\n</code></pre> <pre><code>curl -L -o get.bat \"https://git.rnp.br/redes-abertas/labs/-/raw/main/telegraf-lab/get.bat?ref_type=heads&amp;inline=false\" &amp;&amp; call get.bat &amp;&amp; cd telegraf-lab\n</code></pre> <p>Tip</p> <p>On Linux/Mac, use <code>chmod +x get.sh</code> before running the script if it does not have execute permission.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#5-initializing-the-lab","title":"5. Initializing the Lab","text":"<p>After downloading or customizing, follow the steps below to start the lab. Run the command below inside the downloaded directory.</p> <pre><code>sudo containerlab deploy\n</code></pre> <p>This command will create the router containers, configure the links, and start the monitoring services.</p> <p>Debugging</p> <p>Use <code>docker logs -f &lt;container_name&gt;</code> to check the status of the services if something does not work.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#6-accessing-the-devices","title":"6. Accessing the Devices","text":""},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#61-service-ips-and-ports","title":"6.1 Service IPs and Ports","text":"Device Access IP Port(s) Service Router GO 172.10.10.6 22 SSH Router MS 172.10.10.7 22 SSH Router MT 172.10.10.8 22 SSH Telegraf 172.10.10.114 161 Metrics collection InfluxDB 172.10.10.112 8086 Time series database Chronograf 172.10.10.113 8888 Analysis UI Grafana 172.10.10.111 3000 Web Dashboard Graphite 172.10.10.119 8080 Web UI (Graphite)"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#62-access-passwords","title":"6.2 Access Passwords","text":"Service User Password Routers (SSH) <code>admin</code> <code>admin@123</code> Grafana <code>admin</code> <code>admin</code> InfluxDB <code>admin</code> <code>influxpassword</code> <p>Initialization Check</p> <p>Before accessing the services, use <code>docker ps</code> and check the container logs to ensure they are working correctly.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#7-observability-and-visualization","title":"7. Observability and Visualization","text":""},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#71-telegraf","title":"7.1 Telegraf","text":"<p>Telegraf is configured to collect metrics via:</p> <ul> <li>SNMP: periodic reading of routers.</li> <li>IPFIX: export of traffic flows.</li> <li>Docker and system: collection of local container metrics.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#72-influxdb","title":"7.2 InfluxDB","text":"<p>Time series database where Telegraf metrics are stored. It can be accessed on port 8086.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#73-chronograf","title":"7.3 Chronograf","text":"<p>Web interface for analyzing metrics stored in InfluxDB. Accessible at <code>http://172.10.10.113:8888</code>.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Telegraf/#74-grafana","title":"7.4 Grafana","text":"<p>Interactive visualization platform where data is presented in custom dashboards.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/","title":"Juniper vJunos Zabbix Monitoring","text":"<p>This lab simulates, via Containerlab, the interconnection between two routers representing the BA\u2013ES connection in the RNP, with monitoring via Zabbix and SNMPv2.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#1-description","title":"1. Description","text":""},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#11-lab-objective","title":"1.1 Lab Objective","text":"<p>The \u201czabbix-rnp-lab\u201d laboratory demonstrates the simulation of the connection between two routers representing the interconnection between BA and ES in the RNP backbone, using Containerlab. Routing between devices is performed using the OSPF protocol, ensuring dynamic route exchange. The main focus is to integrate this topology with Zabbix via SNMPv2, enabling real-time monitoring. In addition, the laboratory highlights the automatic device discovery functionality on the network.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#12-lab-topology","title":"1.2 Lab Topology","text":"<p>The topology of this lab consists of two routers interconnected by a point-to-point /31 network, allowing direct communication between them. The routers are configured with OSPF to ensure dynamic routing between the interfaces. Network monitoring is done through an external network called br-lab, where the routers are connected by virtual interfaces. Through this configuration, Zabbix is able to monitor network connectivity and performance.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#2-applications","title":"2. Applications","text":""},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#application-example","title":"Application Example","text":"<p>This laboratory can be used in various academic and professional contexts. It is useful for simulating real-world network operation and monitoring scenarios, serving as an environment for validating configurations and testing interoperability between routing protocols and monitoring tools.</p> <p>Possible Applications:</p> <ul> <li>Training NOC (Network Operations Center) teams: Replicates real-world connectivity situations between routers with OSPF and monitoring via SNMP to familiarize technicians with fault detection and analysis.</li> <li>Performance evaluation of automatic discovery via SNMP: Allows testing the operation of host discovery under different network and topology conditions.</li> <li>Validation of SNMP templates in Zabbix: Can be used to validate or develop SNMP monitoring templates for routers in controlled environments.</li> <li>Teaching dynamic routing protocols: Provides a practical learning environment about configuration and route exchange via OSPF in point-to-point networks.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#3-requirements","title":"3. Requirements","text":"<p>Below are listed the minimum hardware and software requirements necessary to run the lab. Be sure to include essential tools such as Containerlab and Docker, in addition to the previously created <code>br-lab</code> network. To learn more about these items, access:</p> <ul> <li>br-lab Network Creation</li> <li>Docker Installation</li> <li>Containerlab Installation</li> <li>And have Zabbix previously installed, to learn more about Zabbix installation, access: Zabbix Installation</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#minimum-requirements-table","title":"Minimum Requirements Table:","text":"Requirement Details CPUs 4 vCPUs RAM Memory 8 GB Disk Space 10 GB (recommended) Containerlab 0.45.0 Docker Engine 23.0.3 Images <code>vr-vjunos:23.2R1.14</code> Network Created <code>br-lab</code> <p>Attention</p> <p>Check if your processor has hardware virtualization support and if this feature is enabled in the BIOS/UEFI. - In Intel processors, this technology is called VT-x (Intel Virtualization Technology). - In AMD processors, it is known as AMD-V (AMD Virtualization).</p> <p>Without this feature enabled, images such as vJunos-router will not work correctly.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#4-deploying-the-lab","title":"4. Deploying the Lab","text":"<p>Here are the instructions to deploy the lab. You can choose a ready-made deployment or a customized one.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#41-ready-made-deployment","title":"4.1 Ready-made Deployment","text":"<p>This method allows the user to download a pre-assembled version of the laboratory, with the topology and configurations already defined. Simply download the repository and proceed to the start of execution.</p> <p>Tip</p> <p>The ready-made deployment is useful for those who want to get started quickly with a configured environment.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#downloading-the-lab","title":"Downloading the Lab","text":"<p>To download the lab, run the command corresponding to your operating system.</p> Linux/MacWindows <pre><code>curl -L -o get.sh \"https://git.rnp.br/redes-abertas/labs/-/raw/main/zabbix-lab/get.sh?ref_type=heads&amp;inline=false\" &amp;&amp; sh get.sh &amp;&amp; cd zabbix-lab\n</code></pre> <pre><code>curl -L -o get.bat \"https://git.rnp.br/redes-abertas/labs/-/raw/main/zabbix-lab/get.bat?ref_type=heads&amp;inline=false\" &amp;&amp; call get.bat &amp;&amp; cd zabbix-lab\n</code></pre> <p>This command will download the installation script and direct you to the lab directory.</p> <p>Tip</p> <p>Before running the scripts, check if the execution permissions are correct (use <code>chmod +x get.sh</code> in Linux/Mac).</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#5-starting-the-lab","title":"5. Starting the Lab","text":"<p>After downloading or customizing, follow the steps below to start the lab. Run the command below inside the downloaded directory.</p> <pre><code>sudo containerlab deploy\n</code></pre> <p>This command will start the topology defined in the lab and create all the necessary containers.</p> <p>Tip</p> <p>If an error occurs, check the command output for possible error messages. Use <code>docker logs &lt;container_name&gt;</code> to debug.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#6-access","title":"6. Access","text":"<p>After the lab is started, you will be able to access the devices and services configured on the network.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#61-table-of-ips-and-service-ports","title":"6.1 Table of IPs and Service Ports","text":"<p>Here is an example of a table of devices, IPs and service ports available in the lab.</p> Device Access IP Port Service BA Router 172.10.10.6 22 SSH ES Router 172.10.10.11 22 SSH Zabbix Server 172.10.10.115 10051 Zabbix Server Zabbix Frontend 172.10.10.116 880/443 Web UI (Zabbix) Zabbix Agent 172.10.10.117 10050 Zabbix Agent Zabbix Database 172.10.10.118 5432 PostgreSQL Graphite 172.10.10.119 8080 Web UI (Graphite)"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#62-access-passwords","title":"6.2 Access Passwords","text":"Service User Password BA Router (SSH) <code>admin</code> <code>admin@123</code> ES Router (SSH) <code>admin</code> <code>admin@123</code> Zabbix (Web UI) <code>Admin</code> <code>zabbix</code> Zabbix Database <code>zabbix</code> <code>zabbixdatabase</code> <p>Attention</p> <p>Before accessing, access the log of a device to verify that it has been started and configured correctly.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vJunos/Monitoramento-Zabbix/#7-next-steps","title":"7.  Next Steps","text":"<p>When starting the lab, Zabbix will be bare without templates, to configure automatic discovery and templates, access the Configuring Auto Discovery</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vMX/Roteamento-OSPF/","title":"OSPF Routing","text":""},{"location":"en/Laborat%C3%B3rios/Juniper/vMX/Roteamento-OSPF/#introduction","title":"Introduction","text":"<p>This lab simulates a network with 3 routers in a ring topology, configured using OSPF for dynamic routing and SNMP for sending telemetry across the network.</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vMX/Roteamento-OSPF/#1-topology-and-configurations","title":"1. Topology and Configurations","text":"<p>The topology consists of three routers (PB, PE, JPA) connected in a ring. Each router is configured with network interfaces and IP addresses, as well as OSPF protocols for routing and SNMP for monitoring, as we can see in the following image.</p> <p></p> <p>The routers are configured with the following technologies:</p> <ul> <li>OSPF (Open Shortest Path First): Used for dynamic routing in the network, allowing routers to exchange information about routes and topology updates.</li> <li>SNMP (Simple Network Management Protocol): Used for network monitoring and management, allowing access to telemetry information from devices.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Juniper/vMX/Roteamento-OSPF/#2-installation","title":"2. Installation","text":""},{"location":"en/Laborat%C3%B3rios/Juniper/vMX/Roteamento-OSPF/#21-prerequisites","title":"2.1 Prerequisites:","text":"<p>To start the lab, you need to install and configure the following components:</p> <ul> <li>Netbox</li> <li>Netreplica</li> <li>Containerlab</li> </ul> <p>If your environment is not configured, follow the steps in Configuration Guide</p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vMX/Roteamento-OSPF/#22-importing-template-into-netbox","title":"2.2 Importing Template into Netbox:","text":"<p>Containerlab uses startup-config to import configurations to the equipment, these are defined in templates within Netbox.</p> <ol> <li> <p> In Netbox, create a Data source and add the git repository below: <pre><code>https://git.rnp.br/gci/dev/inovacao-ciberinfraestrutura/config-templates-data-source\n</code></pre> How to add: Render Templates - #Remote Templates</p> </li> <li> <p>Import the OSPF lab template:</p> <ol> <li>Access your Netbox and go to Provisioning &gt; Configuration Templates.</li> <li>Create a template and define a name of your choice.</li> <li>In Data Source choose the name of the data source created in step 1.</li> <li>In File Select: <code>Juniper/&lt;image&gt;/OSPF.jinja2</code>]</li> </ol> <p>Attention</p> <p>Pay attention to the device image, as configuration templates are created differently for each image type.</p> </li> <li> <p> Associating Templates to Devices:</p> <ol> <li>In your Netbox, access Devices &gt; Devices.</li> <li>Select the device you want to associate with the template and click edit. </li> <li>In the Management category, in Configuration Template select the name of the template defined in step 2.2.</li> <li>Save the changes.</li> </ol> </li> </ol>"},{"location":"en/Laborat%C3%B3rios/Juniper/vMX/Roteamento-OSPF/#23-setting-up-the-laboratory","title":"2.3 Setting up the Laboratory:","text":"<p>Now, with Netreplica we will pull the information from Netbox to assemble the <code>.clab</code> file that will be used by Containerlab to bring up the lab.</p> <ol> <li>In the folder where the Netreplica container is, give the following command to import the Netbox configurations: <pre><code>nrx -c conf/&lt;file&gt;.conf -n ospf-lab\n</code></pre></li> <li>Now with the <code>.clab</code> file created, use the command to bring up the lab: <pre><code>sudo -E clab dep -t conf/lab/ospf-lab.clab.yaml\n</code></pre></li> </ol> <p>Attention</p> <p>Devices need some time to be initialized and configured, the lab (graphite) may already be available and you will not be able to access the devices. </p> <p>Tip</p> <p>To view the container logs and check if it has been configured, you can use: <pre><code>docker logs &lt;container_name&gt; -f\n</code></pre></p>"},{"location":"en/Laborat%C3%B3rios/Juniper/vMX/Roteamento-OSPF/#3-access","title":"3. Access","text":"<p>There are two ways to access the devices on the network:</p> <ul> <li> <p>Access via SSH to the routers: Use an SSH client to connect to the routers using the IP address of each device or the name assigned by Containerlab, along with the login credentials provided. The management IP address of each router is displayed after the lab is executed by Containerlab.</p> <p>Example:</p> <pre><code>ssh admin@&lt;router_IP_address&gt;\n</code></pre> <p>or</p> <pre><code>ssh admin@&lt;router_name&gt;\n</code></pre> </li> <li> <p>Access to Graphite (Topology Server): Access Graphite through the browser using the IP address and port configured. You can also access it directly by clicking on the SSH icon on the desired router.</p> <p>URL: <code>http://&lt;Graphite_IP_address&gt;:8080/graphite/</code></p> <p>Credentials:</p> </li> <li> <p>Username: admin</p> </li> <li>Password: admin@123</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Juniper/vMX/Roteamento-OSPF/#4-monitoring","title":"4. Monitoring","text":"<p>To monitor the network and devices, you can use tools like edgeshark for packet analysis or SNMP monitoring tools.</p> <ul> <li>edgeshark: Capture and analyze network traffic for troubleshooting and performance monitoring.</li> <li>SNMP Monitoring: Use SNMP-compatible tools to monitor network performance and health metrics.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Configura%C3%A7%C3%A3o-NETCONF/#introduction","title":"Introduction","text":"<p>This lab provides a hands-on approach to configuring network devices using the NETCONF protocol and YANG data models.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Configura%C3%A7%C3%A3o-NETCONF/#prerequisites","title":"Prerequisites","text":"<ul> <li>containerlab</li> <li><code>uv</code> (if you want to create the virtual environment manually, use Python 3.12)</li> </ul> <p>To get started, clone the repository containing scripts and examples from: <pre><code>ssh://git@git.rnp.br:2022/redes-abertas/schema-driven-cfg.git\n</code></pre></p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Configura%C3%A7%C3%A3o-NETCONF/#building-the-test-environment-with-containerlab","title":"Building the Test Environment with <code>containerlab</code>","text":"<p>In this section, we will use <code>containerlab</code> to deploy a simple network topology defined in the <code>simple-lab.yaml</code> file.</p> <ol> <li> <p>Image Generation (if needed):     The virtual router images (vSRX for Juniper and NE40E for Huawei) need to be available locally. Use <code>vrnetlab</code> to build these images. Refer to the <code>vrnetlab</code> documentation for detailed instructions on how to generate the <code>VSRX 20.1R1.13</code> and <code>Huawei NE40E V800R011C00SPC607B607</code> images. The Cisco XRd image does not need to be generated in this way, as it is already a container, just follow the instructions on the containerlab website.</p> </li> <li> <p>Topology Deployment:     With the images ready, execute the following command to start the lab:</p> <p><pre><code>sudo containerlab deploy -t simple-lab.yaml\n</code></pre> <code>containerlab</code> will provision the containers and display a table with the IP addresses for each device. Note these IPs, as they will be used in the subsequent steps.</p> </li> </ol>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Configura%C3%A7%C3%A3o-NETCONF/#installing-python-dependencies","title":"Installing Python Dependencies","text":"<p>The Python scripts used in this lab have external dependencies. Follow one of the methods below to install them:</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Configura%C3%A7%C3%A3o-NETCONF/#using-uv-recommended","title":"Using <code>uv</code> (Recommended)","text":"<p>If you have <code>uv</code> installed, run the command below in the root of the cloned repository to create a virtual environment and install the dependencies:</p> <p><pre><code>uv sync\n</code></pre> Then, activate the virtual environment: <pre><code>source .venv/bin/activate\n</code></pre></p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Configura%C3%A7%C3%A3o-NETCONF/#using-pip-with-a-manual-virtual-environment","title":"Using <code>pip</code> with a Manual Virtual Environment","text":"<p>If you prefer to manage the virtual environment manually with Python 3.12+ and <code>pip</code>:</p> <ol> <li>Create a virtual environment:     <pre><code>python3 -m venv .venv\n</code></pre></li> <li>Activate the virtual environment:     <pre><code>source .venv/bin/activate\n</code></pre></li> <li>Install the dependencies:     <pre><code>pip install -r requirements.txt\n</code></pre></li> </ol>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Configura%C3%A7%C3%A3o-NETCONF/#testing-netconf-operations","title":"Testing NETCONF Operations","text":"<p>With the environment configured, we can test NETCONF operations using the <code>netconf_test.py</code> script. This script uses YAML configuration files to define the device connection parameters and XML payloads for the NETCONF operations.</p> <ol> <li> <p>Update the Device Configuration Files:     Modify the <code>huawei_device_config.yaml</code>, <code>junos_device_config.yaml</code>, and <code>cisco_device_config.yaml</code> files with the correct IP addresses of your devices (provided by <code>containerlab</code>) and the corresponding credentials.</p> <p>Example (<code>huawei_device_config.yaml</code>): <pre><code># filepath: huawei_device_config.yaml\ndevice:\nhostname: \"172.20.20.5\"\nusername: \"admin\"\npassword: \"admin\"\nport: 830\ntype: \"huaweiyang\"\n</code></pre></p> </li> <li> <p>Run the <code>netconf_test.py</code> Script:</p> <p>Script Usage: <pre><code>python netconf_test.py -c &lt;config_yaml_file&gt; -p &lt;payload_xml_file&gt;\n</code></pre></p> <p>Arguments: -   <code>-c CONFIG</code>, <code>--config CONFIG</code>: Path to the device YAML configuration file (e.g., <code>huawei_device_config.yaml</code>). -   <code>-p PAYLOAD</code>, <code>--payload PAYLOAD</code>: Path to the XML file containing the NETCONF payload (e.g., <code>xml/huawei-native-interface-ip.xml</code>).</p> <p>Example of Applying Interface Configuration on a Huawei Device: <pre><code>python netconf_test.py -c huawei_device_config.yaml -p xml/huawei-native-interface-ip.xml\n</code></pre> Access the device and verify that the IP <code>10.1.1.2/24</code> has been configured on the <code>Ethernet1/0/1</code> interface.</p> <p>To remove the configuration, use the deletion payload: <pre><code>python netconf_test.py -c huawei_device_config.yaml -p xml/huawei-native-interface-ip-delete.xml\n</code></pre></p> <p>Example of Applying Interface Configuration on a Juniper Device: <pre><code>python netconf_test.py -c junos_device_config.yaml -p xml/junos-native-interface-ip.xml\n</code></pre> Access the device and verify that the IP <code>10.1.1.2/24</code> has been configured on the <code>ge-0/0/0</code> interface.</p> <p>To remove the configuration, use the deletion payload: <pre><code>python netconf_test.py -c junos_device_config.yaml -p xml/junos-native-interface-ip-delete.xml\n</code></pre></p> <p>Example of Applying Interface Configuration on a Cisco Device: <pre><code>python netconf_test.py -c cisco_device_config.yaml -p xml/cisco-native-interface-ip.xml\n</code></pre> Access the device and verify that the IP <code>192.168.1.12</code> has been configured on the <code>GigabitEthernet0/0/0/0</code> interface.</p> <p>To remove the configuration, use the deletion payload: <pre><code>python netconf_test.py -c cisco_device_config.yaml -p xml/cisco-native-interface-ip-delete.xml\n</code></pre></p> <p>Example using OpenConfig models:</p> <p>Now try performing the same operation using OpenConfig model payloads: <pre><code>#Huawei\npython netconf_test.py -c huawei_device_config.yaml -p xml/openconfig-huawei-interface-ip.xml\n#Juniper\npython netconf_test.py -c junos_device_config.yaml -p xml/openconfig-junos-interface-ip.xml\n</code></pre></p> </li> </ol>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Configura%C3%A7%C3%A3o-NETCONF/#obtaining-yang-models-from-devices","title":"Obtaining YANG Models from Devices","text":"<p>YANG models define the structure of configuration and state data for network devices, serving as the foundation for automation and interoperability via NETCONF. Understanding and exploring these models is essential for creating correct NETCONF payloads.</p> <p>The following sections present methods for obtaining YANG models from the Huawei, Juniper, and Cisco devices in this example.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Configura%C3%A7%C3%A3o-NETCONF/#obtaining-yang-models-from-huawei-devices","title":"Obtaining YANG Models from Huawei Devices","text":"<p>For Huawei devices, we can obtain the YANG models via NETCONF without needing to alter the initial device configuration performed by containerlab. Use the <code>huawei_get_schema.py</code> script to download the models to a local folder.</p> <p>Script Usage:</p> <pre><code>python huawei_get_schema.py &lt;host&gt; &lt;username&gt; &lt;password&gt; [output_dir]\n</code></pre> <p>Arguments:</p> <ul> <li><code>host</code>: IP address or hostname of the Huawei device (obtained from <code>containerlab</code>).</li> <li><code>username</code>: Username for NETCONF authentication.</li> <li><code>password</code>: Password for NETCONF authentication.</li> <li><code>output_dir</code> (Optional): Directory to save the YANG files. Default: <code>huawei-schema</code>.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Configura%C3%A7%C3%A3o-NETCONF/#obtaining-yang-models-from-juniper-devices","title":"Obtaining YANG Models from Juniper Devices","text":"<p>For Juniper devices (Junos OS), it is recommended to obtain the YANG models directly through the equipment's CLI and transfer them to your local machine.</p> <p>Refer to the official Juniper documentation for detailed guidance.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Configura%C3%A7%C3%A3o-NETCONF/#obtaining-yang-models-from-cisco-devices","title":"Obtaining YANG models from Cisco devices","text":"<p>To obtain the YANG model from a Cisco device, execute the <code>cisco_get_schema.py</code> script as follows: <pre><code>usage: cisco_get_schema.py [-h] [--port PORT] host username password [output_dir]\narguments:\n  host          IP address or hostname of the Cisco device\n  username      Username for authentication on the device\n  password      Password for authentication on the device\n  output_dir    (Optional) Path to the directory where the YANG files will be saved - default=cisco-schema\n  --port        (Optional) NETCONF port - default=830\nex:\npython cisco_get_schema.py 192.168.1.2 admin 'password' cisco-schema --port 830\n</code></pre></p> <p>The YANG files will be downloaded and saved in the specified directory (when available, the name will follow the pattern <code>&lt;module&gt;@&lt;revision&gt;.yang</code>).</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/","title":"Diode Multivendor Discovery","text":""},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#introduction","title":"Introduction","text":"<p>This lab simulates a network with 3 routers from different vendors (Juniper, Cisco, and Huawei) configured with OSPF and SNMP, integrating Diode components (plugin, server, and agent) and Netbox for automated device import and management.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#1-description","title":"1. Description","text":""},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#11-lab-objective","title":"1.1 Lab Objective","text":"<p>The objective of this lab is to practically demonstrate the process of automated discovery and import of multivendor network devices, encompassing different models and manufacturers, and their respective configurations into Netbox, using the diode-plugin, diode-server, and orb-agent.</p> <p></p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#12-lab-topology","title":"1.2 Lab Topology","text":"<p>Below is the topology showing the three routers \u2014 Juniper, Cisco, and Huawei \u2014 in addition to the servers involved in the architecture.</p> <p></p> <p>The routers are configured with the following technologies:</p> <ul> <li>OSPF (Open Shortest Path First): Used for dynamic routing, allowing devices (regardless of manufacturer) to exchange information about routes and topology.</li> <li>SNMP (Simple Network Management Protocol): Used for telemetry collection and discovery, ensuring compatibility with Juniper, Cisco, and Huawei devices.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#2-applications","title":"2. Applications","text":""},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#examples-of-applications","title":"Examples of Applications","text":"<p>This lab demonstrates a realistic architecture for automatic device discovery in environments where multiple vendors coexist.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#possible-applications","title":"Possible Applications:","text":"<ul> <li>Multivendor discovery automation: Automatic detection of Juniper, Cisco, and Huawei devices and registration of their inventories in Netbox.</li> <li>Standardization of heterogeneous inventory: Creation of a unified device database regardless of the vendor.</li> <li>Creation of a centralized device repository: Building a reliable database of real-time network data.</li> <li>Practical study of SNMP in hybrid environments: Practical comparison between different MIBs and manufacturer standards.</li> <li>Diode + Netbox integration in real-world scenarios: Practice in collecting and integrating network data.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#3-requirements","title":"3. Requirements","text":""},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#31-prerequisites","title":"3.1 Prerequisites","text":"<p>To start the lab, it is necessary to install and configure the following components:</p> <ul> <li>Netbox</li> <li>Diode Plugin</li> <li>Diode Server</li> <li>Orb Agent</li> <li>Containerlab</li> <li>Docker</li> </ul> <p>If your environment is not configured, follow the steps in Configuration Guide</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#32-computational-requirements-table","title":"3.2 Computational Requirements Table","text":"Requirement Details CPUs 4 vCPUs (minimum recommended) RAM Memory 12 GB Disk Space 10 GB Containerlab 0.64.0 Created Network br-lab <p>Tip</p> <p>Verify that the Docker and Containerlab versions are compatible to avoid errors during deployment.</p> <p>Attention</p> <p>Verify that your processor has hardware virtualization support and that this functionality is enabled in the BIOS/UEFI. - In Intel processors, this technology is called VT-x (Intel Virtualization Technology). - In AMD processors, it is known as AMD-V (AMD Virtualization).</p> <p>Without this feature enabled, images like vJunos-router will not function correctly.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#4-installation","title":"4. Installation","text":""},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#41-configuring-the-docker-network","title":"4.1 Configuring the Docker Network","text":"<p>Before starting the containers, create the bridge network that will interconnect the devices:</p> <pre><code>docker network create \\\n  --driver=bridge \\\n  --opt com.docker.network.bridge.name=br-lab \\\n  --subnet=172.10.10.0/24 \\\n  br-lab\n</code></pre>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#42-cloning-the-lab-repository","title":"4.2 Cloning the Lab Repository","text":"<p>Execute the script below to download and configure the lab automatically:</p> Linux/MacWindows <pre><code>curl -L -o get.sh \"https://git.rnp.br/redes-abertas/labs/-/raw/main/discovery-lab-diode-multivendor/get.sh?ref_type=heads&amp;inline=false\" &amp;&amp; sh get.sh &amp;&amp; cd discovery-lab\n</code></pre> <pre><code>curl -L -o get.bat \"https://git.rnp.br/redes-abertas/labs/-/raw/main/discovery-lab-diode-multivendor/get.bat?ref_type=heads&amp;inline=false\" &amp;&amp; call get.bat &amp;&amp; cd discovery-lab\n</code></pre> <p>Tip</p> <p>On Linux/Mac, use <code>chmod +x get.sh</code> before running the script if it does not have execute permissions.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#5-environment-deployment","title":"5. Environment Deployment","text":""},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#51-starting-the-routers-with-containerlab","title":"5.1 Starting the Routers with Containerlab","text":"<p>Here, the three Juniper/Cisco/Huawei devices will be initialized. The boot time may vary depending on the manufacturer.</p> <pre><code>sudo clab deploy -t clab/discovery-lab.clab.yaml\n</code></pre> <p>Debug</p> <p>The devices may take about 10 minutes to become fully operational. If an error occurs, check the command output for possible error messages. Use <code>docker logs &lt;container_name&gt;</code> to debug.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#52-starting-the-diode-server","title":"5.2 Starting the Diode Server","text":"<p>Tip</p> <p>If you already have the Diode server configured, just skip this step.</p> <ol> <li> <p>Let's create a new folder to store the diode-server files: <pre><code>mkdir diode-server\ncd diode-server\n</code></pre></p> </li> <li> <p>Now, let's download the quick start script: <pre><code>curl -sSfLo quickstart.sh https://raw.githubusercontent.com/netboxlabs/diode/release/diode-server/docker/scripts/quickstart.sh\nchmod +x quickstart.sh\n</code></pre></p> </li> <li> <p>Then, just run the script passing the url of your netbox: <pre><code>./quickstart.sh https://&lt;netbox-server&gt;\n</code></pre></p> </li> <li> <p>Finally, just start the containers: <pre><code>docker compose up -d\n</code></pre></p> </li> <li> <p>To extract the credentials needed to install the plugin, execute the command below: <pre><code>echo $(jq -r '.[] | select(.client_id == \"netbox-to-diode\") | .client_secret' ./oauth2/client/client-credentials.json)\n</code></pre></p> </li> </ol> <p>Tip</p> <p>Store the token, you will need to add it to the configuration below.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#53-installing-the-plugin-in-netbox","title":"5.3 Installing the Plugin in Netbox","text":"<p>In this step, we will install the diode plugin, which is responsible for establishing the connection between the diode-server and Netbox.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#531-configuring-the-netbox-version","title":"5.3.1 Configuring the Netbox version:","text":"<ol> <li>First, let's clone the Netbox Docker repository: <pre><code>git clone -b release https://github.com/netbox-community/netbox-docker.git\n</code></pre></li> <li>Now, let's go to Release 3.2.1: <pre><code>cd netbox-docker/\ngit checkout 3.2.1\n</code></pre></li> </ol> <p>Information</p> <p>We changed the repository branch to have access to Netbox version 4.2.4.</p> <p>Tip</p> <p>All commands below will be executed inside the netbox root directory <code>netbox-docker/</code>.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#532-plugin_requirementstxt","title":"5.3.2 plugin_requirements.txt","text":"<p>This file contains a list of Netbox plugins (as PyPI Python packages) that must be installed during the Docker image build.</p> <p>Execute the following command to write the package inside the <code>plugin_requirements.txt</code> file.</p> <pre><code>echo \"netboxlabs-diode-netbox-plugin\" &gt;&gt; plugin_requirements.txt\n</code></pre>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#533-dockerfile-plugins","title":"5.3.3 DockerFile-Plugins","text":"<p>This is the DockerFile used to build the custom docker image.</p> <ol> <li> <p>Create the file and access it with an editor: <pre><code>nano DockerFile-Plugins\n</code></pre></p> </li> <li> <p>Copy the content below and paste it into the file: <pre><code>FROM netboxcommunity/netbox:v4.2.4\n\nCOPY ./plugin_requirements.txt /opt/netbox/\nRUN /usr/local/bin/uv pip install -r /opt/netbox/plugin_requirements.txt\n</code></pre></p> </li> </ol>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#534-docker-composeoverrideyml","title":"5.3.4. docker-compose.override.yml","text":"<p>As the name implies, this file contains the configurations that will overwrite the <code>docker-compose.yml</code>.</p> <p>If you haven't configured the <code>br-lab</code> network yet. Access: Configuring the Docker Network</p> <ol> <li> <p>Create the file and access it with an editor: <pre><code>nano docker-compose.override.yml\n</code></pre></p> </li> <li> <p>Copy the content below and paste it into the file: <pre><code>services:\n  netbox:\n    image: netbox:latest-plugins\n    pull_policy: never\n    ports:\n      - 8000:8080\n    build:\n      context: .\n      dockerfile: Dockerfile-Plugins\n    networks:\n      - br-lab\n\n  netbox-worker:\n    image: netbox:latest-plugins\n    pull_policy: never\n    networks:\n      - br-lab\n\n  netbox-housekeeping:\n    image: netbox:latest-plugins\n    pull_policy: never\n    networks:\n      - br-lab\n\n  postgres:\n    networks:\n      - br-lab\n\n  redis:\n    networks:\n      - br-lab\n\n  redis-cache:\n    networks:\n      - br-lab\n\nnetworks:\n  br-lab:\n    external: true\n</code></pre></p> </li> </ol> <p>The changes made were:</p> <ul> <li>adding Netbox to the <code>br-lab</code> network.</li> <li>changing the dockerfile to <code>Dockerfile-Plugins</code>, created previously.</li> <li>Also changed the image of the services to: <code>netbox:latest-plugins</code>.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#535-pluginspy","title":"5.3.5. plugins.py","text":"<p>This file is responsible for setting the specific configurations for each plugin.</p> <ol> <li> <p>Access the file with the editor: <pre><code>nano configuration/plugins.py\n</code></pre></p> </li> <li> <p>Copy and paste the content into the file: <pre><code>PLUGINS = [\n    \"netbox_diode_plugin\",\n]\n\nPLUGINS_CONFIG = {\n    \"netbox_diode_plugin\": {\n        # Diode gRPC target for communication with Diode server\n        \"diode_target_override\": \"grpc://localhost:8080/diode\",\n\n        # Username associated with changes applied via plugin\n        \"diode_username\": \"diode\",\n\n        # netbox-to-diode client_secret created during diode bootstrap.\n        \"netbox_to_diode_client_secret\": \"...\"\n    },\n}\n</code></pre></p> </li> </ol> <p>Tip</p> <p>The token stored during diode-server installation must be passed in the option: <code>netbox_to_diode_client_secret</code>.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#536-build-and-deploy","title":"5.3.6 Build and Deploy!","text":"<p>Now your Netbox is configured and ready for deploy, follow the commands below and build a new instance of Netbox!</p> <ol> <li> <p>Build the image: <pre><code>docker compose build --no-cache\n</code></pre></p> </li> <li> <p>Start the containers: <pre><code>docker compose up -d\n</code></pre></p> </li> <li> <p>Create the necessary migrations with the command below: <pre><code>docker compose exec -it netbox ./manage.py migrate netbox_diode_plugin\n</code></pre></p> </li> </ol>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#537-generating-credentials-for-the-agent","title":"5.3.7. Generating credentials for the agent","text":"<p>We need to create credentials for the diode agent to communicate and forward the data collected from the devices to the diode-server.</p> <ol> <li>Access your Netbox and go to the side menu.</li> <li>Go to <code>Diode</code> &gt; <code>Client Credentials</code>.</li> <li>Click on the top button <code>Add Credential</code>.</li> <li>Type a name for your credential.</li> <li>Store the <code>Client Id</code> and <code>Client Secret</code>.</li> </ol>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#6-orb-agent","title":"6. Orb-Agent","text":"<p>The orb-agent is a diode component responsible for collecting data on devices.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#61-configuring-the-agent","title":"6.1 Configuring the agent","text":"<ol> <li> <p>Access the <code>orb-agent</code> folder: <pre><code>cd ./orb-agent\n</code></pre></p> </li> <li> <p>In the <code>.env</code> file, configure the variables according to your environment. <pre><code>DOCKER_NETWORK=br-lab                      # Container Network\nDOCKER_SUBNET=172.10.10.0/24               # Devices Network\nDIODE_CLIENT_ID=                           # Diode Client Id\nDIODE_CLIENT_SECRET=                       # Diode Client Secret\nDIODE_HOST=&lt;your-ip&gt;:8080                  # Diode Server Url\nAGENT_NAME=agent1                          # Agent Name\nSITE_NAME=RNP                              # Netbox Site Name\nMULTIDEVICE_COMMUNITY=\"public\"             # Device Community\n</code></pre></p> </li> </ol> <p>Here are the <code>Client Id</code> and <code>Client Secret</code> generated in the diode plugin in Netbox.</p> <ol> <li>Now, let's apply the variables to the juniper import template with the command: <pre><code>set -o allexport &amp;&amp; source .env &amp;&amp; envsubst &lt; agent.snmp.template.yaml &gt; agent.yaml\n</code></pre></li> </ol>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#62-starting-data-collection","title":"6.2 Starting Data Collection","text":"<p>Finally, just bring up the container to start importing devices into Netbox!</p> <pre><code>docker compose up\n</code></pre> <p>\u2705 Track in real-time in Netbox the devices being collected by the agent.</p> <p>\u23f1\ufe0f In addition, you can configure a collection interval for the agent to perform the import automatically and periodically, without the need for manual intervention.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#7-access","title":"7. Access","text":"<p>After the lab is started, you can access the devices and services configured on the network.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#71-table-of-ips-and-service-ports","title":"7.1 Table of IPs and Service Ports","text":"<p>Here is the table of devices, IPs, and service ports available in the lab.</p> Device Manufacturer IP Port Service node1 Juniper 172.10.10.201 22 SSH node2 Cisco 172.10.10.202 22 SSH node3 Huawei 172.10.10.203 22 SSH Diode \u2014 localhost 8080 API Netbox \u2014 localhost 8000 Web UI Graphite \u2014 172.20.20.1 8081 Web UI"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#72-access-passwords","title":"7.2 Access Passwords","text":"<p>Here is the table with the access passwords for the services configured in the lab.</p> Service User Password node1 (SSH) admin admin@123 node2 (SSH) clab clab@123 node3 (SSH) admin admin Netbox (Web) Admin Admin <p>Attention</p> <p>Before accessing, access the log of a device to verify that it has been started and configured correctly.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#8-next-steps","title":"8. Next Steps","text":"<p>With the lab completed, you can follow some of the steps below as extra.</p> <ul> <li>Test SNMP collection differences between Juniper, Cisco, and Huawei.</li> <li>Compare the structure of MIBs used in the import.</li> <li>Add new devices from any manufacturer to check compatibility.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Descoberta-Diode/#9-conclusion","title":"9. Conclusion","text":"<p>\u2705 Now you have learned how to use Diode components to automatically import a network composed of Juniper, Cisco, and Huawei devices, building a complete inventory in Netbox and enabling the creation of your Digital Twin with Netreplica.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-ELK/","title":"Multivendor Logs ELK","text":"<p>This lab simulates, via Containerlab, the interconnection between three routers \u2014 Juniper, Huawei, and Cisco \u2014 with dynamic routing via OSPF, and log export via Syslog to an observability infrastructure based on the ELK stack (Elasticsearch, Logstash, Kibana), using Elastic Agents managed by Fleet for data collection and sending.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-ELK/#1-description","title":"1. Description","text":""},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-ELK/#11-lab-objective","title":"1.1 Lab Objective","text":"<p>The objective of this lab is to simulate the export and centralized collection of logs from routers of different manufacturers (Juniper, Huawei, and Cisco) using the Syslog protocol (UDP 514). The collection is performed by Elastic Agents, configured to receive logs directly from the devices and forward the events to Elasticsearch, under the management of the Fleet Server. The visualization and analysis of logs occur through Kibana, enabling a modern approach to multivendor observability.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-ELK/#12-lab-topology","title":"1.2 Lab Topology","text":"<p>Topology Description</p> <ul> <li>Three routers (Juniper, Cisco, Huawei) interconnected in a ring topology with point-to-point /31 links.</li> <li>Dynamic routing via OSPF between the routers.</li> <li>Log export via Syslog (UDP/514) to the monitoring server.</li> <li>Elastic Agent acts as a collector, listening on port 514/UDP, parsing the events and sending them to Elasticsearch.</li> <li>Fleet Server manages and monitors Elastic agents.</li> <li>Elasticsearch stores and indexes the received logs.</li> <li>Kibana provides the graphical interface for viewing, searching, and correlating logs.</li> <li>External network br-lab connects the routers to the ELK-based monitoring infrastructure.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-ELK/#2-applications","title":"2. Applications","text":""},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-ELK/#application-examples","title":"Application Examples","text":"<p>This lab constitutes a basis for academic and applied experimentation in monitoring, observability, and event analysis in multivendor environments, focusing on the use of the Elastic Stack and Fleet Management.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-ELK/#possible-applications","title":"Possible Applications:","text":"<ul> <li>Multivendor NOC/SOC training \u2013 Practical simulation of log export and analysis in a Juniper, Huawei, and Cisco environment.</li> <li>Syslog collection validation \u2013 Compatibility testing and log parsing via Elastic Agents without the use of Logstash.</li> <li>Real-time visualization \u2013 Creation of dashboards in Kibana for network events and metrics.</li> <li>Centralized monitoring \u2013 Use of Fleet to manage agents and collection policies in a unified way.</li> <li>Observability integration teaching \u2013 Educational application about Syslog, Elastic Agents, Fleet, Elasticsearch, and Kibana in multivendor networks.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-ELK/#3-requirements","title":"3. Requirements","text":"<p>Below are listed the minimum hardware and software requirements needed to run the lab. Be sure to include essential tools like Containerlab and Docker, in addition to the previously created <code>br-lab</code> network. To learn more about these items, access:</p> <ul> <li>Creating the br-lab Network</li> <li>Docker Installation</li> <li>Containerlab Installation</li> </ul> <p>And have the ELK stack previously installed and configured for log ingestion, to learn more about the installation access: Configuring Syslog in ELK</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-ELK/#minimum-requirements-table","title":"Minimum Requirements Table:","text":"Requirement Details CPUs 6 vCPUs RAM Memory 16 GB Disk Space 20 GB (recommended) Containerlab 0.45.0 or higher Docker Engine 23.0.3 or higher Images <code>vr-vjunos:23.2R1.14</code>, <code>vrnetlab/huawei_vrp:ne40e-8.180</code>, <code>xrd-control-plane:7.10.2</code> Docker Network <code>br-lab</code> <p>Attention</p> <p>Verify that your processor has hardware virtualization support and that this feature is enabled in the BIOS/UEFI. - In Intel processors, this technology is called VT-x (Intel Virtualization Technology). - In AMD processors, it is known as AMD-V (AMD Virtualization).</p> <p>Without this feature enabled, images such as vJunos-router will not work correctly.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-ELK/#4-deploying-the-lab","title":"4. Deploying the Lab","text":"<p>You can deploy using a ready-made script or manually configure the lab files.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-ELK/#41-ready-deployment","title":"4.1 Ready Deployment","text":"<p>This method allows the user to download a pre-assembled version of the lab, with the topology and configurations already defined. Simply download the repository and proceed to the beginning of the execution.</p> <p>Tip</p> <p>Ready deployment is useful for those who want to quickly start with a configured environment.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-ELK/#downloading-the-lab","title":"Downloading the Lab","text":"<p>Execute the script below to download and configure the lab automatically:</p> Linux/MacWindows <pre><code>curl -L -o get.sh \"https://git.rnp.br/redes-abertas/labs/-/raw/main/logs-elk-multvendor/get.sh\" &amp;&amp; sh get.sh &amp;&amp; cd logs-elk-multvendor\n</code></pre> <pre><code>curl -L -o get.bat \"https://git.rnp.br/redes-abertas/labs/-/raw/main/logs-elk-multvendor/get.bat\" &amp;&amp; call get.bat &amp;&amp; cd logs-elk-multvendor\n</code></pre> <p>Tip</p> <p>On Linux/Mac, use <code>chmod +x get.sh</code> before running the script if it does not have execute permission.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-ELK/#5-initializing-the-lab","title":"5. Initializing the Lab","text":"<p>After downloading or customizing, follow the steps below to start the lab. Execute the command below inside the downloaded directory.</p> <pre><code>sudo containerlab deploy\n</code></pre> <p>This command will create the router containers, configure the links, and start the monitoring services.</p> <p>Debugging</p> <p>Use <code>docker logs -f &lt;container_name&gt;</code> to check the status of the services if something does not work.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-ELK/#6-accessing-the-devices","title":"6. Accessing the Devices","text":""},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-ELK/#61-ips-and-ports-of-services","title":"6.1 IPs and Ports of Services","text":"Device Access IP Port(s) Service node1 172.10.10.201 22 SSH node2 172.10.10.202 22 SSH node3 172.10.10.203 22 SSH Fleet Server 172.10.10.110 8220 Data Ingestion Elasticsearch 172.10.10.108 9200 Database Kibana 172.10.10.109 5601 Web Interface Graphite 172.10.10.119 8080 Web UI (Graphite)"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-ELK/#62-access-passwords","title":"6.2 Access Passwords","text":"Service User Password node1 (SSH) <code>admin</code> <code>admin@123</code> node2 (SSH) <code>clab</code> <code>clab@123</code> node3 (SSH) <code>admin</code> <code>admin</code> Kibana <code>elastic</code> <code>admin@123</code> <p>Startup Verification</p> <p>Before accessing the services, use <code>docker ps</code> and check the container logs to ensure they are working correctly.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-ELK/#7-observability-and-visualization","title":"7. Observability and Visualization","text":"<p>Attention</p> <p>Due to the way settings are applied on the vJunos-router, syslog configuration must be done manually. Follow the step-by-step instructions below to send all system logs to the remote log server.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-ELK/#step-by-step","title":"Step by step","text":"<p>Access node1 via ssh and run:</p> <pre><code>configure\n</code></pre> <ul> <li>Enters configuration mode of Junos.</li> <li>All subsequent commands will change the device's configuration.</li> </ul> <pre><code>set system syslog host 172.10.10.110 any any\n</code></pre> <ul> <li>Sets the remote log server (172.10.10.110) as the destination.</li> <li><code>any any</code> means: send any facility (system, kernel, daemon, auth, etc.) at any severity level (emergency, alert, critical, warning, info, debug).</li> <li>In practice: all system events will be sent to this server.</li> </ul> <pre><code>set system syslog source-address 172.10.10.201\n</code></pre> <ul> <li>Defines the source IP of the log packets as 172.10.10.201 (the IP of the vJunos-router).</li> <li>This ensures that the syslog traffic leaves through the interface that has this address.</li> <li>It is important for the log server to correctly recognize the origin of the messages.</li> </ul> <pre><code>commit\n</code></pre> <ul> <li>Applies the changes made to the configuration.</li> </ul> <p>attention</p> <p>After starting the Vjunos, it may take between 3 to 6 minutes for all routes to come up and the configuration to work correctly.</p> <ul> <li>Only after this command do the logs start being sent to the configured destination.</li> </ul> <p>At the end of the deployment you will see the logs in Kibana like this:</p> <p></p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-ELK/#71-elastic-agent","title":"7.1 Elastic Agent","text":"<p>The Elastic Agent is responsible for collecting and sending logs exported via Syslog (UDP/514) by the Juniper, Huawei, and Cisco routers. It acts as a unified agent under the management of the Fleet Server, performing the parsing, enrichment, and forwarding of data directly to Elasticsearch.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-ELK/#72-elasticsearch","title":"7.2 Elasticsearch","text":"<p>Document-oriented database used to store and index the logs collected by the agents. Allows queries, aggregations, and correlations between events from different devices. Accessible via port 9200.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-ELK/#73-kibana","title":"7.3 Kibana","text":"<p>Web interface for analyzing and visualizing logs stored in Elasticsearch. Allows the creation of dashboards, real-time queries, and Fleet management. Accessible at <code>https://&lt;your IP or localhost&gt;:5601</code>.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-ELK/#74-fleet-server","title":"7.4 Fleet Server","text":"<p>The Fleet Server runs in the same container as the Elastic Agent, unifying the collection and management functions. It manages Elastic agents, applies collection policies, receives logs via Syslog (UDP/514), and sends the data to Elasticsearch. Operates on port 8220/TCP and is administered through Kibana \u2192 Management \u2192 Fleet.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-Telegraf/","title":"Multivendor Logs Telegraf","text":"<p>This lab simulates, via Containerlab, the interconnection between three routers Juniper, Huawei and Cisco, with dynamic routing via OSPF, log export via Syslog using Telegraf, InfluxDB, Chronograf and Grafana.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#1-description","title":"1. Description","text":""},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#11-lab-objective","title":"1.1 Lab Objective","text":"<p>The objective of the lab is to simulate the export of logs from three routers of different manufacturers (Juniper, Huawei and Cisco) to a centralized monitoring server, using the Syslog protocol. The monitoring system is composed of Telegraf, InfluxDB, Chronograf and Grafana, allowing the collection, storage and visualization of network metrics in real time.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#12-lab-topology","title":"1.2 Lab Topology","text":"<p>Topology Description</p> <ul> <li>Three routers (Juniper, Cisco, Huawei) interconnected in a ring topology with point-to-point /31 links.</li> <li>Dynamic routing via OSPF between routers.</li> <li>Log collection via Syslog udp (514).</li> <li>Observability with the TICK stack (Telegraf, InfluxDB, Chronograf) and Grafana.</li> <li>External network <code>br-lab</code> connects the nodes to the monitoring infrastructure.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#2-applications","title":"2. Applications","text":""},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#application-examples","title":"Application Examples","text":"<p>This lab can be explored in various academic and applied research scenarios, serving as a basis for experimentation in monitoring and traffic visualization in networks with multiple routers.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#possible-applications","title":"Possible Applications:","text":"<ul> <li>Training NOC teams in a multivendor environment: Simulates real operations with Juniper, Huawei and Cisco routers, using OSPF and log export via Syslog, allowing analysis of connectivity and troubleshooting.</li> <li>Validation and testing of log collection via Syslog: Allows you to verify the compatibility and behavior of different vendors in sending logs to Telegraf.</li> <li>Real-time metric visualization and analysis: Validate and test Grafana template forms to work with logs.</li> <li>Centralized monitoring with Telegraf: Evaluates Telegraf's ability to receive and process logs from heterogeneous devices, ensuring data integrity and consistency.</li> <li>Teaching the integration of monitoring systems: Provides practical learning on configuring Syslog, collecting metrics, and visualization in TICK stacks and Grafana in a multivendor scenario.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#3-requirements","title":"3. Requirements","text":"<p>Below are listed the minimum hardware and software requirements to run the lab. Be sure to include essential tools such as Containerlab and Docker, in addition to the previously created <code>br-lab</code> network. to learn more about these items access:</p> <ul> <li>Creation of the br-lab Network</li> <li>Docker Installation</li> <li>Containerlab Installation</li> </ul> <p>And have the telegraf stack previously installed, to learn more about installing zabbix access: Telegraf Installation</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#minimum-requirements-table","title":"Minimum Requirements Table:","text":"Requirement Details CPUs 4 vCPUs RAM Memory 8 GB Disk Space 10 GB (recommended) Containerlab 0.45.0 or higher Docker Engine 23.0.3 or higher Images <code>vr-vjunos:23.2R1.14</code>, <code>vrnetlab/huawei_vrp:ne40e-8.180</code>, <code>xrd-control-plane:7.10.2</code> Docker Network <code>br-lab</code> <p>Attention</p> <p>Check if your processor has hardware virtualization support and if this feature is enabled in the BIOS/UEFI. - In Intel processors, this technology is called VT-x (Intel Virtualization Technology). - In AMD processors, it is known as AMD-V (AMD Virtualization).</p> <p>Without this feature enabled, images such as the vJunos-router will not work correctly.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#4-deploying-the-lab","title":"4. Deploying the Lab","text":"<p>You can perform the deployment via a ready-made script or manually configure the lab files.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#41-ready-made-deployment","title":"4.1 Ready-Made Deployment","text":"<p>This method allows the user to download a pre-assembled version of the laboratory, with the topology and configurations already defined. Simply download the repository and proceed to the start of execution.</p> <p>Tip</p> <p>Ready-made deployment is useful for those who want to get started quickly with a configured environment.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#downloading-the-lab","title":"Downloading the Lab","text":"<p>Run the script below to automatically download and configure the lab:</p> Linux/MacWindows <pre><code>curl -L -o get.sh \"https://git.rnp.br/redes-abertas/labs/-/raw/main/logs-telegraf-multvendor/get.sh\" &amp;&amp; sh get.sh &amp;&amp; cd logs-telegraf-multvendor\n</code></pre> <pre><code>curl -L -o get.bat \"https://git.rnp.br/redes-abertas/labs/-/raw/main/logs-telegraf-multvendor/get.bat\" &amp;&amp; call get.bat &amp;&amp; cd logs-telegraf-multvendor\n</code></pre> <p>Tip</p> <p>On Linux/Mac, use <code>chmod +x get.sh</code> before running the script, if it does not have execute permission.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#5-initializing-the-lab","title":"5. Initializing the Lab","text":"<p>After downloading or customizing, follow the steps below to start the lab. Run the command below inside the downloaded directory.</p> <pre><code>sudo containerlab deploy\n</code></pre> <p>This command will create the router containers, configure the links, and start the monitoring services.</p> <p>Debugging</p> <p>Use <code>docker logs -f &lt;container_name&gt;</code> to check the status of the services, if something does not work.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#6-access-to-devices","title":"6. Access to Devices","text":""},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#61-ips-and-ports-of-services","title":"6.1 IPs and Ports of Services","text":"Device Access IP Port(s) Service node1 172.10.10.201 22 SSH node2 172.10.10.202 22 SSH node3 172.10.10.203 22 SSH Telegraf 172.10.10.114 161 Metrics collection InfluxDB 172.10.10.112 8086 Time series database Chronograf 172.10.10.113 8888 Analysis UI Grafana 172.10.10.111 3000 Web Dashboard Graphite 172.10.10.119 8080 Web UI (Graphite)"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#62-access-passwords","title":"6.2 Access Passwords","text":"Service User Password node1 (SSH) <code>admin</code> <code>admin@123</code> node2 (SSH) <code>clab</code> <code>clab@123</code> node3 (SSH) <code>admin</code> <code>admin</code> Grafana <code>admin</code> <code>admin</code> InfluxDB <code>admin</code> <code>influxpassword</code> <p>Initialization Verification</p> <p>Before accessing the services, use <code>docker ps</code> and check the container logs to ensure they are working correctly.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#7-observability-and-visualization","title":"7. Observability and Visualization","text":"<p>Attention</p> <p>Due to the way the configurations are applied in the vJunos-router, the syslog configuration must be done manually. Follow the step by step below to send all system logs to the remote log server.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#step-by-step","title":"Step by step","text":"<p>Access node1 via ssh and execute:</p> <pre><code>configure\n</code></pre> <ul> <li>Enters configuration mode of Junos.</li> <li>All subsequent commands will change the equipment configuration.</li> </ul> <pre><code>set system syslog host 172.10.10.114 any any\n</code></pre> <ul> <li>Defines the remote log server (172.10.10.114) as the destination.</li> <li><code>any any</code> means: send any facility (system, kernel, daemon, auth etc.) at any severity level (emergency, alert, critical, warning, info, debug).</li> <li>In practice: all system events will be sent to this server.</li> </ul> <pre><code>set system syslog source-address 172.10.10.201\n</code></pre> <ul> <li>Defines the source IP of the log packets as 172.10.10.201 (the IP of the vJunos-router).</li> <li>This ensures that the syslog traffic leaves through the interface that has that address.</li> <li>It is important for the log server to correctly recognize the origin of the messages.</li> </ul> <pre><code>commit\n</code></pre> <ul> <li>Applies the changes made to the configuration.</li> </ul> <p>attention</p> <p>After the start of Vjunos, it can take between 3 to 6 minutes to upload all routes and the configuration to work correctly.</p> <ul> <li>Only after this command do logs begin to be sent to the configured destination.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#71-telegraf","title":"7.1 Telegraf","text":"<p>Telegraf is configured to collect metrics via:</p> <ul> <li>syslog: log export</li> <li>IPFIX: traffic flow export.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#72-influxdb","title":"7.2 InfluxDB","text":"<p>Time series database where Telegraf metrics are stored. It can be accessed through port 8086.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#73-chronograf","title":"7.3 Chronograf","text":"<p>Web interface for analyzing metrics stored in InfluxDB. Accessible at <code>http://172.10.10.113:8888</code>.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Logs-Telegraf/#74-grafana","title":"7.4 Grafana","text":"<p>Interactive visualization platform where data is presented in custom dashboards.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/","title":"Multivendor Zabbix Monitoring","text":"<p>This lab, using Containerlab, simulates the interconnection of three routers from different manufacturers: vJunos (Juniper), Huawei VRP, and Cisco XRD.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#1-description","title":"1. Description","text":""},{"location":"en/Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#11-lab-objective","title":"1.1 Lab Objective","text":"<p>The \"Multivendor Zabbix Monitoring\" lab demonstrates the simulation of the interconnection of three routers from different manufacturers \u2014 vJunos (Juniper), Huawei VRP, and Cisco XRD \u2014 using Containerlab. The devices are interconnected in a ring topology, and routing is performed by the OSPF protocol, enabling dynamic route exchange. Communication with Zabbix occurs via SNMP, enabling real-time monitoring.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#12-lab-topology","title":"1.2 Lab Topology","text":"<p>The topology of this lab consists of three routers interconnected in a ring topology, allowing direct communication between the devices. Each router is configured with OSPF, ensuring dynamic routing between interfaces. Monitoring is performed from an external network called br-lab, to which the routers are connected by virtual interfaces. This configuration allows Zabbix to monitor network connectivity and performance in real-time, using SNMP as the metric collection protocol.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#2-applications","title":"2. Applications","text":""},{"location":"en/Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#application-example","title":"Application Example","text":"<p>This lab can be used in various academic and professional contexts. It is useful for simulating real-world network operation and monitoring scenarios, serving as an environment for validating configurations and testing interoperability between routing protocols and monitoring tools.</p> <p>Possible Applications:</p> <ul> <li>Training NOC (Network Operations Center) teams:     Replicates real-world connectivity situations between Juniper, Huawei, and Cisco routers in a ring topology, using OSPF and SNMP, allowing technicians to learn how to detect, analyze, and resolve faults.</li> <li>Evaluation of interoperability between vendors: Allows testing how different manufacturers interact via OSPF, analyzing route convergence, and identifying inconsistencies in the dynamic exchange of routing information.</li> <li>Validation of SNMP templates in Zabbix: Controlled environment to validate, adjust, or develop SNMP monitoring templates for multiple router manufacturers, ensuring compatibility and accuracy in metric collection.</li> <li>Teaching dynamic routing protocols: Provides practical learning on configuration, maintenance, and route exchange via OSPF in point-to-point and ring topologies, including fault analysis and reconvergence.</li> <li>Monitoring and automatic discovery tests: Allows evaluating the automatic device discovery functionality via SNMP and the real-time monitoring of connectivity and performance, simulating various network scenarios.</li> <li>Simulation of network policies and ACLs: Enables the application of traffic filtering rules and verifying their impact on communication and monitoring, with analysis of logs and SNMP traps in Zabbix.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#3-requirements","title":"3. Requirements","text":"<p>Below are the minimum hardware and software requirements needed to run the lab. Be sure to include the essential tools, such as Containerlab and Docker, in addition to the previously created <code>br-lab</code> network. To learn more about these items, access:</p> <ul> <li>Creating the br-lab Network</li> <li>Docker Installation</li> <li> </li> </ul>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#containerlab-installation","title":"Containerlab Installation","text":"And have Zabbix previously installed. To learn more about installing Zabbix, access: Zabbix Installation"},{"location":"en/Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#minimum-requirements-table","title":"Minimum Requirements Table:","text":"Requirement Details CPUs 4 vCPUs RAM Memory 8 GB Disk Space 10 GB (recommended) Containerlab 0.45.0 Docker Engine 23.0.3 Images <code>vr-vjunos:23.2R1.14</code>, <code>vrnetlab/huawei_vrp:ne40e-8.180</code>, <code>xrd-control-plane:7.10.2</code> Created Network <code>br-lab</code> <p>Attention</p> <p>Check if your processor has hardware virtualization support and if this feature is enabled in the BIOS/UEFI. - In Intel processors, this technology is called VT-x (Intel Virtualization Technology). - In AMD processors, it is known as AMD-V (AMD Virtualization).</p> <p>Without this feature enabled, images such as vJunos-router will not work correctly.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#4-deploying-the-lab","title":"4. Deploying the Lab","text":"<p>Here are the instructions to deploy the lab. You can choose between a ready deployment or a customized one.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#41-ready-deployment","title":"4.1 Ready Deployment","text":"<p>This method allows the user to download a pre-assembled version of the lab, with the topology and configurations already defined. Simply download the repository and proceed to the start of execution.</p> <p>Tip</p> <p>The ready deployment is useful for those who want to quickly start with a configured environment.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#downloading-the-lab","title":"Downloading the Lab","text":"<p>To download the lab, execute the command corresponding to your operating system.</p> Linux/MacWindows <pre><code>curl -L -o get.sh \"https://git.rnp.br/redes-abertas/labs/-/raw/main/monitoramento-zabbix-multvendor/get.sh\" &amp;&amp; sh get.sh &amp;&amp; cd monitoramento-zabbix-multvendor\n</code></pre> <pre><code>curl -L -o get.bat \"https://git.rnp.br/redes-abertas/labs/-/raw/main/monitoramento-zabbix-multvendor/get.bat\" &amp;&amp; call get.bat &amp;&amp; cd monitoramento-zabbix-multvendor\n</code></pre> <p>This command will download the installation script and direct you to the lab directory.</p> <p>Tip</p> <p>Before running the scripts, check if the execution permissions are correct (use <code>chmod +x get.sh</code> on Linux/Mac).</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#5-starting-the-lab","title":"5. Starting the Lab","text":"<p>After downloading or customizing, follow the steps below to start the lab. Run the command below inside the downloaded directory.</p> <pre><code>sudo containerlab deploy\n</code></pre> <p>This command will start the topology defined in the lab and create all the necessary containers.</p> <p>Tip</p> <p>If any errors occur, check the command output for possible error messages. Use <code>docker logs &lt;container_name&gt;</code> to debug.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#6-access","title":"6. Access","text":"<p>After the lab is started, you can access the devices and services configured in the network.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#61-table-of-ips-and-service-ports","title":"6.1 Table of IPs and Service Ports","text":"<p>Here is an example table of devices, IPs, and service ports available in the lab.</p> Device Access IP Port Service node1 172.10.10.201 22 SSH node2 172.10.10.202 22 SSH node3 172.10.10.203 22 SSH Zabbix Server 172.10.10.115 10051 Zabbix Server Zabbix Frontend 172.10.10.116 880/443 Web UI (Zabbix) Zabbix Agent 172.10.10.117 10050 Zabbix Agent Zabbix Database 172.10.10.118 5432 PostgreSQL Graphite 172.10.10.119 8080 Web UI (Graphite)"},{"location":"en/Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#62-access-passwords","title":"6.2 Access Passwords","text":"Service User Password node1 (SSH) <code>admin</code> <code>admin@123</code> node2 (SSH) <code>clab</code> <code>clab@123</code> node3 (SSH) <code>admin</code> <code>admin</code> Zabbix (Web UI) <code>Admin</code> <code>zabbix</code> Zabbix Database <code>zabbix</code> <code>zabbixdatabase</code> <p>Attention</p> <p>Before accessing, access the log of a device to verify that it has been started and configured correctly.</p>"},{"location":"en/Laborat%C3%B3rios/Multivendor/Monitoramento-Zabbix/#7-next-steps","title":"7.  Next Steps","text":"<p>When starting the lab, Zabbix will be raw without templates. To configure automatic discovery and templates, access Configuring Auto Discovery</p> <p>Attention</p> <p>Currently, automatic discovery is only adding the correct template for Juniper. For other manufacturers, you will need to add the template manually.</p> <p>without changing the structure of the documentation, adding anything, or changing the links or references.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Configura%C3%A7%C3%A3o-NETCONF/","title":"Index","text":""},{"location":"en/Laborat%C3%B3rios/Multvendor/Configura%C3%A7%C3%A3o-NETCONF/#introduction","title":"Introduction","text":"<p>This lab offers a practical approach to configuring network devices using the NETCONF protocol and YANG data models.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Configura%C3%A7%C3%A3o-NETCONF/#prerequisites","title":"Prerequisites","text":"<ul> <li>containerlab</li> <li><code>uv</code> (if you want to create the virtual environment manually, use Python 3.12)</li> </ul> <p>To get started, clone the repository containing scripts and examples from: <pre><code>ssh://git@git.rnp.br:2022/redes-abertas/schema-driven-cfg.git\n</code></pre></p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Configura%C3%A7%C3%A3o-NETCONF/#building-the-test-environment-with-containerlab","title":"Building the Test Environment with <code>containerlab</code>","text":"<p>In this section, we will use <code>containerlab</code> to deploy a simple network topology defined in the <code>simple-lab.yaml</code> file.</p> <ol> <li> <p>Image Generation (if necessary):     The images of the virtual routers (vSRX for Juniper and NE40E for Huawei) need to be available locally. Use <code>vrnetlab</code> to build these images. Refer to the <code>vrnetlab</code> documentation for detailed instructions on how to generate the <code>VSRX 20.1R1.13</code> and <code>Huawei NE40E V800R011C00SPC607B607</code> images. The Cisco XRd image does not need to be generated this way, as it is already a container, just follow the instructions on the containerlab website.</p> </li> <li> <p>Topology Deployment:     With the images ready, run the following command to start the lab:</p> <p><pre><code>sudo containerlab deploy -t simple-lab.yaml\n</code></pre> <code>containerlab</code> will provision the containers and display a table with the IP addresses for each device. Note these IPs, as they will be used in subsequent steps.</p> </li> </ol>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Configura%C3%A7%C3%A3o-NETCONF/#installing-python-dependencies","title":"Installing Python Dependencies","text":"<p>The Python scripts used in this lab have external dependencies. Follow one of the methods below to install them:</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Configura%C3%A7%C3%A3o-NETCONF/#using-uv-recommended","title":"Using <code>uv</code> (Recommended)","text":"<p>If you have <code>uv</code> installed, run the command below in the root of the cloned repository to create a virtual environment and install the dependencies:</p> <p><pre><code>uv sync\n</code></pre> Then, activate the virtual environment: <pre><code>source .venv/bin/activate\n</code></pre></p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Configura%C3%A7%C3%A3o-NETCONF/#using-pip-with-a-manual-virtual-environment","title":"Using <code>pip</code> with a Manual Virtual Environment","text":"<p>If you prefer to manage the virtual environment manually with Python 3.12+ and <code>pip</code>:</p> <ol> <li>Create a virtual environment:     <pre><code>python3 -m venv .venv\n</code></pre></li> <li>Activate the virtual environment:     <pre><code>source .venv/bin/activate\n</code></pre></li> <li>Install the dependencies:     <pre><code>pip install -r requirements.txt\n</code></pre></li> </ol>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Configura%C3%A7%C3%A3o-NETCONF/#testing-netconf-operations","title":"Testing NETCONF Operations","text":"<p>With the environment configured, we can test NETCONF operations using the <code>netconf_test.py</code> script. This script uses YAML configuration files to define the device connection parameters and XML payloads for the NETCONF operations.</p> <ol> <li> <p>Update the Device Configuration Files:     Modify the <code>huawei_device_config.yaml</code>, <code>junos_device_config.yaml</code>, and <code>cisco_device_config.yaml</code> files with the correct IP addresses of your devices (provided by <code>containerlab</code>) and the corresponding credentials.</p> <p>Example (<code>huawei_device_config.yaml</code>): <pre><code># filepath: huawei_device_config.yaml\ndevice:\nhostname: \"172.20.20.5\"\nusername: \"admin\"\npassword: \"admin\"\nport: 830\ntype: \"huaweiyang\"\n</code></pre></p> </li> <li> <p>Run the <code>netconf_test.py</code> Script:</p> <p>Script Usage: <pre><code>python netconf_test.py -c &lt;config_yaml_file&gt; -p &lt;payload_xml_file&gt;\n</code></pre></p> <p>Arguments: -   <code>-c CONFIG</code>, <code>--config CONFIG</code>: Path to the device YAML configuration file (e.g., <code>huawei_device_config.yaml</code>). -   <code>-p PAYLOAD</code>, <code>--payload PAYLOAD</code>: Path to the XML file containing the NETCONF payload (e.g., <code>xml/huawei-native-interface-ip.xml</code>).</p> <p>Example of Applying Interface Configuration to a Huawei Device: <pre><code>python netconf_test.py -c huawei_device_config.yaml -p xml/huawei-native-interface-ip.xml\n</code></pre> Access the device and verify that the IP <code>10.1.1.2/24</code> has been configured on the <code>Ethernet1/0/1</code> interface.</p> <p>To remove the configuration, use the deletion payload: <pre><code>python netconf_test.py -c huawei_device_config.yaml -p xml/huawei-native-interface-ip-delete.xml\n</code></pre></p> <p>Example of Applying Interface Configuration to a Juniper Device: <pre><code>python netconf_test.py -c junos_device_config.yaml -p xml/junos-native-interface-ip.xml\n</code></pre> Access the device and verify that the IP <code>10.1.1.2/24</code> has been configured on the <code>ge-0/0/0</code> interface.</p> <p>To remove the configuration, use the deletion payload: <pre><code>python netconf_test.py -c junos_device_config.yaml -p xml/junos-native-interface-ip-delete.xml\n</code></pre></p> <p>Example of Applying Interface Configuration to a Cisco Device: <pre><code>python netconf_test.py -c cisco_device_config.yaml -p xml/cisco-native-interface-ip.xml\n</code></pre> Access the device and verify that the IP <code>192.168.1.12</code> has been configured on the <code>GigabitEthernet0/0/0/0</code> interface.</p> <p>To remove the configuration, use the deletion payload: <pre><code>python netconf_test.py -c cisco_device_config.yaml -p xml/cisco-native-interface-ip-delete.xml\n</code></pre></p> <p>Example Using OpenConfig Models:</p> <p>Now try to perform the same operation using the OpenConfig model payloads: <pre><code>#Huawei\npython netconf_test.py -c huawei_device_config.yaml -p xml/openconfig-huawei-interface-ip.xml\n#Juniper\npython netconf_test.py -c junos_device_config.yaml -p xml/openconfig-junos-interface-ip.xml\n</code></pre></p> </li> </ol>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Configura%C3%A7%C3%A3o-NETCONF/#obtaining-yang-models-from-devices","title":"Obtaining YANG Models from Devices","text":"<p>YANG models define the structure of configuration and state data of network devices, serving as the basis for automation and interoperability via NETCONF. Understanding and exploring these models is essential for creating correct NETCONF payloads.</p> <p>Below, we present methods for obtaining YANG models from the Huawei, Juniper, and Cisco devices in this example.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Configura%C3%A7%C3%A3o-NETCONF/#obtaining-yang-models-from-huawei-devices","title":"Obtaining YANG Models from Huawei Devices","text":"<p>In the case of Huawei devices, we can obtain YANG models via NETCONF, without needing to change the initial device configuration made by containerlab. Use the <code>huawei_get_schema.py</code> script to download the models to a local folder.</p> <p>Script Usage:</p> <pre><code>python huawei_get_schema.py &lt;host&gt; &lt;username&gt; &lt;password&gt; [output_dir]\n</code></pre> <p>Arguments:</p> <ul> <li><code>host</code>: IP address or hostname of the Huawei device (obtained from <code>containerlab</code>).</li> <li><code>username</code>: Username for NETCONF authentication.</li> <li><code>password</code>: Password for NETCONF authentication.</li> <li><code>output_dir</code> (Optional): Directory to save the YANG files. Default: <code>huawei-schema</code>.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Configura%C3%A7%C3%A3o-NETCONF/#obtaining-yang-models-from-juniper-devices","title":"Obtaining YANG Models from Juniper Devices","text":"<p>For Juniper devices (Junos OS), it is recommended to obtain the YANG models directly from the equipment's CLI and transfer them to your local machine.</p> <p>Refer to the official Juniper documentation for detailed guidance.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Configura%C3%A7%C3%A3o-NETCONF/#obtaining-yang-models-from-cisco-devices","title":"Obtaining YANG Models from Cisco Devices","text":"<p>To obtain the YANG model from a Cisco device, run the <code>cisco_get_schema.py</code> script as follows: <pre><code>usage: cisco_get_schema.py [-h] [--port PORT] host username password [output_dir]\narguments:\n  host          IP address or hostname of the Cisco device\n  username      Username for authentication on the device\n  password      Password for authentication on the device\n  output_dir    (Optional) Path to the directory where the YANG files will be saved - default=cisco-schema\n  --port        (Optional) NETCONF port - default=830\nex:\npython cisco_get_schema.py 192.168.1.2 admin 'password' cisco-schema --port 830\n</code></pre></p> <p>The YANG files will be downloaded and saved to the specified directory (when available, the name will follow the pattern <code>&lt;module&gt;@&lt;revision&gt;.yang</code>).</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Logs-Telegraf/","title":"Multivendor Logs Telegraf","text":"<p>This lab simulates, via Containerlab, the interconnection between three Juniper, Huawei and Cisco routers, with dynamic routing via OSPF, log export via Syslog using Telegraf, InfluxDB, Chronograf and Grafana.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Logs-Telegraf/#1-description","title":"1. Description","text":""},{"location":"en/Laborat%C3%B3rios/Multvendor/Logs-Telegraf/#11-lab-objective","title":"1.1 Lab Objective","text":"<p>The objective of the lab is to simulate the export of logs from three routers from different manufacturers (Juniper, Huawei and Cisco) to a centralized monitoring server, using the Syslog protocol. The monitoring system is composed of Telegraf, InfluxDB, Chronograf and Grafana, allowing the collection, storage and visualization of network metrics in real time.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Logs-Telegraf/#12-lab-topology","title":"1.2 Lab Topology","text":"<p>Topology Description</p> <ul> <li>Three routers (Juniper, Cisco, Huawei) interconnected in a linear topology with point-to-point /31 links.</li> <li>Dynamic routing via OSPF between routers.</li> <li>Log collection via Syslog udp (514).</li> <li>Observability with the TICK stack (Telegraf, InfluxDB, Chronograf) and Grafana.</li> <li>External network <code>br-lab</code> connects the nodes to the monitoring infrastructure.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Logs-Telegraf/#2-applications","title":"2. Applications","text":""},{"location":"en/Laborat%C3%B3rios/Multvendor/Logs-Telegraf/#application-examples","title":"Application Examples","text":"<p>This lab can be explored in several academic and applied research scenarios, serving as a basis for experimentation with monitoring and visualization of traffic in networks with multiple routers.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Logs-Telegraf/#possible-applications","title":"Possible Applications:","text":"<ul> <li>Training of NOC teams in a multivendor environment: Simulates real operations with Juniper, Huawei and Cisco routers, using OSPF and log export via Syslog, allowing analysis of connectivity and fault resolution.</li> <li>Validation and testing of log collection via Syslog: Allows verifying the compatibility and behavior of different vendors in sending logs to Telegraf.</li> <li>Real-time metrics visualization and analysis: Validate and test Grafana template forms to work with logs.</li> <li>Centralized monitoring with Telegraf: Evaluates Telegraf's ability to receive and process logs from heterogeneous devices, ensuring data integrity and consistency.</li> <li>Teaching monitoring system integration: Provides practical learning about Syslog configuration, metric collection and visualization in TICK stacks and Grafana in a multivendor scenario.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Logs-Telegraf/#3-requirements","title":"3. Requirements","text":"<p>Below are listed the minimum hardware and software requirements to run the lab. Be sure to include the essential tools such as Containerlab and Docker, in addition to the previously created <code>br-lab</code> network. to learn more about these items access:</p> <ul> <li>Creation of the br-lab Network</li> <li>Docker Installation</li> <li>Containerlab Installation</li> </ul> <p>And have the telegraf stack previously installed, to learn more about installing zabbix access: Telegraf Installation</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Logs-Telegraf/#minimum-requirements-table","title":"Minimum Requirements Table:","text":"Requirement Details CPUs 4 vCPUs RAM Memory 8 GB Disk Space 10 GB (recommended) Containerlab 0.45.0 or higher Docker Engine 23.0.3 or higher Images <code>vr-vjunos:23.2R1.14</code>, <code>vrnetlab/huawei_vrp:ne40e-8.180</code>, <code>xrd-control-plane:7.10.2</code> Docker Network <code>br-lab</code> <p>Attention</p> <p>Check if your processor has hardware virtualization support and if this feature is enabled in the BIOS/UEFI. - In Intel processors, this technology is called VT-x (Intel Virtualization Technology). - In AMD processors, it is known as AMD-V (AMD Virtualization).</p> <p>Without this feature enabled, images such as the vJunos-router will not work correctly.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Logs-Telegraf/#4-deploying-the-lab","title":"4. Deploying the Lab","text":"<p>You can perform the deployment using a ready-made script or manually configure the lab files.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Logs-Telegraf/#41-ready-deployment","title":"4.1 Ready Deployment","text":"<p>This method allows the user to download a pre-assembled version of the lab, with the topology and configurations already defined. Just download the repository and proceed to the beginning of execution.</p> <p>Tip</p> <p>Ready deployment is useful for those who want to get started quickly with a configured environment.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Logs-Telegraf/#downloading-the-lab","title":"Downloading the Lab","text":"<p>Execute the script below to download and configure the lab automatically:</p> Linux/MacWindows <pre><code>curl -L -o get.sh \"https://git.rnp.br/redes-abertas/labs/-/raw/main/logs-telegraf-multvendor/get.sh\" &amp;&amp; sh get.sh &amp;&amp; cd logs-telegraf-multvendor\n</code></pre> <pre><code>curl -L -o get.bat \"https://git.rnp.br/redes-abertas/labs/-/raw/main/logs-telegraf-multvendor/get.bat\" &amp;&amp; call get.bat &amp;&amp; cd logs-telegraf-multvendor\n</code></pre> <p>Tip</p> <p>In Linux/Mac, use <code>chmod +x get.sh</code> before running the script, if it does not have execution permission.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Logs-Telegraf/#5-initializing-the-lab","title":"5. Initializing the Lab","text":"<p>After downloading or customizing, follow the steps below to start the lab. Run the command below inside the downloaded directory.</p> <pre><code>sudo containerlab deploy\n</code></pre> <p>This command will create the router containers, configure the links, and start the monitoring services.</p> <p>Debugging</p> <p>Use <code>docker logs -f &lt;container_name&gt;</code> to check the status of the services, if something does not work.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Logs-Telegraf/#6-access-to-devices","title":"6. Access to Devices","text":""},{"location":"en/Laborat%C3%B3rios/Multvendor/Logs-Telegraf/#61-ips-and-ports-of-services","title":"6.1 IPs and Ports of Services","text":"Device Access IP Port(s) Service node1 172.10.10.201 22 SSH node2 172.10.10.202 22 SSH node3 172.10.10.203 22 SSH Telegraf 172.10.10.114 161 Metric collection InfluxDB 172.10.10.112 8086 Time series database Chronograf 172.10.10.113 8888 Analysis UI Grafana 172.10.10.111 3000 Web Dashboard Graphite 172.10.10.119 8080 Web UI (Graphite)"},{"location":"en/Laborat%C3%B3rios/Multvendor/Logs-Telegraf/#62-access-passwords","title":"6.2 Access Passwords","text":"Service User Password node1 (SSH) <code>admin</code> <code>admin@123</code> node2 (SSH) <code>clab</code> <code>clab@123</code> node3 (SSH) <code>admin</code> <code>admin</code> Grafana <code>admin</code> <code>admin</code> InfluxDB <code>admin</code> <code>influxpassword</code> <p>Initialization Verification</p> <p>Before accessing the services, use <code>docker ps</code> and check the container logs to ensure they are working correctly.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Logs-Telegraf/#7-observability-and-visualization","title":"7. Observability and Visualization","text":"<p>Attention</p> <p>Due to the way configurations are applied to the vJunos-router, the syslog configuration must be done manually. Follow the step-by-step instructions below to send all system logs to the remote log server.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Logs-Telegraf/#step-by-step","title":"Step by step","text":"<p>Access node1 via ssh and execute:</p> <pre><code>configure\n</code></pre> <ul> <li>Enters configuration mode of Junos.</li> <li>All subsequent commands will change the equipment's configuration.</li> </ul> <pre><code>set system syslog host 172.10.10.114 any any\n</code></pre> <ul> <li>Defines the remote log server (172.10.10.114) as the destination.</li> <li><code>any any</code> means: send any facility (system, kernel, daemon, auth etc.) at any severity level (emergency, alert, critical, warning, info, debug).</li> <li>In practice: all system events will be sent to this server.</li> </ul> <pre><code>set system syslog host 172.10.10.114 source-address 172.10.10.201\n</code></pre> <ul> <li>Defines the source IP of the log packets as 172.10.10.201 (the IP of the vJunos-router).</li> <li>This ensures that syslog traffic leaves through the interface that has this address.</li> <li>It is important for the log server to correctly recognize the origin of the messages.</li> </ul> <pre><code>commit\n</code></pre> <ul> <li>Applies the changes made to the configuration.</li> <li>Only after this command will the logs begin to be sent to the configured destination.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Logs-Telegraf/#71-telegraf","title":"7.1 Telegraf","text":"<p>Telegraf is configured to collect metrics via:</p> <ul> <li>syslog: log export</li> <li>IPFIX: export of traffic flows.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Logs-Telegraf/#72-influxdb","title":"7.2 InfluxDB","text":"<p>Time series database where Telegraf metrics are stored. Can be accessed via port 8086.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Logs-Telegraf/#73-chronograf","title":"7.3 Chronograf","text":"<p>Web interface for analyzing metrics stored in InfluxDB. Accessible at <code>http://172.10.10.113:8888</code>.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Logs-Telegraf/#74-grafana","title":"7.4 Grafana","text":"<p>Interactive visualization platform where data is presented in customized dashboards.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Monitoramento-Zabbix/","title":"Multivendor Zabbix Monitoring","text":"<p>This lab, using Containerlab, simulates the interconnection of three routers from different vendors: vJunos (Juniper), Huawei VRP, and Cisco XRD.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Monitoramento-Zabbix/#1-description","title":"1. Description","text":""},{"location":"en/Laborat%C3%B3rios/Multvendor/Monitoramento-Zabbix/#11-lab-objective","title":"1.1 Lab Objective","text":"<p>The \"Multivendor Zabbix Monitoring\" lab demonstrates the simulation of the interconnection of three routers from different vendors\u2014vJunos (Juniper), Huawei VRP, and Cisco XRD\u2014using Containerlab. The devices are interconnected in a ring topology, and routing is performed by the OSPF protocol, allowing dynamic route exchange. Communication with Zabbix occurs via SNMP, enabling real-time monitoring.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Monitoramento-Zabbix/#12-lab-topology","title":"1.2 Lab Topology","text":"<p>The topology of this lab consists of three routers interconnected in a ring topology, allowing direct communication between the devices. Each router is configured with OSPF, ensuring dynamic routing between interfaces. Monitoring is performed from an external network called br-lab, to which the routers are connected by virtual interfaces. This configuration allows Zabbix to monitor the connectivity and performance of the network in real-time, using SNMP as the metric collection protocol.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Monitoramento-Zabbix/#2-applications","title":"2. Applications","text":""},{"location":"en/Laborat%C3%B3rios/Multvendor/Monitoramento-Zabbix/#application-example","title":"Application Example","text":"<p>This lab can be used in various academic and professional contexts. It is useful for simulating real-world network operation and monitoring scenarios, serving as an environment for validating configurations and testing interoperability between routing protocols and monitoring tools.</p> <p>Possible Applications:</p> <ul> <li>Training of NOC (Network Operations Center) teams:     Replicates real-world connectivity situations between Juniper, Huawei, and Cisco routers in a ring topology, using OSPF and SNMP, allowing technicians to learn how to detect, analyze, and resolve failures.</li> <li>Evaluation of interoperability between vendors: Allows testing how different manufacturers interact via OSPF, analyzing route convergence, and identifying inconsistencies in the dynamic exchange of routing information.</li> <li>Validation of SNMP templates in Zabbix: Controlled environment to validate, adjust, or develop SNMP monitoring templates for multiple router manufacturers, ensuring compatibility and accuracy in metric collection.</li> <li>Teaching of dynamic routing protocols: Provides practical learning about the configuration, maintenance, and exchange of routes via OSPF in point-to-point and ring topologies, including failure analysis and reconvergence.</li> <li>Monitoring and automatic discovery tests: Allows evaluating the automatic device discovery functionality via SNMP and the monitoring of connectivity and performance in real-time, simulating various network scenarios.</li> <li>Simulation of network policies and ACLs: Enables applying traffic filtering rules and verifying their impact on communication and monitoring, with analysis of logs and SNMP traps in Zabbix.</li> </ul>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Monitoramento-Zabbix/#3-requirements","title":"3. Requirements","text":"<p>Below are listed the minimum hardware and software requirements to run the lab. Be sure to include essential tools such as Containerlab and Docker, as well as the previously created <code>br-lab</code> network. To learn more about these items, access:</p> <ul> <li>Creation of the br-lab Network</li> <li>Docker Installation</li> <li> </li> </ul>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Monitoramento-Zabbix/#containerlab-installation","title":"Containerlab Installation","text":"And have Zabbix previously installed. To learn more about installing Zabbix, access: Zabbix Installation"},{"location":"en/Laborat%C3%B3rios/Multvendor/Monitoramento-Zabbix/#minimum-requirements-table","title":"Minimum Requirements Table:","text":"Requirement Details CPUs 4 vCPUs RAM Memory 8 GB Disk Space 10 GB (recommended) Containerlab 0.45.0 Docker Engine 23.0.3 Images <code>vr-vjunos:23.2R1.14</code>, <code>vrnetlab/huawei_vrp:ne40e-8.180</code>, <code>xrd-control-plane:7.10.2</code> Network Created <code>br-lab</code> <p>Attention</p> <p>Verify that your processor has hardware virtualization support and that this feature is enabled in the BIOS/UEFI. - In Intel processors, this technology is called VT-x (Intel Virtualization Technology). - In AMD processors, it is known as AMD-V (AMD Virtualization).</p> <p>Without this feature enabled, images like vJunos-router will not work correctly.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Monitoramento-Zabbix/#4-deploying-the-lab","title":"4. Deploying the Lab","text":"<p>Here are the instructions to deploy the lab. You can choose a ready-made deployment or a customized one.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Monitoramento-Zabbix/#41-ready-made-deployment","title":"4.1 Ready-Made Deployment","text":"<p>This method allows the user to download a pre-assembled version of the lab, with the topology and configurations already defined. Simply download the repository and proceed to the start of the execution.</p> <p>Tip</p> <p>Ready-made deployment is useful for those who want to start quickly with a configured environment.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Monitoramento-Zabbix/#downloading-the-lab","title":"Downloading the Lab","text":"<p>To download the lab, execute the command corresponding to your operating system.</p> Linux/MacWindows <pre><code>curl -L -o get.sh \"https://git.rnp.br/redes-abertas/labs/-/raw/main/monitoramento-zabbix-multvendor/get.sh\" &amp;&amp; sh get.sh &amp;&amp; cd monitoramento-zabbix-multvendor\n</code></pre> <pre><code>curl -L -o get.bat \"https://git.rnp.br/redes-abertas/labs/-/raw/main/monitoramento-zabbix-multvendor/get.bat\" &amp;&amp; call get.bat &amp;&amp; cd monitoramento-zabbix-multvendor\n</code></pre> <p>This command will download the installation script and direct you to the lab directory.</p> <p>Tip</p> <p>Before running the scripts, check if the execution permissions are correct (use <code>chmod +x get.sh</code> on Linux/Mac).</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Monitoramento-Zabbix/#5-starting-the-lab","title":"5. Starting the Lab","text":"<p>After downloading or customizing, follow the steps below to start the lab. Execute the command below inside the downloaded directory.</p> <pre><code>sudo containerlab deploy\n</code></pre> <p>This command will start the topology defined in the lab and create all necessary containers.</p> <p>Tip</p> <p>If an error occurs, check the command output for possible error messages. Use <code>docker logs &lt;container_name&gt;</code> to debug.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Monitoramento-Zabbix/#6-access","title":"6. Access","text":"<p>After the lab is started, you can access the devices and services configured on the network.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Monitoramento-Zabbix/#61-table-of-ips-and-service-ports","title":"6.1 Table of IPs and Service Ports","text":"<p>Here is an example of a table of devices, IPs, and service ports available in the lab.</p> Device Access IP Port Service node1 172.10.10.201 22 SSH node2 172.10.10.202 22 SSH node3 172.10.10.203 22 SSH Zabbix Server 172.10.10.115 10051 Zabbix Server Zabbix Frontend 172.10.10.116 880/443 Web UI (Zabbix) Zabbix Agent 172.10.10.117 10050 Zabbix Agent Zabbix Database 172.10.10.118 5432 PostgreSQL Graphite 172.10.10.119 8080 Web UI (Graphite)"},{"location":"en/Laborat%C3%B3rios/Multvendor/Monitoramento-Zabbix/#62-access-passwords","title":"6.2 Access Passwords","text":"Service User Password node1 (SSH) <code>admin</code> <code>admin@123</code> node2 (SSH) <code>clab</code> <code>clab@123</code> node3 (SSH) <code>admin</code> <code>admin</code> Zabbix (Web UI) <code>Admin</code> <code>zabbix</code> Zabbix Database <code>zabbix</code> <code>zabbixdatabase</code> <p>Attention</p> <p>Before accessing, access the log of a device to verify that it has been started and configured correctly.</p>"},{"location":"en/Laborat%C3%B3rios/Multvendor/Monitoramento-Zabbix/#7-next-steps","title":"7.  Next Steps","text":"<p>When starting the lab, Zabbix will be bare without templates. To configure automatic discovery and templates, access Configuring Auto Discovery</p> <p>Attention</p> <p>Currently, automatic discovery is only adding the correct template for Juniper. For other manufacturers, you must add the template manually.</p> <p>without altering the structure of the documentation, and without adding anything, and without altering the links or references.</p>"}]}